<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<title>Mono C# Compiler</title>

	<meta name="Robots" content="INDEX, FOLLOW">
	<meta http-equiv="Content-Language" content="en">
	<meta http-equiv="Content-Type" content="text/html; CHARSET=UTF-8">
	<meta name="keywords" content="mono">
	<meta name="description" content="How to install Mono">
	<meta name="author" content="Jonathan Duncan">
	<meta name="date" content="14-Apr-2004">
	<meta name="modified-by" content="Jonathan Duncan">
	<meta name="modified" content="14-Apr-2004">

	<style type="text/css" media="all"><!--  @import url(/inc/mono-main.css); --></style>
	<style type="text/css" media="all"><!--  @import url(/inc/mono-green.css); --></style>  <!-- blue=About, green=Using, orange=Contributing -->

	<!-- **************************************** -->
	<!--  BEGIN SCRIPT HEADER HERE -->
        <script type="text/javascript">
        <!--
        //var pageName;  DISABLED
        //var pageName = "FAQ";  ENABLED
        var pageName = "Quick Start";
        -->
        </script>
	<!--#include virtual="/inc/script_header.inc"-->
	<!--  END SCRIPT HEADER HERE -->
	<!-- **************************************** -->

</head>
<body>

<div id="thePage"> <!-- Start The Page -->
	    <!-- **************************************** -->
	    <!--  BEGIN RIGHT CONTENT HERE -->
	    <!--#include virtual="/inc/header_green.html"-->  <!-- blue=About, green=Using, orange=Contributing -->
	    <!--  END RIGHT CONTENT HERE -->
	    <!-- **************************************** -->
	<div id="pageBody"> <!-- Start Body -->
		<div id="leftNav"> <!-- Start Left Nav -->
				<div id="leftNavTop"></div>
					<!-- **************************************** -->
					<!--  BEGIN LEFT NAV SUB HERE -->
					<!--#include virtual="/inc/leftnav_green.inc"-->
					<!--  END LEFT NAV HERE -->
					<!-- **************************************** -->

					<!-- **************************************** -->
					<!--  BEGIN SEARCH BOX HERE -->
					<!--#include virtual="/inc/searchbox.inc"-->
					<!--  END SEARCH BOX HERE -->
					<!-- **************************************** -->
		</div> <!-- End Left Nav -->
		<div id="bodyContent"> <!-- Start Body Content -->
			<h1>MCS : the Mono C# compiler</h1>
			<ul class="head">
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#working">Working with MCS</a></li>
				<li><a href="#implementation">Implementation Details</a></li>
				<li><a href="#history">History</a></li>
				<li><a href="#qa">Q&amp;A</a></li>
			</ul>

			<a name="introduction"></a>
			<h3>Introduction</h3>
			<p>The Mono C# compiler is considered feature C# 1.0 complete at this point and mature.  MCS is able to compile itself and many more C# programs (there is a test suite included that you can use).  It is routinely used to compile Mono, roughly 1.7 million lines of C# code.</p>
			<p>The compiler is also fairly fast.  On a IBM ThinkPad t40 it compiles 18,000 lines of C# code per second.</p>
			<p>Work on C# 2.0 has started: some pieces of it are available on the standard compiler with the -2 switch (iterators, method conversions) and some others are available on the 'gmcs' branch on SVN (generics)</p>
			
			<a name="working"></a>
			<h3>Working with MCS</h3>
			<h4>Obtaining MCS</h4>
			<p>The Mono C# compiler is part of the `mcs' module in the Mono SVN you can get it from our <a href="/contributing/anonsvn.html">Anonymous SVN</a> server, or you can get nightly <a href="/downloads/">download page</a>.</p>
			
			<h4>Running MCS</h4>
			<p>MCS is written in C# and uses heavily the .NET APIs.  MCS runs on Linux with the Mono runtime and on Windows with both the .NET runtime and the Mono runtime.</p>
			
			<h4>Reporting Bugs in MCS</h4>
			<p>When you report a bug, try to provide a small test case that would show the error so we can include this as part of the Mono C# regression test suite.</p>
			<p>If the bug is an error or a warning that we do not flag, write a sample program called `csXXXX.cs' where XXXX is the code number that is used by the Microsoft C# compiler that illustrates the problem.  That way we can also do regression tests on the invalid input.</p>
			
			<a name="implementation"></a>
			<h3>Implementation details</h3>
			<h4>Phases of the compiler</h4>
			<p>The compiler has a number of phases:</p>
			
				<ul>
					<li>Lexical analyzer: hand-coded lexical analyzer that provides tokens to the parser.</li>
					<li>The Parser: the parser is implemented using Jay (A Berkeley Yacc port to Java, that I ported to C#). The parser does minimal work and syntax checking, and only constructs a parsed tree.<br/>Each language element gets its own class.  The code convention is to use an uppercase name for the language element.  So a C# class and its associated information is kept in a "Class" class, a "struct" in a "Struct" class and so on.  Statements derive from the "Statement" class, and Expressions from the Expr class.</li>
					<li>Parent class resolution: before the actual code generation, we need to resolve the parents and interfaces for interface, classe and struct definitions.</li>
					<li>Semantic analysis: since C# can not resolve in a top-down pass what identifiers actually mean, we have to postpone this decision until the above steps are finished.</li>
					<li>Code generation: The code generation is done through the System.Reflection.Emit API.</li>
				</ul>
			
			<h4>CIL Optimizations.</h4>
			<p>The compiler performs a number of simple optimizations on its input: constant folding (this is required by the C# language spec) and can perform dead code elimination.</p>
			<p>Other more interesting optimizations like hoisting are not possible at this point since the compiler output at this point does not generate an intermediate representation that is suitable to perform basic block computation.</p>
			<p>Adding an intermediate layer to enable the basic block computation to the compiler should be a simple task, but we are considering having a generic CIL optimizer.  Since all the information that is required to perform basic block-based optimizations is available at the CIL level, we might just skip this step altogether and have just a generic IL optimizer that would perform hoisting on arbitrary CIL programs, not only those produced by MCS.</p>
			<p>If this tool is further expanded to perform constant folding (not needed for our C# compiler, as it is already in there) and dead code elimination, other compiler authors might be able to use this generic CIL optimizer in their projects reducing their time to develop a production compiler.</p>
			
			<h4>Open bugs</h4>
			<p>See the <a href="bugs.html">bugs page</a> for more information.</p>
			<p>A test suite is maintained to track the progress of the compiler and various programs are routinely compiled and ran.</p>
			
			<h4>Slides</h4>
			<p>Slides for the Mono C# Compiler presentation at .NET ONE are available <a href="http://primates.ximian.com/~miguel/slides-europe-nov-2002/Mono_C_Sharp_Overview_1007.sxi">here</a> in StarOffice format.</p>
			
			<a name="history"></a>
			<h3>History</h3>
			<p>MCS was able to parse itself on April 2001, MCS compiled itself for the first time on December 28 2001.  MCS became self hosting on January 3rd, 2002.</p>
			<p>The Mono Runtime and the Mono execution engine were able to make our compiler self hosting on March 12, 2002.</p>
			
			<a name="qa"></a>
			<h3>Questions and Answers</h3>
			<p><a name="q1"></a><b>Question 1:</b> Does the Mono C# compiler support C# 2.0?</p>
			<p>At this point the Mono C# compiler supports some of the features of C# 2.0, but the support has not been completed.   To enable 2.0 features you must use the -2 flag to the compiler.</p>
			
			<p><a name="q2"></a><b>Question 2:</b> What features are available as of Feb 2004?</p>
			<p>Iterators have been implemented as well as method group implicit conversion to delegates on the main compiler branch.</p>
			<p>We have a branch of the compiler in the module `mcs/gmcs' which is where we are developing the Generics support for the compiler.  Plenty of tests work (see mcs/tests/gen-*.cs for a list of tests), but work remains to be done.</p>
			
			<p><a name="q3"></a><b>Question 3:</b> Will the C# 2.0 features be part of the Mono 1.0 release?</p>
			<p>Only a few, the generic compiler will not be part of the 1.0 stable release, but a beta preview will be distributed.</p>
			
			<p><a name="q4"></a><b>Question 4:</b> Why not write a C# front-end for GCC?</p>
			<p>I wanted to learn about C#, and this was an exercise in this task.  The resulting compiler is highly object-oriented, which has lead to a very nice, easy to follow and simple implementation of the compiler.</p>
			<p>I found that the design of this compiler is very similar to Guavac's implementation.</p>
			<p>Targeting the CIL/MSIL byte codes would require to re-architecting GCC, as GCC is mostly designed to be used for register machines.</p>
			
			<p>The GCC Java engine that generates Java byte codes cheats: it does not use the GCC backend; it has a special backend just for Java, so you can not really generate Java bytecodes from the other languages supported by GCC.</p>
			
			<p><a name="q5"></a><b>Question 5:</b> If your C# compiler is written in C#, how do you plan on getting this working on a non-Microsoft environment.</p>
			<p>We will do this through an implementation of the CLI Virtual Execution System for UNIX (our JIT engine).</p>
			<p>Our JIT engine is working for the purposes of using the compiler. The supporting class libraries are being worked on to fully support the compiler.</p>
			
			<p><a name="q6"></a><b>Question 6:</b> Do you use Bison?</p>
			<p>No, currently I am using Jay which is a port of Berkeley Yacc to Java that I later ported to C#.  This means that error recovery is not as nice as I would like to, and for some reason error productions are not being caught.</p>
			<p>In the future I want to port one of the Bison/Java ports to C# for the parser.</p>
			
			<p><a name="q7"></a><b>Question 7:</b> Should someone work on a GCC front-end to C#?</p>
			<p>I would love if someone does, and we would love to help anyone that takes on that task, but we do not have the time or expertise to build a C# compiler with the GCC engine.  I find it a lot more fun personally to work on C# on a C# compiler, which has an intrinsic beauty.</p>
			<p>We can provide help and assistance to anyone who would like to work on this task.</p>
			
			<p><a name="q8"></a><b>Question 8:</b> Should someone make a GCC backend that will generate CIL images?</p>
			<p>I would love to see a backend to GCC that generates CIL images.  It would provide a ton of free compilers that would generate CIL code.  This is something that people would want to look into anyways for Windows interoperation in the future.</p>
			<p>Again, we would love to provide help and assistance to anyone interested in working in such a project.</p>
			
			<p><a name="q9"></a><b>Question 9:</b> What about making a front-end to GCC that takes CIL images and generates native code?</p>
			<p>I would love to see this, specially since GCC supports this same feature for Java Byte Codes.  You could use the metadata library from Mono to read the byte codes (ie, this would be your "front-end") and generate the trees that get passed to the optimizer.</p>
			<p>Ideally our implementation of the CLI will be available as a shared library that could be linked with your application as its runtime support.</p>
			<p>Again, we would love to provide help and assistance to anyone interested in working in such a project.</p>
			
			<p><a name="q10"></a><b>Question 10:</b> But would this work around the GPL in the GCC compiler and allow people to work on non-free front-ends?</p>
			<p>People can already do this by targeting the JVM byte codes (there are about 130 compilers for various languages that target the JVM).</p>
			
			<p><a name="q11"></a><b>Question 11:</b> Why are you writing a JIT engine instead of a front-end to GCC?</p>
			<p>The JIT engine and runtime engine will be able to execute CIL executables generated on Windows.</p>

		</div> <!-- End Body Content -->
		<!-- **************************************** -->
		<!--  BEGIN RIGHT NAV HERE -->
		<!--#include virtual="/inc/rightnav_green.inc"-->
		<!--  END SEARCH BOX HERE -->
		<!-- **************************************** -->
		<div class="clear"></div>
	</div> <!-- End Body -->

	<!-- **************************************** -->
	<!--  BEGIN FOOTER HERE -->
	<!--#include virtual="/inc/footer.inc"-->
	<!--  END FOOTER HERE -->
	<!-- **************************************** -->
</div> <!-- End The Page -->

</body>
</html>
