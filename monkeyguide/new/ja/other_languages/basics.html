<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<title>Monoの組み込み - 基本</title>
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<h1>Monoの組み込み: 基本</h1>
<br/>

<h2>ランタイムの組み込み</h2>

<p>
  この章では、アプリケーションへのMonoランタイムの組み込み方をカバーします。このドキュメント中にソースコードの断片も提示します。完全なサンプルコードを見る場合には、Monoディストリビューションの'sample/embed'ディレクトリを参考にしてください。
</p>

<p>
  MonoのためのC APIはC言語を使ったオブジェクト指向なAPIで、ユーザー向けに公開されたAPIに一貫性を持たせるために導入された設計上の便宜が図られています。
</p>

<h3>コンパイルとリンク</h3>

<p>
  <a href="philosophy.html">「導入のセクション」</a>でも述べたように、アプリケーションにMonoランタイムを組み込むということは、Monoランタイムをソフトウェアにリンクさせるということです。
</p>

<p>
  ランタイムを組み込むためには、ソースコードをMonoランタイム
  ライブラリに組み込む必要があります。そうするためには、コンパイラーにpkg-configから返されたフラッグを渡してください。
</p>

        <pre class="console">

      pkg-config --cflags --libs mono
        </pre>

<p>
  <tt>pkg-config</tt>はサード・パーティーライブラリを、ポータブルな方法で活用するときに便利なツールです。
</p>

<p>こうコンパイルすれば、Monoライブラリをリンクできます：</p>

        <pre class = "console">

      $ gcc sample.c `pkg-config --cflags --libs mono`
        </pre>

<p>
  コンパイル・フラッグとリンク・フラッグを分けることもできます。
  例えば、makefileに以下のマクロを含めることができます：
</p>
    
        <pre class="console">

     CFLAGS=`pkg-config --cflags mono`
     LDFLAGS=`pkg-config --libs mono`
        </pre>

<h3>Monoランタイムの初期化</h3>

<p>ランタイムを初期化するためには、このようにmojo_jit_initを呼び出します：</p>

<pre class="code">
      MonoDomain *domain;
     
      domain = mono_jit_init ("domain-name");
</pre>

<p>
        そのコードが実行されるロケーションであるMonoDomainが返されます。複数のドメインを作ることができます。それぞれのドメインはそれぞれ他のドメインとコードから隔離されれおり、他のドメインには何の影響も与えません。これは一つのプログラムに複数のアプリケーションを組み入れる時に便利です。
</p>

<p>
        これで、Monoにコントロールを渡し、スレッドを作成する必要があります。
        それはこのように：
</p>
   
<pre class="code">
      void *user_data = NULL;

      mono_runtime_exec_managed_code (domain, main_thread_handler, user_data);
</pre>

<p>main_thread_handlerがアセンブリを呼び出し、実行する場所で行います：</p>

<pre class="code">

      static void main_thread_handler (gpointer user_data)
      {
              MonoAssembly *assembly;
      
              assembly = mono_domain_assembly_open (domain, "file.dll");
              if (!assembly)
                      error ();
      }
</pre>

<p>
  上記の例では、'file.dll'の内容はドメインに組み入れられます。これはコードのみをロードし、まだ実行はしません。'file.dll'の代わりに、'file.ext'などの他の任意のファイルにすることもできます。
</p>
<p>
  実行を開始するには、アセンブリの中のメソッドを呼び出すか、またはスタティックなMainメソッド（エントリー・ポイント）があるならば、便利な関数を使うこともできます：
</p>
   
<pre class="code">
      retval = mono_jit_exec (domain, assembly, argc - 1, argv + 1);
</pre>

<p>
  別のメソッドを呼び出すときには、後述の`Invoking Methods in the CIL universe'を後で参照してください。
</p>

<h3>ランタイムの終了</h3>
<p>
        Monoランタイムを終了するときには、作ったすべてのドメインを消去しなければなりません。それにはこの関数を使います：
</p>

<pre class="code">
     mono_jit_cleanup (domain);
</pre>

<p>
  アセンブリ起動中にコードから抜け出すことは、
  <tt>mono_environment_exitcode_get()</tt>関数を使ってできます。
</p>

<h3>アセンブリとイメージ</h3>

<p>
   前のセクションでは、メモリに格納されたアセンブリを指す
   'MonoAssembly *'型について紹介しました。アセンブリとは、
   ECMA CLIにおけるデプロイメントの単位で、
   一つのパッケージにコードとリソースを含みます。
</p>

<p>
   これがMonoでアセンブリを扱うためのパブリックAPIです：
</p>

<dl class="box">
  <dt><tt>MonoAssembly *mono_assembly_open (const char *filename, MonoImageOpenStatus *status);</tt></dt>
   
  <dd>
   <br/>
   これはファイル名の示すアセンブリをロードし、エラーがあればNULLを
   （そしてステータス・ポインタはエラーの詳細にセットされています）、
   成功すればMonoAssemblyポインタを返します。</dd><br/>
   
  <dt><tt>MonoImage *mono_assembly_get_image  (MonoAssembly *assembly);</tt></dt>
  <dd>
    <br/>
    これは与えられたアセンブリのコードとメタデータを含むイメージを返します。
  </dd><br/>

  <dt><tt>MonoImage *mono_assembly_load_module (MonoAssembly
   *assembly, guint32 idx);</tt></dt>
   <dd>
    <br/>
    アセンブリから、デフォルトではない指定されたモジュールをロードします。
   </dd><br/>
</dl>

<h3>型 （訳注：原文では"type"）</h3>

<p>
  <ins>Cでは、</ins>CIL型は'MonoClass *'として表され、オブジェクトは'MonoObject *'として表されます。
  これらのAPIはオブジェクト指向的なCの書き方で、MonoClassとMonoObjectの
  アクセッサー・メソッドには以下のものがあります：
</p>

<dl class="box">
  <dt><tt>MonoClass *mono_class_from_name (MonoImage *image, const char* namespace, const char *name);</tt></dt>
  <dd>
    <br/>
    指定されたMonoImageから、指定されたネームスペースと名前をもつMonoClassを取得します。
    <br/>
    'NULL'をイメージに渡すこともでき、そうすると指定されたネームスペースと名前を、ロードされている全てのアセンブリから探し出します。
    注意点として、この場合には名前の重複が起こりえるため、厳密に正確な型が必要である場合は、NULLを渡すのは、あまり薦められません。
    <br/>
  </dd><br/>
   
  <dt><tt>MonoClass *
mono_class_from_name_case  (MonoImage *image, const char* name_space, const char *name);</tt></dt>

  <dd>
    <br/>
    指定されたMonoImageから、指定されたネームスペースと名前をもつMonoClassを取得します
    ネームスペースと名前の検索は、大文字・小文字を区別しません。
    <br/>
    'NULL'をイメージに渡すこともでき、そうすると指定されたネームスペースと名前を、ロードされている全てのアセンブリから探し出します。
    注意点として、この場合には名前の重複が起こりえるため、厳密に正確な型が必要である場合は、NULLを渡すのはあまり薦められません。
  </dd><br/>

  <dt><tt>MonoImage *mono_class_get_image (MonoClass *klass);</tt></dt>
   <dd>
     MonoImageを与えられたMonoClassから返す。
   </dd>
</dl>

<h3>メソッドの検索</h3>

<p>
  CからCILの世界のメソッドを呼び出すには、いくつかの手順が必要です：
  <ul>
    <li>そのメソッドのMonoMethodハンドルを取得する。</li>
    <li>メソッドの呼び出し。</li>
  </ul>
</p>

<p>
  メソッドの取得にはいくつもの方法がありますが、そのクラスの中の適切なメソッドを見つけるために、反復子APIを使うことができます。
</p>

<dl class="box">
  <dt><tt>MonoMethod *mono_class_get_methods (MonoClass *klass, gpointer *iter)</tt></dt>
  <dd>
    <br/>
    このルーチンはクラスのフィールドを取得するための反復APIルーチンです。
    <br/>
    ゼロを指し示すgpointerを渡すと、それはすべてのエレメントを反復する不透過ハンドル（ランダムポインタ）として扱われます。
    もしも値がない場合には、NULLが返されます。
    <br/>
    それぞれの反復ではMonoMethodが返され、これ以上メソッドが存在しない時にはNULLが返されます。
  </dd>
</dl>

<p>
  以下の例が'Main'メソッドを見つけ出す簡単なメカニズムです：
</p>

<pre class="code">
        gpointer iter = NULL;
	MonoMethod *method;

        while ((m = mono_class_get_methods (klass, &amp;iter))) {
                if (strcmp (mono_method_get_name (m), "Main") == 0) {
                        method = m;
			break;
                } 
        }
</pre>

<p>
  ループの最後には、変数'method'にはMainメソッドの詳細が格納されており、
  実行可能な状態になっています。
</p>
  
<p>
  反復子モデルは、1回の処理でいろいろなメソッドを引き出すときに便利です。もし必要でないなら、より高次元なルーチンも使えます：
</p>


<dl class="box">
  <dt><tt>MonoMethod *mono_method_get (MonoImage *image, const char *name)</tt></dt>
  <dd>
    <br/>
    次の指定内容に該当し、'name'に合致するメソッドを返します：
    <br/>
    [namespace.]classname:methodname[(args...)]
    <br/>
    'image'の中か、もしNULLが指定されれば、ロードされている全てのアセンブリから、これを検索します。
  </dd>
</dl>

<h3>メソッドの呼び出し</h3>

<p>マネージドメソッドを呼び出すには二つの方法があります：</p>

<dl class="box">
  <dt><tt>MonoObject* mono_runtime_invoke (MonoMethod *method, void *obj, void **params, MonoObject **exc);</tt></dt>
  <dt><tt>MonoObject* mono_runtime_invoke_array (MonoMethod *method, void *obj, MonoArray *params, MonoObject **exc);</tt></dt>
  <dd>
    <br/>
    'obj'オブジェクト中のメソッド'method'を呼び出します：
    <p>
    objは'this'ポインタで、スタティック・メソッドにはNULL、
    オブジェクトのインスタンスにはMonoObject*、値型であればその型のポインタでなければなりません。
    </p>
    <p>
    params配列は、そのメソッドの引数を、そのままの形式で含みます: オブジェクトのインスタンスへのMonoObjectポインタか、値型へのポインタです。_invoke_arrayの方は、C#のobject[]をparams引数(MonoArray* params)として受け取ります。この場合、値型はそれぞれ参照型にボックス化されます。
    </p>
    <p>
    アンマネージドコードからは、通常mono_runtime_invoke()の方を使います。
    </p>
    <p>
    この関数はvirtualメソッドは扱えません。これは与えられたメソッドをそのまま実行するだけで、派生クラスにおけるこのvirtualメソッドの実装を探索する必要があります。
    </p>
    <p>
    例外を捕捉したくない場合は、NULLを実行時の引数として渡すこともできます。
    そうしない場合には、投げられた例外がexc*にセットされます。例外が発生すれば、関数の戻り値であるMonoObject*は使えません。
    </p>
    <p>もし値の型が返されれば、オブジェクトの参照にボックス化されます。
    </p>
  </dd>
</dl>

<h3>オブジェクトのインスタンス化</h3>

<p>
   MonoオブジェクトはMonoObject C 型のインスタンスへのポインタとして表されます。
   MonoObjectにはさまざまな処理が可能ですが、まずは一番よく使われる処理、Cからのインスタンス化に焦点を当てます。
</p>

<dl class="box">
  <dt><tt>MonoObject *mono_object_new (MonoDomain *domain, MonoClass *klass);</tt></dt>
  <dd>
    定義がklassによって参照された、新しく作られたオブジェクトを返します。
    これはどのコンストラクタも実行しないので、このルーチンは初期化時に明示的にコンストラクタを実行する必要があります。
  </dd>
</dl>
  
<p>
  上記のAPIを呼び出すと、は任意の'domain'の'klass'で参照されたクラスのインスタンスを作ります。ドメインは、そのオブジェクトがどのアプリケーションドメインに作られるかを指定します。ドメインはまず最初に説明すべきものなのですが、後のセクションでもう少し詳しく解説します。
</p>

<p>
  作られたオブジェクトはどのコンストラクタも実行しません。これはオブジェクトをインスタンス化させる側の裁量に任されます。
</p>

<pre class="code">
	MonoMethod *ctor = mono_method_get (image, "MyNS.MyType:.ctor");
	MonoObject *obj = mono_object_new (domain, klass);

	/* Ignore exceptions, pass no parameters */
	mono_runtime_invoke (method, obj, NULL, NULL);
</pre>

<h3>Mappings</h3>

</body>
</html>
