<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<!--
    <title>Glade# for Rapid Development: Simple Web Browser</title>
    -->
	<title>短時間で開発することを目的とした Glade# : シンプルなウェブ・ブラウザ</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Erik Dasque" />
	<meta name = "DC.Contributor" content = "Aaron Weber" />
	<meta name = "DC.Contributor" content = "Johannes Roith" />

<!--
	<link rel="stylesheet" type="text/css" href="../../../style.css" />
-->
	<link rel="stylesheet" type="text/css" href="style.css" />

    <meta name="translator" content="Takeshi AIHANA &lt;aihana@gnome.gr.jp&gt;" />
    <meta name="description" content="第1版 2005年02月10日" />
    <meta name="description" content="原文:
	  http://svn.myrealbox.com/source/trunk/monkeyguide/new/en/gnome/bindings/glade/glade2.html" />

</head>
<body> 

<!--
<h1>Glade# for Rapid Development: Simple Web Browser</h1>
-->
<h1>短時間で開発することを目的とした Glade# : シンプルなウェブ・ブラウザ</h1>

<!--
<h2>Contents</h2>
-->
<h2>目次</h2>
<!--
<ul>

	<li>1. <a href="#intro">Introduction</a></li>
	<li>3. <a href="#project">Project Setup</a></li>
	<li>4. <a href="#glade">Building the Interface</a></li>
	<li>5. <a href="#coding">Start Coding</a></li>
	<li>6. <a href="#i18n">Internationalization</a></li>
	<li>7. <a href="#todo">Further Exercises</a></li>
</ul>
-->
<ol>
	<li><a href="#intro">はじめに</a></li>
	<li><a href="#project">プロジェクトの設定</a></li>
	<li><a href="#glade">インタフェースの構築</a></li>
	<li><a href="#coding">コーディングの開始</a></li>
	<li><a href="#i18n">国際化</a></li>
	<li><a href="#todo">さらなる学習</a></li>
</ol>
<h2><a id="intro">はじめに</a></h2>

<p>
<!--
  In the <a href="glade.html">previous example</a> we built a very
  simple glade application using a simple editor and the Glade Interface
  Builder. In this example, we'll build a slightly more complex
  application, taking advantage of more tools: a web browser.
-->
<a href="glade.html">前の例</a> では簡易エディタと Glade インタフェース・ビルダを用いて、とてもシンプルなインタフェース・アプリケーションを構築しました。ここで紹介する例として、もっとたくさんのツールを利用し、ちょっとだけ複雑なアプリケーション "<em>ウェブ・ブラウザ</em>" を構築してみることにします。
</p>

<p>
<!--
  Many applications display rich content with an HTML rendering
  engine. Evolution and Monodoc, for example, use
  gtkhtml to render and edit messages, Monodevelop uses the Mozilla
  project's Gecko, and Konqueror and KMail use the khtml widget.
-->
多くのアプリケーションが表示するものは、HTML レンダリング・エンジンを使って内容が充実したものになっています。たとえば、Evolution や Monodoc はメッセージの描画や編集に Gtkhtml のレンダリング・エンジンを、Monodevelop では Mozilla プロジェクトの Gecko エンジンを、そして Konqueror と KMail では khtml ウィジットを利用しています。
</p>

<p>
<!--
  Mono includes bindings for both gtkhtml and Gecko, but in this
  example we'll use Gecko.  Gtkhtml is more suited to simple displays,
  such as email messages or static documentation pages, but Gecko is
  more full-featured and therefore better suited to use in a
  full-fledged web browser.  
-->
Mono には Gtkhtml と Gecko のバインディングが含まれていますが、ここで紹介する例では Gecko のバインディングを使用することにします。Gtkhtml は電子メールやドキュメントのページといったシンプルな表示に向いていますが、Gecko はさらに機能が充実したレンダリング・エンジンであり、本格的なウェブ・ブラウザでの利用に向いています。
</p>

<!--
<p>We'll use the following tools in this example:</p>
-->
<p>ここで紹介する例では、次のようないろいろなツール使用することになります:</p>

<ul>
<li>Mono</li>
<li>GTK# (gtk-sharp)</li>
<li>Gecko# (gecko-sharp、gtkmozembed#)</li>
<!--
<li>Monodevelop, an IDE for Mono</li>
-->
<li>Mono 向けの IDE である、Monodevelop</li>
</ul>

<p>
<!--
  Monodevelop isn't absolutely necessary here, but we'll
  be using it in the examples and screenshots.
-->
ここで Monodevelop は必須ということではありませんが、例とそのスクリーンショットで利用することにします。
</p>

<!--
<h2><a id="project">Project Setup</a></h2>
-->
<h2><a id="project">プロジェクトの設定</a></h2>

<p>
<!--
  First, launch Monodevelop and then select <b>File -> New
  Solution</b>. A dialog appears, offering you several choices for
  template and project type. Select C# for your template and Glade#
  Project for the project type. This will automatically fill in some
  starter code for you: a window and a button, similar to the "Hello
  World" code we wrote earlier.  
-->
まず最初に、Monodevelop を起動して <strong>ファイル -> 新しいソリューション</strong> を選択して下さい。ダイアログが表示され、テンプレートとプロジェクトの種類をいくつか選択するよう促されます。テンプレートで "C#" を、プロジェクトの種類として "Glade# Project" を選択して下さい。すると、自動的に初期コードをいくつか生成してくれます: 先に紹介した "Hello World" のコードによく似た、ウィンドウとボタンをそれぞれ一個です。
</p>

<div align="center"><img src="glade2_img/MonoD_1.png" /></div>

<blockquote>
<!--
  <b>Note:</b> Monodevelop uses the same project terminology as Visual
  Studio.NET: a "Solution" contains multiple "Projects," each of which
  contains one or more source files. Other platforms describe this
  arrangement as one of "Projects" and "Sub-Projects."
-->
<b>注記:</b> Monodevelop では Visual Studio.NET と同じ意味合いで "プロジェクト"	という用語を扱っています: "ソリューション" には複数の "プロジェクト" が含まれており、そのプロジェクトには一個以上のソース・ファイルが含まれます。他のプラットフォームでは、この用語をそれぞれ "プロジェクト" と "サブプロジェクト" の一つとして表記しています。
</blockquote>


<p>
<!--
  There's one more step as we get set up: adding the gecko-sharp
  assembly to the list of references we'll be using in
  Monodevelop.  To do that, right click on <b>References</b> in the
  <b>Solutions</b> tab on the left hand side, click <b>Edit Reference</b>
  and check the
  box marked <b>gecko-sharp</b>.  Adding the assembly means that
  Monodevelop will offer autocompletion and syntax validation on Gecko
  objects as well as those in its default set of assemblies. 
-->
もう一つ設定すべきステップがあります: gecko-sharp のアセンブリを、Monodevelop で使用することになる参照リストに追加します。これを行うには、左側のペインにあるタブ <strong>ソリューション</strong> の <strong>参照</strong> の上で右クリックし、<strong>参照の編集</strong> をクリックして表示されるダイアログの中にある <strong>gecko-sharp</strong> のチェック・ボタンを ON にします。アセンブリを追加するということは、デフォルトのアセンブリで行えるのと同様に、Gecko オブジェクトの自動補完や文法の検証を Monodevelop に依頼するということです。
</p>

<p> 
<!--
  Name your project MyBrowser and save it in a new directory. Now
  we're ready to start. 
-->
このプロジェクトの名前を MyBrowser として新しいディレクトリに保存して下さい。これでアプリケーションを作成する準備が整いました。
</p>

<div align="center"><img src="glade2_img/Reference.png" /></div>

<!--
<h2><a id="glade">Building the Interface</a></h2>
-->
<h2><a id="glade">インタフェースの構築</a></h2>

<p> 
<!--
  The first step is building the user interface. If you're using
Monodevelop, you already have a glade XML file started for you, in the
<tt>MyBrowser/Resource/</tt> directory. Double-click on that file in
the list of project files Monodevelop provides, or open it using
Glade. If you are not using Monodevelop, start Glade and create a new
GNOME project, then create a new window for it. 
-->
ここでの最初のステップはユーザ・インタフェースを構築することです。Monodevelop をご利用なら、既に <tt>MyBrowser/リソースファイル</tt> というディレクトリの中に、Glade XML ファイルが用意されています。Monodevelop が提供しているプロジェクト・ファイルの一覧からそのファイルをダブルクリックするか、あるいは Glade インタフェース・ビルダを使って開いて下さい。Monodevelop をご利用でない場合は、Glade インタフェース・ビルダを起動して新しいNOME プロジェクトを生成して、新しいウィンドウを追加して下さい。
</p>

<p>
<!--
Double click on the <i>window1</i> Glade object, so that its
properties are displayed in the Properties dialog. Then, change its
title to say "My Browser" instead of "Glade Window.
-->
Glade オブジェクトの <em>window1</em> をダブルクリックすると、そのプロパティがプロパティ・ダイアログの中に表示されます。それから、プロパティにあるタイトルを "Glade Window" から "My Browser" に変更して下さい。
</p>

<div align='center'><img src="glade2_img/Glade1.png" /></div>

<p>
<!--
Next, click the vertical box button (<img
src="glade2_img/vbox.png" align="baseline"/>) and click in the window.
When prompted, select 2 rows. You now have a top and bottom half of
your window. The top half will consist of buttons and toolbars, and
the bottom half will be the HTML display area. 
-->
次に、<img src="glade2_img/vbox.png" align="baseline"/> (垂直ボックス) のボタンをクリックして、<em>window1</em> に貼り付けます。このときに列の数を聞かれるので、列の数を 2個にして下さい。これでウィンドウを上下に分割することができました。上半分にはボタンとツールバーを配置し、そして下半分は HTML を表示する領域にします。
</p>

<p> 
<!--
To add spaces for your buttons, create a horizontal box (<img
src="glade2_img/hbox.png" align="baseline" />) with 3 colums in the
top row of the vertical box you created earlier.
-->
ボタンの間にスペースを追加するために、3列の <img src="glade2_img/hbox.png" align="baseline" /> (水平ボックス) を先に生成した垂直ボックスの上側に配置します。

</p>

<div align='center'><img src="glade2_img/Glade2.png" /><img src="glade2_img/Glade3.png"/></div>

<p> 
<!--
  In the three colums of the top half of the window, we'll add two
  buttons and a text entry.  In the Properties dialogs for the buttons
  you added, go to the Widget tab and select the stock Backward and
  Forward icons. Using stock icons provides application consistency
  across the desktop. In addition, stock labels are already
  translated, so you get free localization.
-->
ウィンドウの上半分にある三列のカラムに、二つのボタンとテキスト・エントリを追加して下さい。二つのボタンを追加したら、プロパティ・ダイアログの中にある "ウィジット" タブのプロパティ "ストック・アイコン" から "戻る (<u>B</u>)" と "進む (<u>F</u>)" をそれぞれ選択して下さい。ストック・アイコンを使うと、利用しているデスクトップと一貫性を保つことができるようになります。さらに、ストック・ラベルはお使いの言語に翻訳されており、ローカライゼーションに対応したものになっています。
</p>

<p>
<!--
  Right-click the top area and choose <b>hbox->Select</b> to select
  the hbox.  Change its Packing property so that <i>Expand</i> and
  <i>Fill</i> are "No." Now the box will take up only as much space as
  it needs, rather than filling all available space.
-->
上半分で右クリックして、コンテキスト・メニューから <strong>hbox1-&gt;選択</strong> を選択して水平ボックスを選択状態にして下さい。プロパティ・ダイアログのタブ "パッキング" を選択し、水平ボックスでウィジットをパッキングするプロパティである <em>広げる</em> と <em>埋める</em> を共に "いいえ" に変更して下さい。これにより、ウィンドウで利用可能なスペースを全部使うのではなく、水平ボックスで必要となる分だけウィンドウの領域を占めることになります。		
</p>

<p>
<!--
  In the bottom half of the UI, add a frame (img
  src="glade2_img/frame.png" align="baseline" />). Then, right-click
  on its label and select <b>Delete</b> so that it is blank and
  unlabeled. Later, we'll fill the frame with the Gecko rendering
  widget, which is not available in Glade.
-->
ウィンドウの下半分に、<img src="glade2_img/frame.png" align="baseline" /> (フレーム) を追加して下さい。それから、そのフレームのラベルの上で右クリックして <strong>削除</strong> を選択し、ラベルを付与しないようにして下さい。あとで、このフレームの中に Glade では設定できない Gecko レンダリング・ウィジットを埋め込むことになります。
</p>

<p>
<!--
Your UI should now look like this:
-->
ここまでのユーザ・インタフェースは次のようになるはずです:
</p>

<div> <img src="glade2_img/Glade5.png"/></div>

<p>
<!--
Now that looks more like a web browser! With the UI more or less
complete, save your work and quit Glade.
-->
ここまでで、なんとなく見た感じがウェブ・ブラウザらしくなってきました！ おおよそのインタフェースが完成したら保存して、Glade を終了して下さい。
</p>


<!--
<h2><a id="coding">Start Coding</a></h2>
-->
<h2><a id="coding">コーディングの開始</a></h2>

<p>
<!--
  The code that the project wizard generated for us should look
  pretty familiar by now:
-->
ここまでくると、プロジェクト・ウィザードが自動的に生成してくれたコードはホントに見慣れたものです:
</p>

<pre class="code">// project created on 4/16/04 at 2:17 P
using System;
using Gtk;
using Glade;

public class GladeApp
{
        public static void Main (string[] args)
        {
                new GladeApp (args);
        }

        public GladeApp (string[] args) 
        {
                Application.Init();

                Glade.XML gxml = new Glade.XML (null, "gui.glade", "window1", null);
                gxml.Autoconnect (this);
                Application.Run();
        }

        /* Connect the Signals defined in Glade */
        public void OnWindowDeleteEvent (object o, DeleteEventArgs args) 
        {
                Application.Quit ();
                args.RetVal = true;
        }
}
</pre>

<p>
<!--
  Now, we'll add to the code. Our changes here are marked in red:
-->
ここで、このコードを変更していくことにします。変更箇所は赤色で記しを付けてあります: 
</p>

<pre class="code">
...
using Glade;<font color="Green">
<!--
  // Earlier, we added a reference to the Gecko.dll assembly. Noting
  // here that we are using it lets the compiler know we're using classes
  // from that namespace, so we can type <b>WebControl</b> directly and not 
  // have to specify <b>Gecko.WebControl</b> everywhere.</font>
-->
  // 最初の方で、参照をアセンブリ Gecko.dll に追加しました。
  // ここで注意してもらいたい点は、
  // このアセンブリの名前空間から関連するクラスを使いたい旨を
  // コンパイラに知らせるためにその参照を使っているということです。
  // この参照を使えば、<strong>WebControl</strong> に直接アクセスすることができ、
  // このコードの中で <b>Gecko.WebControl</b> と指定する必要がなくなるわけです。</font>
<font color="Red"><b>using Gecko;</b></font>

public class GladeApp
{
...</pre>


<p> 
<!--
  As we saw earlier, Glade can automatically bind UI controls to
  references, provided that indicate that the object is a
  <b>Glade.Widget</b>, like so:
-->
前の章で紹介したように、Glade はいろいろな UI コントロールを自動的に参照へ接続することが可能で、次のように、オブジェクトが <strong>Glade.Widget</strong> を指すよう手配してくれます: 
</p>

<pre class="code">
...
public class GladeApp
{<font color="Green"><!-- // Because frame1 and entry1 are tagged as Widgets
 // the Glade runtime will bind them to UI controls with the same name -->
 // frame1 と entry1 を [Widgets] とタグしてあるので
 // これらのウィジットを実行時に Glade が同じ名前で UI コントローラに接続してくれます</font>
<font color="Red"><b>[Widget] Frame frame1;
[Widget] Entry entry1;</b></font>
...</pre>

<p>
<!--
  Because Glade only includes standard widgets, we couldn't put the
  browser control into our UI when we created it earlier. Instead,
  we'll write it in code, starting with a variable to refer to
  it. Let's call it "web."
-->
Glade は標準的なウィジットだけ提供しているので、先に生成しておいたユーザ・インタフェースの中にブラウザ用コントロールを配置することはできません。そのかわり、そのコントロールを参照する変数を使ってコードの中に直接記述することにします。その変数に "web" という名前を付けることにします。
</p>

<pre class="code">
...
public class GladeApp
{
[Widget] Frame frame1;
[Widget] Entry entry1;
<!-- <font color="Green"> // Define a variable for our web control </font> -->
<font color="Green"> // ブラウザ用コントロールの変数を定義します</font>
<font color="Red"><b>WebControl web;</b></font>
...</pre>


<p> 
<!--
  Now that we've defined a variable to refer to it, we can actually
  create the control:
-->
ウェブ・インタフェースを参照する変数を定義したので、ここで実際にコントロールのインスタンスを生成できます: 
</p>

<pre class="code">
...
Glade.XML gxml = new Glade.XML (null, "gui.glade", "window1", null);
gxml.Autoconnect (this);
<!-- <font color="Green"> // First we create a WebControl, using its default constructor</font> --> 
<font color="Green"> // 最初に WebControl のデフォルトのコンストラクタを使って、インスタンスを生成します</font>
<font color="Red"><b>web = new WebControl();</b></font>
<!-- <font color="Green"> // Then we ask it to show itself.
 // This is required because of a Gecko bug, and doesn't actually show the control yet. </font> -->
<font color="Green"> // 次に、このインスタンスを表示するよう伝えます。
 // Gecko にバグがあるのでこの文が必要なのですが、実際のところコントロールはまだ表示されません</font>
<font color="Red"><b>web.Show();</b></font>
<!-- <font color="Green"> // Next, we'll add the web control to our existing frame:</font> -->
<font color="Green"> // 次に、このコントロールをフレーム・ウィジット上に追加します:</font>
<font color="Red"><b>frame1.Add(web);</b></font>
...</pre>

<p> 
<!--
  Now things begin to get really interesting.  Type "entry1." and
  you'll get a list of possible completions. Select "Activated," the
  event called when someone types into the text entry and presses
  Return. We want the entered text to be loaded as a URL, so we'll
  need to delegate a new method, load_url, to entry1.Activated.
-->
肝心な部分はこれからです。"entry1." とまで入力すると、次の語を補完する候補の一覧がプルダウン表示されます。その一覧から、誰かがテキスト・エントリで何か入力してリターン・キーを押下するときに呼び出されるイベントである "Activated" を選択して下さい。ここで入力された文字列を URL として読み込みたいので、新しいメソッド load_url() を entry1.Activated にデリゲートする必要があります。
</p>

<p>
<!--
  C# supports operator overloading like C++ does, so we can do that
  with a simple shortcut, literally adding the method load_url to the
  list of delegates that will be fired when
  <i>entry1.Activated</i> occurs. To do that, we'll just add the
  following line, right before "Application.Run()."
-->
C# では C++ 同様に演算子のオーバーロードをサポートしているので、簡単にデリゲートを追加することができ、イベント <em>entry1.Activated</em> が発行されたときに呼び出されるデリゲートのリストへ文字どおりメソッド load_url() を追加できます。ということで、次に示す行を "Application.Run()" の直前に追加します。
</p>

<pre class="code"><font color="Green"><!-- // We can define load_url later -->
                 // 後ろに load_url を定義できます</font><font color="Red">
                 <b>entry1.Activated += load_url;</b></font>
 </pre>

 <p>
<!--
  Of course, now we have to actually implement the load_url method we
  delegated to the entry1.Activated event. We'll get the URL from the
   text entry control. In other languages, such as Java, we'd do that
   by using a "getter" method, something like
   <tt>entry1.getText().</tt> In C#, we have a shortcut, again through
   operator overloads. "Getter" and "setter" methods still exist, but
   you can also just get or set data as a property of its parent
   object: entry1.Text, instead of creating a string, setting the
   string to the value of entry1.getText(), and then using the data.
   That seems trivial at first, but in more complicated situations it
   can clarify syntax to a great degree.
-->
当然、イベント entry1.Activated にデリゲートするメソッド load_url() を実装する必要があります。テキスト・エントリのコントロールから URL を受け取ることにします。Java といった他のプログラミング言語では、<tt>entry1.getText()</tt> 風に "getter" メソッドを使って実現します。一方、C# では演算子のオーバーロードに対してショートカットがあります。"Getter" や "Setter" といったメソッドも存在してはいますが、単に親オブジェクト entry1.Text のプロパティとしてデータを get したり set することも可能です: (新たに文字列を生成し、その文字列を entry1.getText() の値にセットしてから、そのデータを利用するという方法をとる必要はありません)。一見ささいなことのように思えますが、もっと複雑なケースでは文法を大変わかりやすいものにしてくれます。
 </p>

<pre class="code">
...<font color="Green"><!-- // Connect the Signals defined in Glade -->
// Glade で定義されているシグナルを接続します </font>
public void OnWindowDeleteEvent (object o, DeleteEventArgs args) 
{
        Application.Quit ();
        args.RetVal = true;
}
<font color="Green"><!-- // A delegate signature has two parameters. -->
// デリゲートのシグネチャは二つの引数を受け取ります
<!--
// The first one is the source object that the event was invoked on
// and the second is the list of arguments for that event.
-->
// 一番目の引数はイベントが呼び出されるオブジェクト (ソース・オブジェクト) で、
// 二番目の引数はそのイベントの引数リストです
<!--
// We have it easy here, because we already know where the event comes 
// from, and don't care much about the arguments either.
-->
// 既にどこからイベントが発行されるのか既に知っているので、
// ここでは簡単に記述しています (引数リストについては気にしないで下さい)</font>
<font color="Red">
void load_url( object source, EventArgs args) {
    <b>web.LoadUrl(entry1.Text);
}</b></font>
...</pre>



<p>
<!--
  Save your work and select <b>Run->Compile All</b>.  Since the
  gui.glade file is listed in the project's resource file list, it
will be bundled into the executable automatically.
-->
ここまでのコードを保存してから、<strong>Run-&gt;全てコンパイル(<u>A</u>)</strong> を選択して下さい。Glade XML インタフェースのファイル gui.glade がプロジェクトのリソース・ファイルの一覧にあるので、自動的に実行形式の中に埋め込まれます。
</p>

<p> 
<!--
After compilation, you should be able to run the application by
selecting <b>Run->Run</b>. Test it by entering a URL such as
http://go-mono.com, and pressing Enter to trigger the entry1.Activated
event. 
-->
コンパイルが済んだら、<strong>Run-&gt;実行(<u>R</u>)</strong> を選択するとアプリケーションを実行できます。http://go-mono.com といった URL を入力し、イベント entry1.Activated を発行させるためにリターン・キーを入力して動作を確認してみて下さい。
</p>

<p>
<!--
<i>N.B. If you'd like to run your application from the command line, you'll need to add MOZILLA_HOME to your LD_LIBRARY_PATH</i>
-->
<em>注意: コマンドラインからアプリケーションを起動させたい場合は、環境変数 MOZILLA_HOME をお使いの環境の LD_LIBRARY_PATH に追加する必要があります。</em>
</p>

<!--
<h2><a id="i18n">Internationalization</a></h2>
-->
<h2><a id="i18n">国際化</a></h2>

<p>
<!--
Because we've used some stock components in our UI, Gnome will
know how to automatically localize them for us. For example, in a
terminal, go to the MyBrowser/bin/Debug/ directory, where the browser
executable was built earlier, and enter the command:
-->
ユーザ・インタフェースの中でストック・コンポーネントをいくつか使っているので、GNOME はそれらのアイテムを自動的に翻訳して表示する方法を知っています。たとえば、端末から MyBrowser/bin/Debug ディレクトリへ移動してみて下さい。そこには今回のブラウザの実行形態が格納されています。そして次のコマンドを入力してみて下さい: 
</p>

<pre>
mono MyBrowser.exe
</pre>

<p>
環境変数 LANG が日本語ならば、次のような表示になるはずです。
</p>
<div align='center'><img src='glade2_img/japanese.png' /></div>

<p>
次のコマンドの場合: 
</p>

<pre>
LANG=fr_FR mono MyBrowser.exe
</pre>

<p>
<!--
  Setting the LANG environment variable to fr_FR (French as spoken
  in France, as opposed to, say, fr_CA, the Canadian (Quebecois)
  dialect.)
-->
環境変数 LANG を fr_FR (フランスで話されるフランス語、対してカナダ (ケベック市の方言) で話されるのは fr_CA) に設定して下さい。
</p>
<p>
<!--
You should see this:
-->
次のような表示になるはずです:
</p>

 <div align='center'><img src='glade2_img/french.png' /></div>

<!--
 <p>For a better example, try this one:</p>
-->
 <p>もっとわかりやすい例として、次のコマンドを実行してみて下さい:</p>

<pre>
LANG=he_IL mono MyBrowser.exe
</pre>
<p>
<!--
he_IL designates Hebrew (he) as used in Israel (IL). Notice how the
button and general UI order has been inverted to reflect the
right-to-left writing direction found in Hebrew.
-->
he_IL はイスラエル (IL) で使用されるヘブライ語 (he) を表します。ボタンを含め標準的なユーザ・インタフェースの並び方が、ヘブライ語で実際に記述する方向である右から左へと変更されている点に留意して下さい。
</p>

<div align='center'><img src='glade2_img/hebrew.png' /></div>


<!--
<h2><a id="todo">Further Exercises</a></h2>
-->
<h2><a id="todo">さらなる学習</a></h2>

<p>
<!--
  To build on what you've learned so far, try the following exercises:
-->
ここまで学習してきたことを基にさらに発展させるには、次に示す課題に挑戦してみて下さい:
</p>

<ul>
<!--
  <li>Attach actions to the Forward and Back buttons. You'll need to implement a history queue, and decide how far back it should go.</li>
  <li> Implement a Refresh button. </li>
  <li> Implement a Go button, so that entry1.Activated can be triggered without pressing Return.</li>
  <li> Implement a Home button.</li>
  <li> Add a status bar. </li>
  <li> Add exception handling for missing pages (404) and so forth.</li>
  <li> Add an application menu with an About box.</li>
-->
  <li> "進む" と "戻る" ボタンにアクションを割り当ててみて下さい。訪問先の履歴を表現するキューを実装して、その履歴をどの程度戻すか決める必要が出てくるでしょう。</li>
  <li> 表示を "更新" するボタンを実装してみて下さい。</li>
  <li> "ジャンプ" ボタンを実装することによって、リターン・キーを押下しなくてもイベント entry1.Activated を発行できるようにしてみて下さい。</li>
  <li> "ホーム" ボタンを実装してみて下さい。</li>
  <li> ステータス・バーを追加してみて下さい。</li>
  <li> "ページが見つからない (404)" などの例外ハンドラを追加してみて下さい。</li>
  <li> 情報ダイアログを使ってアプリケーション・メニューを追加してみて下さい。</li>
</ul>

</body>
</html>
