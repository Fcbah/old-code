<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>グローバル アセンブリ キャッシュ - 高度な議論</title>
	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>

<body>
<h1>グローバル アセンブリ キャッシュ - 高度な議論</h1>

  <p> 
    このセクションでは、<a 
    href="basics.html#gac">グローバル アセンブリ キャッシュ</a>に関する、いくつかの高度な議論を進めます。GACの導入については、<a 
    href="basics.html">基礎編</a>を読んでみて下さい。
  </p>
    
<a name="delay_signed_assembly" />
<h2>遅延署名したアセンブリを使う</h2>

  <p>
    <a href="basics.html#delay_signed_assembly">遅延署名したアセンブリ</a>は、よく、開発期間中は署名する秘密鍵を秘匿しておく、という目的で使用されます。これは、統合メカニズムとして厳密名を使用する場合には、不可欠のステップでもあります。
  </p>

  <p>
    Mono 1.0では、ランタイムが厳密名の署名検証をサポートしていません。
    これはつまり、統合メカニズムが存在していないということです。
    しかし、Monoで遅延署名したアセンブリを使用することは、それでも可能です。
    たとえば、開発者は別のランタイムでアセンブリを実行するために、厳密名の
    統合を必要とするかもしれませんし、同一の秘密鍵を他の目的で使用するかも
    しれないのです。
  </p>

  <p>
    遅延署名をするには、以下のものをインクルードしなければなりません:
  </p>

  <ul>
    <li>
      プロジェクトのどこかに、パラメータが <b>true</b> である <b>AssemblyDelaySign</b> アトリビュート。
    </li>
    <li>
      公開鍵を含むファイルへの参照を示した <b>AssemblyKeyFile</b> アトリビュート。
      秘密鍵も機能しますが、それでは使用する意味が無いでしょう。
    </li>
  </ul>

<pre class="code">
[assembly: AssemblyDelaySign (true)]
[assembly: AssemblyKeyFile ("mypublickeyfile.pub")]
</pre>

  <p>
    これとは対照的に、完全に署名されたアセンブリでは、<b>AssemblyDelaySign</b>
    アトリビュートに <b>false</b> パラメータを使い
    （あるいはこのアトリビュートを完全に消してしまって）、
    そして完全な鍵ペア（つまり秘密鍵と公開鍵の両方）を含むファイルを参照する
    <b>AssemblyKeyFile</b> アトリビュートを使うことになるでしょう。
  </p>

  <p>
    今のところ、遅延署名されたアセンブリは、ランタイムによって使用されることがなければ、大した用を成すわけではありません。一般に、（ランタイムが厳密署名を強要することがない）Mono 1.0では問題ではないのですが、検証処理は以下の範囲指定によって、さらにオフにすることができます:
  </p>

  <ul>
    <li>
      単一のアセンブリ（ファイル名と公開鍵トークンで指定します）を、特定のユーザー、ユーザーのリスト、あるいは全ユーザーを対象とする
    </li>
    <li>
      特定の公開鍵トークンを共有する全てのアセンブリを、ここでも特定のユーザー、ユーザーのリスト、あるいは全ユーザーを対象とする
    </li>
  </ul>

<a name="delay_signed_config" />
<h4>遅延署名のコンフィグレーション</h4>

  <p>
    署名検証が免除されるアセンブリのリストあるいは公開鍵トークンは、<b>machine.config</b> ファイルに記述されています。このファイルは通常 <b>[prefix]/etc/mono</b> にあります。
  </p>

  <p>
    このコンフィグレーションは、<b>configuration/strongNames/verificationSettings</b> のセクションの下にまとめられています。それぞれのエントリが、<b>skip</b> という名前になっており、3つの属性を持っています。
  </p>

  <ul>
    <li>
      <b>Token</b>: 無視すべき公開鍵トークン;
    </li>
    <li>
      <b>Assembly</b>: 無視すべきアセンブリ名。<b>*</b>で、指定されたトークンの全てのアセンブリが無視できます。
    </li>
    <li>
      <b>Users</b>: 署名検証でスキップ対象となるユーザー。複数のユーザー名をカンマ(,)で区切って指定できます。ここでも、<b>*</b>で、指定されたアセンブリ/公開鍵トークンのものについて、全てのユーザーが検証をスキップすることができます。
    </li>
  </ul>

  <p>
    たとえば、全てのECMAアセンブリの署名を、全てのユーザーについて無視するというエントリは、次のようになります:
  </p>

<pre class="code">
&lt;skip Token="b77a5c561934e089" Assembly="*" Users="*" /&gt;
</pre>

<a name="public_key_token_remapping" />
<h2>公開鍵トークンの再マッピング</h2>

   <p>
    再マッピングの一番の例は <a href="basics.html#ecma_key">ECMA</a> 鍵でしょう。
    全てのランタイムが、ECMA公開鍵トークンを、それ自身の公開鍵に再マッピングしなければなりません。
    こうして、それぞれのランタイムで<a href="basics.html#standard_assembly">標準ECMAアセンブリ</a>のデジタル署名を検証することができるのです。
  </p>

  <p>
    同様の議論が、他のアセンブリについても当てはまります。ごくわずかな人だけしか、フレームワーク アセンブリの大部分を署名するのに用いられている秘密鍵（msfinalとして知られています）にアクセスすることができません。しかし、我々が必要としている厳密名を維持するためには、同一の公開鍵を必要とします。Monoでの解決策は、ECMAの再マッピングのメカニズムを、あらゆる公開鍵トークンについて一般化するというものです。
  </p>

  <p>
    この普遍的な再マッピングのメカニズムは、Monoにしか存在しません。
    すなわち、この機能を使用するアセンブリは、この境界の外側つまり別のランタイム上では、動作しません（署名が直接検証できないためです）。もしそれらのアセンブリを（テストやデバッグ目的などで）使用する必要がある場合は、それらの特定のアセンブリ（あるいはその公開鍵トークン全体）の厳密署名の検証をオフにしなければなりません。この詳細は<a href="#delay_signed_assembly">遅延署名したアセンブリ</a>を参照して下さい。
  </p>

<a name="remapping_config" />
<h4>公開鍵の再マッピングのコンフィグレーション</h4>

  <p>
    再マッピングのコンフィグレーションは、<b>machine.config</b> ファイルに記述されています。このファイルは通常 <b>[prefix]/etc/mono</b> にあります。
  </p>

  <p>
    このコンフィグレーションは、<b>configuration/strongNames/pubTokenMapping</b> のセクションの下にまとめられています。それぞれのエントリが、<b>map</b> という名前になっており、2つの属性を持っています。
  </p>

  <ul>
    <li>
      <b>Token</b>: アセンブリの公開鍵トークン
    </li>
    <li>
      <b>PublicKey</b>: アセンブリの厳密署名を検証するのに用いられる公開鍵
    </li>
  </ul>

  <p>
    たとえば、ECMA鍵のエントリは次のようになっています:
  </p>

<pre class="code">
&lt;map Token="b77a5c561934e089" PublicKey="002400000480000000..." /&gt;
</pre>

</body>
</html>

