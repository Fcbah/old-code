<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8" />
	<title>XmlReaderを使ってXML文書を読む</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Atsushi Enomoto" />

	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>

<h1>XmlReaderを使ってXML文書を読む</h1>

<h2>もくじ</h2>

<ol>
	<li><a href="#intro">イントロダクション</a></li>
	<li><a href="#outline">readerクラスの概要</a>
	<ol>
		<li><a href="#xmltextreader">XmlTextReader</a></li>
		<li><a href="#xmlnodereader">XmlNodeReader</a></li>
		<li><a href="#xmlvalidatingreader">XmlValidatingReader</a></li>
		<li><a href="#abstract-xmlreader">XmlReader: 共通のXML読み込みAPIとして</a></li>
	</ol>
	</li>
	<li><a href="#howtouse">XmlReaderの使い方</a>
	<ol>
		<li><a href="#properties">ノード情報のプロパティ</a></li>
		<li><a href="#methods">Readerのメソッド</a></li>
		<li><a href="#attributes">属性の扱い方</a></li>
		<li><a href="#api-notes">重要な注意事項</a></li>
	</ol>
	</li>
	<li><a href="#tips">XML ReaderのTips</a>
	<ol>
		<li><a href="#namespaces-false">名前空間を考慮せずに文書を解析する</a></li>
		<li><a href="#ctor">コンストラクタ</a></li>
		<li><a href="#dtd">XmlReaderとDTD</a></li>
	</ol>
	</li>
</ol>

<h2><a name="intro">1. イントロダクション</a></h2>

<p>これから、私は「XMLリーダー」インターフェースからXMLのガイドを始めることにします。これはXMLを読み込み、そのXMLの情報集合(information set)を提供するのに使われます。それから? その先何が出来るかは、あなた次第です。</p>

<p>もしあなたが単に文書構造の中身を簡単に探したいのであれば、この「XMLリーダー」はあまり便利ではないでしょう。XmlDocumentやXPathNavigatorを使うことができますし、そちらの方がずっと簡単に使えます。XmlReaderは、XML入力として広汎に使われているので、このインスタンスをつくる必要が生じることになるでしょうが、あなたがXML処理まわりで優れたパフォーマンスを必要とするのでない限り、あなたがこれを「使う」必要はありません。XmlReaderは、読み込んだ情報をほとんど置き去りにしていきますから、巨大なXML文書を扱いたい場合には適しています。</p>

<p>ええと、なぜ私が簡単な用途向けにこれをお勧めしないのかを理解してもらうために、ちょっとした実用コードの例を見てみましょう。これはMonoのWebサイトから最新のRSSエントリを引っ張ってくるサンプルです。（このコードは最新のwebサイトと同期していない可能性には留意して下さい。）</p>

<pre class="code">
XmlTextReader reader = new XmlTextReader ("http://www.go-mono.com/index.rss");
reader.Read ();
Console.WriteLine (reader.NodeType); // It prints "XmlDeclaration"

reader.MoveToContent ();
Console.WriteLine (reader.NodeType); // It prints "Element"
Console.WriteLine (reader.Name); // "rss"
Console.WriteLine (reader.GetAttribute ("version")); // Maybe "0.92"

// proceed content until we reach "item" element
while (!reader.EOF &amp;&amp; reader.Name != "item")
	reader.Read ();

reader.Read (); // Move from "item" to "title"
while (reader.NodeType == XmlNodeType.Whitespace)
	reader.Read ();
Console.WriteLine ("Title : " + reader.ReadString ());

reader.Read (); // from "&lt;/title>" to whitespace
reader.Read (); // from whitespace to &lt;link>
Console.WriteLine ("Link  : " + reader.ReadString ());

reader.Read (); // from "&lt;/link>" to whitespace
reader.Read (); // from whitespace to &lt;pubDate>
Console.WriteLine ("Date  : " + reader.ReadString ());

reader.Read (); // from "&lt;/pubDate>" to whitespace
reader.Read (); // from whitespace to &lt;description>
Console.WriteLine ("Description : " + reader.ReadString ());
</pre>

<p>こんな長いの? こんな簡単なタスクにこんな長いコードを書かなければいけないのかって? いいえ、もしあなたが特にリソースの制約を抱えているわけでもなく、単にsummaryを取得したいのであれば、noです。XmlDocumentかXPathNavigatorを使いましょう。そして、はい - もしあなたがXmlReaderを使いたいのであれば、yesです。</p>

<p>(ええと、このコードは単なるサンプルで実際にはあんまり良いコードではありませんから、ここから真似しないで下さい。特に空白ノードの存在などには依存すべきではありません。)</p>



<h2><a name="outline">2. XML Reader クラスの概要</a></h2>

<h3><a name="xmltextreader">2.1. XmlTextReader</a></h3>

<p>XMLはタグ付けされたマークアップ言語です。あなたは、カスタムテキストパーサーを書いて、内容を読むことも出来ますが、XMLを解析するにはずっと簡単な手段があります。XMLテキストデータを解析するときには、XmlTextReaderが使えます。</p>

<p>もしあなたがここで私が列挙するキーワードのいくつかをご存じなら、たぶんXmlTextReaderがどんなものであるか理解できることでしょう: SAX, XMLPull, StAX。XmlTextReaderは「プル パーサー」のたぐいです。</p>

<p>これはファイル名あるはURI文字列、StreamまたはTextReaderから生成されます。もしまだエラーに遭遇していなければ、これは「現在のノード」を保持しています。Name, Prefix, NamespaceURI, Valueといったプロパティから、ノードの情報を取得できます。Read()メソッドを呼ぶと、現在のノードから次のノードに進みます。</p>


<h3><a name="xmlnodereader">2.2. XmlNodeReader</a></h3>

<p>XML文書をテキスト表現から「読む」必要はありません。もしいったんXML文書を文書オブジェクト(XmlDocument)に読み込んでいたら、同じXML infosetを再び解析する必要は無いのです。もしあなたがXmlDocumentに対して、XmlTextReaderに対する処理と同じような処理をしたいのであれば、XmlNodeReaderを使うことができます。これはXmlNodeをもとに生成され、XmlTextReaderと同様にName, Prefix, NamespaceURI, Valueを取得することができます（もちろん、これらは既にそれぞれのノードのプロパティとして利用可能になっているものですが）。</p>


<h3><a name="xmlvalidatingreader">2.3. XmlValidatingReader</a></h3>

<p>Mono と Microsoft.NET は、いくつかの「検証」機能をサポートしています。MonoはDTD, XML Schema, RELAX NGを検証言語としてサポートします。Microsoft.NETでは、DTD, XML SchemaとXDR (XML Data Reduced)をサポートします。DTDとXML Schemaについては（Microsoft.NETについてはXDRも）、この検証機能はXmlValidatingReaderで実装されています。RELAX NG文法に基づいて検証したい場合は、RelaxngValidatingReaderについて調べてみて下さい。</p>


<h3><a name="abstract-xmlreader">2.4. XmlReader: 共通のXML読み込みAPIとして</a></h3>

<p>これらのクラスは、infosetプロパティや読み込みを進めるメソッドではほとんど共通なので、これらはXmlReaderという共通の基底クラスをもっています。いったんXmlTextReaderの使い方をマスターしたら、あなたはXmlNodeReaderとXmlValidatingReaderも使えるようになっているでしょう。</p>



<h2><a name="howtouse">3. XmlReaderの使い方</a></h2>

<h3><a name="reader-properties">3.1. ノード情報プロパティ</a></h3>

<p>この章ではXmlReaderの使い方を説明します。まず、このセクションはノード情報プロパティから始めます（ちょっとばかり退屈なものですが、これはあらかじめ説明しておかないといけませんので）。</p>

<p>以下のプロパティが現在のノードを表すものとして利用可能です:</p>

<ul>
	<li>Name: マークアップ名 (例 "xsl:template")</li>
	<li>LocalName: 名前のローカル部分 (例 "template")</li>
	<li>Prefix: 名前空間プレフィックス ("xsl")</li>
	<li>NamespaceURI: 文書中で宣言あるいは規定された名前空間URI ("http://www.w3.org/1999/XSL/Transform")</li>
	<li>NodeType: 限定列挙されたノードの種類のうちのひとつ。以下ですぐに説明します。</li>
</ul>

<p>これらはW3CのDOM APIのものとは多少異なることに注意して下さい。たとえば、documentノードのValueに対して "#document" を返すことはありません。</p>

<p>CLIでは列挙型をサポートするので、ノードの種類は、W3C文書オブジェクトモデルとは異なり、整数ではなく列挙型として表現されています。この型の名前はXmlNodeTypeです。（もうひとつ、XPathNodeTypeという型もあるので注意して下さい。)</p>

<p>限定列挙されている値は以下のものです:</p>

<ul>
	<li>None</li>
	<li>Element</li>
	<li>Attribute</li>
	<li>Text</li>
	<li>CDATA</li>
	<li>EntityReference</li>
	<li>Entity (文書型定義の内容です)</li>
	<li>ProcessingInstruction</li>
	<li>Comment</li>
	<li>Document</li>
	<li>DocumentType</li>
	<li>DocumentFragment</li>
	<li>Notation</li>
	<li>Whitespace</li>
	<li>SignificantWhitespace</li>
	<li>EndElement</li>
	<li>XmlDeclaration</li>
</ul>

<p>(変に見えますか? ええ、これらはW3C DOMとは互換性がありません - DOMにはEndElementもXmlDeclarationもWhitespaceもSignificantWhitespaceもありません。また、これらは"Infoset"でもありません - XML Infosetでは、TextとCDATA sectionの違いは認識されません。)</p>


<h3><a name="reader-methods">3.2. Readerのメソッド</a></h3>

<p>Read() は、次のノードに移動します。「次のノード」というのは次のものを意味します:</p>
<ol>
<li>現在のノードがdocumentまたはelementで、もし1つ以上の子ノードがあれば、最初の子に移動します。</li>
<li>そうでなく、もし要素の終端に到達した場合は、そのノードのEndElement（終端）に移動します。</li>
<li>そうでなく、もし展開した実体の終端に到達した場合は、EndEntityに移動します。</li>
<li>そうでなく、次の兄弟ノードが存在する場合は、その兄弟に移動します。</li>
<li>そうでなく、要素の終端にいて、親ノードが存在する場合は、親に進んで、この一覧の2つ前に戻って続けます。</li>
<li>以上に該当しなければ、これは何も進めません。</li>
</ol>

<p>属性ノードはそれを有する要素ノードの子ではなく、従ってRead()によって属性に移動するということはないんだということに注意して下さい。もしリーダーが属性上にあれば、まずそれを有する要素まで移動し、それから前述の次のノードまで移動します。属性に移動する方法については後述します。</p>

<p>もしリーダーが要素あるいはテキスト内容の上にあれば、ReadString()は、その内容を読み込んで文字列値として返します（その他のノード上にあれば、これは何もしません）。これは次のノード（テキスト内容の場合）あるいは対応するEndElementを除いた次のノード（要素の場合）に進めます。</p>

<p>ReadInnerXml() は現在のノードの内容を表すマークアップ文字列を返します。
ReadOuterXml() は現在のノードとその内容を表すマークアップ文字列を返します。</p>

<p>MoveToContent() はElement, Text, CDATAあるいはEndElementに到達するまで読み進めるショートカット メソッドです。Skip()は、現在のノードの次のノード（もしあれば現在の要素に対応するEndElementを除く）まで読み飛ばします。</p>


<h3><a name="attributes">3.3. 属性の扱い方</a></h3>

<p>ここまでの章では、属性を置き去りにしてきました。このセクションでは、属性がどのように扱われるかについて説明しましょう。</p>

<p>各種メソッドの説明に入る前に、属性がどのように構成されているかをせつめいしなければなりません。要素ノードは、0個以上の属性ノードを含みます。属性ノードには、0個以上の属性値ノードが含まれます。</p>

<p>属性にアクセスするには、概して2通りの方法があります:</p>

<ol>
	<li>オーナー要素から属性値文字列を取得する。</li>
	<li>属性ノードに移動して、リーダーのプロパティを使用し、属性値トークンから属性値文字列を読み取る。</li>
</ol>

<p>最初のカテゴリについては、これらは単に属性を、1つの文字列を含むものとして扱います。
2番目のカテゴリでは、より細かく属性にアクセスします。</p>

<p>より具体的に言えば、属性にアクセスするには4通りの方法があります:</p>

<ul>
	<li>オーナー要素からGetAttribute() を使って、属性値文字列を取得する。</li>
	<li>XmlReaderのインデクサを使う。これはGetAttribute()と同じものを返します。</li>
	<li>MoveToFirstAttribute()あるいはMoveToNextAttribute()を使って、属性に順番に移動する。</li>
	<li>MoveToAttribute() を使って、指定した属性に直接移動する。</li>
</ul>

<p>
MoveToXXX()メソッドを使えば、XmlReader自身からさまざまなプロパティが取得できるようになります。また、ReadAttributeValue()メソッドを使えば、それぞれの属性値ノードを読むことも出来ます。実際には、ReadAttributeValue()は他のMoveToXXX()メソッドと同様、単に属性値ノードに移動するだけです。</p>

<p>属性値ノードとしては、TextとEntityReferenceのみが出現可能です。属性の中では、WhitespacesはTextとして扱われます。空の属性でも、空文字列Textノードとして扱われます。</p>

<p>GetAttribute()、インデクサおよびMoveToAttribute()は3種類の引数をとるようにオーバーロードされています。</p>

<ol>
	<li>順序づけられた属性項目を指定するintインデックス。（ええ、属性はXML Infoset勧告では「順序づけられていない」ものですが、XmlReaderでは属性間の「順序」が必須のものとして存在しています。）</li>
	<li>マークアップで同じ属性を指定するための文字列名。</li>
	<li>名前のローカル部分と名前空間URI部分を指定する2つの文字列の組合せ。</li>
</ol>

<p>もし指定名の属性がない場合、GetAttribute()とインデクサはnullを返し、MoveToXXX()はfalseを返します（これらはbooleanの値を返しますので）。intの引数については、これらは例外を投げます。</p>


<h3><a name="api-notes">3.4. 重要な注意事項</a></h3>

<p>リーダーを使った後は、Close()を呼ばなければなりません。特にXmlTextReader
やXmlValidatingReaderをファイル名から生成した場合は、これを忘れないで下さい。
</p>


<h2><a name="tips">4. XML ReaderのTips</a></h2>

<h3><a name="namespaces-false">4.1. 名前空間を無視して文書を解析する</a></h3>

<p>時には（主に遺産的な文書で）、あなたはXML文書を名前空間無しで解析したいと思うかもしれません。そのような場合には、XmlTextReaderでNamespaces = falseと指定することが出来ます。</p>


<h3><a name="ctor">4.2. コンストラクタ</a></h3>

<p>XmlTextReaderにはたくさんのコンストラクタがあります。XML文書全体については、文字列URI、StreamあるいはTextReaderから、オプションでXmlNameTableとBaseURI（主にStreamやTextReaderの場合に有用です）を指定して、生成することが出来ます。</p>

<p>代わりに、XML内容文字列から、NodeTypeとXmlParserContextを引数に生成することもできます。XmlTextReaderは、XMLフラグメントを解析するために使用することも出来ます。このコンストラクタは属性や要素の内容を解析する簡単な方法を提供します。
これは実際にDOMの値のsetterとしても内部的に使われています。</p>


<h3><a name="dtd">4.3. XmlReaderとDTD</a></h3>

<p>DTD (文書型定義) は、XML構造を制約するために用いられます。これは名前空間を無視するので、あまりお勧めではありませんが、（XMLの祖先のひとつであり、設計上DTDを必須としたSGMLの頃から）非常に一般的に用いられてきました。</p>

<p>ご存じないかもしれませんが、DTDは「検証正統性」（妥当性）にのみ影響するのではなく、"well formedness"にも影響します。そのため、well-formednessチェックをサポートするXmlTextReaderは、DTDも消化します。</p>

<p>もしパーサーのパフォーマンスにも影響するような、外部DTDを読み込みたくない場合には、XmlResolver = nullと設定することが出来ます。</p>

<p>もし検証エラーを報告してほしくない場合は、XmlValidatingReaderのValidationEventHandler、あるいはValidationType = ValidationType.Noneを設定することができます。もしハンドラーをせっとしたら、あなたがその委譲したメソッドの中でエラーを投げない限り、それ以上検証エラーを投げることはありません。well-formednessエラーから回復することはできないことに注意して下さい。</p>


<!--
<h3><a name="known-bugs">4.4. Known bugs</a></h3>

<p>This is known MS bugs.</p>

<p>Don't use MoveToXxxAttribute() on XmlDeclaration. It leads to inconsistent
results. For example, XmlNodeReader never moves to version, encoding nor
standalone values, while XmlTextReder and XmlValidatingReader does.</p>
-->


</body>
</html>
