<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Developer integration</title>
	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>

<body>
<h1>Developers and Versioning</h1>

  <p>
    So having multiple versions of the same assembly is useful to the
    user: he does not have to worry about conflicting assembly filenames
    and he can have multiple versions of the same assembly installed
    at once without breaking his existing software when he updates
    software. 
  </p>

  <p>
    But how do developers cope with having multiple assemblies, and how
    does the compiler choose the right version of a assembly to link
    with?
  </p>

  <p>
    The compiler will automatically load assemblies that are located in
    the same directory as the compiler (by default /usr/lib/mono/1.0)
    and these include all the assemblies that are part of the standard
    Mono.  But for third party assemblies, it is necessary to indicate
    a directory that holds the assembly to link against.
  </p>

  <p>
    In the GAC world, the assemblies are exposed in two places: in the
    GAC (which is what the runtime uses to load assemblies) and to the
    compiler in a different location, this is done with the <tt>-package</tt>
    flag to the <tt>gacutil</tt> command.
  </p>

  <p> What the <tt>-package</tt> option does is to expose the assembly
    in a different location for the compiler to pick up (by default
    the assembly is only exposed in a cryptic location, for example::
    /usr/lib/mono/gac/monodoc/1.0.0.0__0738eb9f132ed756/monodoc.dll)
    which is not very practical to type.   The <tt>-package NAME</tt>
    option will surface the assembly (using a symbolic link) in
    /usr/lib/mono/NAME directory, which is a convenient assembly to
    pass to the compiler. 
  </p>

  <p>
    To further integrate into the Unix build process, we go one step
    beyond, and we encourage developers to not only install their
    assembly into the GAC and surface it for developers with the
    <tt>-package</tt> option, but to also ship a <tt>pkg-config</tt>
    configuration file.  The pkg-config configuration file has all the
    information required to build against a assembly.
  </p>

  <p> This can be used in conjunction with the compiler flag
    <tt>-pkg:</tt> to directly reference a software package, for
    example to compile with Gtk# and Pango#, this is the command line
    used:
  </p>

<pre class="console">
$ mcs -pkg:gtk-sharp,pango-sharp sample.cs
Compilation succeeded
$ 
</pre>

  <p>
    The above is convenient for developers as they do not have to
    remember the paths, or probe for the paths, they can just use
    pkg-config to probe on their configuration scripts for the
    presence and a specific version if they need to.
  </p>

  <p>
    The gtk-sharp.pc file is a file that is installed into
    /usr/lib/pkgconfig directory (on most systems) or on any directory
    references by the PKG_CONFIG_PATH.  This allows a developer to
    have multiple development versions installed at once, and have the
    compiler pick the right version based on the .pc file
  </p>

  <p>
    Here is what the gtk-sharp.pc file looks like:
  </p>

<pre class="code">
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib


Name: Gtk#
Description: Gtk# - GNOME .NET Binding
Version: 0.91.99
Libs: -r:${libdir}/mono/gtk-sharp/glib-sharp.dll     \
	-r:${libdir}/mono/gtk-sharp/pango-sharp.dll  \
	-r:${libdir}/mono/gtk-sharp/atk-sharp.dll    \
	-r:${libdir}/mono/gtk-sharp/gdk-sharp.dll    \
	-r:${libdir}/mono/gtk-sharp/gtk-sharp.dll
</pre>
 
  <p>
    Notice that the assemblies are referenced directly instead of
    passing the -lib: command line and then the -r option separately:
    This helps specifying exactly what assembly must be linked with.
  </p>


</body>
</html>
