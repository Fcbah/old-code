<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
  <title>Glade# for Rapid Development: Hello World</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Erik Dasque" />
	<meta name = "DC.Contributor" content = "Aaron Weber" />
	<meta name = "DC.Contributor" content = "Johannes Roith" />

	<link rel="stylesheet" type="text/css" href="../../../style.css" />
</head>
<body> 

<h1>Glade# for Rapid Development: Hello World</h1>


<h2>Contents</h2>
<ul>
	<li>1. <a href="#intro">Introduction</a></li>
	<li>2. <a href="#create_ui">Creating the UI</a></li>
	<li>3. <a href="#coding">Creating the Code</a></li>
	<li>4. <a href="#self_contained">Bundling XML Into the Executable</a></li>
</ul>

<h2><a id="intro">Introduction</a></h2>

<p> 
  In the previous chapter, you learned how create a GUI the hard way,
  with code alone.  In this chapter, we'll look at using the Glade GUI
  builder. Glade lets you construct a user interface visually, and keep
  it neatly separated from the rest of the code. 
</p>

<p>
  Glade comes in two pieces:
  <ul>
    <li>The Glade application itself, which lets you build the UI and saves it as an XML file.</li>
    <li>The libglade library,  which loads the XML and generates the UI at runtime.</li>
  </ul>
</p>

  <p>
    If you install the packages glade, libglade, and gtk-sharp, you
    will have all you need: gtk-sharp includes the .NET wrappers for
    libglade. You can use Glade and libglade with a variety of
    languages, including Python, C, C++, and of course C#. Check the
    Glade documentation for details.
  </p>
  
  <p>
    If you build an application using libglade, libglade must be
    installed for the application to run, and you must include the XML
    application file with your application. If you are using Gtk#, you
    can bundle the XML file as part of the executable.
  </p>



<h2><a id="create_ui">Creating the UI</a></h2>
<table cellpadding="5" border="0">
<tr>
<td valign="top"><img src="glade-palette.png" border="0" /></td>
<td valign="top">

  <p>
    First, open the Glade Interface Designer (make sure you're
    using version 2.0 or newer, usually run with the command
    glade-2). Glade opens with three windows: the main window, a
    properties window, and a palette window.  In the main window,
    click the <b>New</b> button, and when prompted select <b>GNOME
    Project.</b>
  </p>

  <blockquote>
    <b>Note:</b> Glade 2.5 and later make use of Gtk+ 2.4, which
    offers a wider range of widgets than Gtk+ 2.2. Prior to Mono 1.0,
    GNOME.NET (including gtk-sharp) will support only Gtk+ 2.2
    widgets.  Although you can use any version of Glade after 2.0 to
    design your interface, versions between 2.0 and 2.5 are suggested,
    to avoid accidental selection of unsupported widgets.
  </blockquote>


  <p>
  Now, select your first widget from the palette: a window. All other
  widgets go inside a window. As you might expect for the first item
  in every project, the window button is the first button in the
  palette.  When you click the window button, a new window opens,
  labeled <b>window1</b>. The Properties dialog now shows information
  about the window, including Type, Position, and Caption.
</p>

<p>
  The next step is adding signals, so that your window will have an
  action. In the properties dialog, select the <b>Signals</b>
  tab. Then, click the <b>...</b> next to the signal entry box to
  display a list of predefined signals available to you. Select
  "delete_event," one of the GtkWidget signals.  Leave it with the
  default name, "on_window1_delete_event". You can use this signal to
  quit your application when the window closes.  
</p>

<p>
  Next, add a button to your window: click the button tool in the
  palette (it's in the left column, with an "OK" on it) and
  then click in your new window.  Because you have not placed anything
  else in the window, the button will fill all the available space.
</p>


<blockquote>
  <p> <b>Note:</b> In Glade, there are four categories of widget: Gtk+
  Basic, Gtk+ Additional, GNOME, and Deprecated. The first two are
  easily portable to Windows and Macintosh OS X. If you are developing
  for Linux only, you may find the items in the GNOME category to be
  useful, in particular the "Druid" or assistant object, the font
  selector, and icon lists. The Deprecated tools, obviously, are not
  recommended.
</p> 
</blockquote>


<p>
  Just like the window, the button needs a signal before it can do
  anything.  In the properties window, click <b>Signals</b>. 
  properties and add a signal handler for the GtkButton signal
  "clicked," leaving it with the default name, "on_button1_clicked".
</p>

<p>
  Now, save your project in a new directory, naming it "button."  
  Glade will create two files for you: button.glade, which describes
  your window and button, and button.gladep, which is a Glade project file 
  we don't need to work with right now. The button.glade file should
  look like this:
</p>

</td>

<td valign="top">
  <img src="glade-m.png" border="0" />
  <br />
  <img src="glade-properties.png" border="0" />
</td>
</tr>
</table>


<pre class="code">
&lt;?xml version="1.0" standalone="no"?&gt; &lt;!--*- mode: xml -*--&gt;
&lt;!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd"&gt;

&lt;glade-interface&gt;

&lt;widget class="GtkWindow" id="window1"&gt;
  &lt;property name="visible"&gt;True&lt;/property&gt;
  &lt;property name="title" translatable="yes"&gt;window1&lt;/property&gt;
  &lt;property name="type"&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
  &lt;property name="window_position"&gt;GTK_WIN_POS_NONE&lt;/property&gt;
  &lt;property name="modal"&gt;False&lt;/property&gt;
  &lt;property name="resizable"&gt;True&lt;/property&gt;
  &lt;property name="destroy_with_parent"&gt;False&lt;/property&gt;
  &lt;signal name="delete_event" handler="on_window1_delete_event" last_modification_time="Mon, 05 Apr 2004 13:31:33 GMT" /&gt;
  &lt;child&gt;
    &lt;widget class="GtkButton" id="button1"&gt;
      &lt;property name="border_width"&gt;10&lt;/property&gt;
      &lt;property name="visible"&gt;True&lt;/property&gt;
      &lt;property name="can_focus"&gt;True&lt;/property&gt;
      &lt;property name="label" translatable="yes"&gt;button1&lt;/property&gt;
      &lt;property name="use_underline"&gt;True&lt;/property&gt;
      &lt;property name="relief"&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
      &lt;signal name="clicked" handler="on_button1_clicked_event" last_modification_time="Mon, 05 Apr 2004 13:31:57 GMT" /&gt;

    &lt;/widget&gt;
  &lt;/child&gt;
&lt;/widget&gt;

&lt;/glade-interface&gt;
</pre>
<br />


<h2><a id="coding">Creating the Code</a></h2>

<p> 

The code we will use in this example is similiar to the code from
previous chapters. However, most of the action has moved from the
Main() method to the GladeTest constructor, because Main() is now
<b>static</b> and therefore does not belong to any class. Using the
GladeTest() method makes things simpler and neater. There are three
other portions of code you should pay special attention to. </p>

<ul>
  <li>
    As in other examples, we define namespaces and assemblies first. 
    In this example, the namespace is "GladeSamples" and
    we're using System, Gtk and Glade. The addition of Glade
    here allows us use of the Glade# assembly.
  </li>

  <li>
    Next, look at the first two lines in the Application.Init() function,
    which will hook our Glade XML file to our code.  In the first line, we
    create an instance of a Glade.XML object. The constructor is provided
    with the file name (button.glade) and the primary widget we'll be
    working with (window1). (The third parameter is for the XML
    translation domain. It defaults to null and we can ignore it for now).

  <pre class="code">
    Glade.XML gxml = new Glade.XML ("button.glade", "window1", null);</pre>
  
  <p>
    With that line, the user interface we created earlier is now
    accessible to our application as the object named 'gxml.'
  </p>
  
  <p>
    Now we'll call the Autoconnect() method in our user  interface object:
  </p> 
  
  <pre class="code">
    gxml.Autoconnect (this); </pre>
</li>


<li>
    Finally, note that importing the Glade file didn't import every
  object in it: you need to import them individually:
  <pre class="code">
[Glade.Widget]
Button button1;</pre>
  
  Once you've done that, you can interact with the object, adding more
  properties and events that aren't defined in the Glade file.  Here,
  we set the width of the button border to ten pixels: 
<pre class="code">
button1.BorderWidth=10;
</pre>
</li>
</ul>

<p>
Here's the full example:
</p>

<pre class="code">
namespace GladeSamples {
        using System;
        using Gtk;
        using Glade;

        public class GladeTest
        {
                public static void Main (string[] args)
                {
                        new GladeTest(args);
                }
<font color="green"> 
                /* The following two lines "import" the Glade objects, allowing
                 * us to work with the signal handlers we created earlier.
                 * If you do not import your objects this way, you must write
                 * your own signal handling code. */
</font>
                [Glade.Widget]      
                Button button1;

                public GladeTest (string[] args) 
                {
                        Application.Init();
<font color="green">      
                         /* The next lines load the glade file button.glade
                          * (in the current directory), select window1 and 
                          * connect it to the current object, an instance
                          * of GladeTest. */ </font>

                        Glade.XML gxml = new Glade.XML ("button.glade", "window1", null);
                        gxml.Autoconnect (this);

                        button1.BorderWidth=10;

                        Application.Run();
                }
                <font color="green">
                  /* The following two methods implement the signal handling code
                   * defined in the UI designer*/</font>

                public void on_window1_delete_event (object o, DeleteEventArgs args) 
                {
                        Application.Quit ();
                        args.RetVal = true;
                }
    
                public void on_button1_clicked (System.Object obj, EventArgs e) 
                {
                        Console.WriteLine ("Button 1 clicked");
                }
        }
}
</pre>


  <p>Save the file as GladeTest.cs, and compile it:</p>
<pre class="code">
mcs -unsafe -pkg:gtk-sharp,glade-sharp GladeTest.cs
</pre>

<p>Then, run it:</p>
<pre class="code">mono GladeTest.exe</pre>
<p>
You should get this:
</p>

<img src="sample1.png" border="0"/>



<h3><a id="self_contained">Bundling XML Into the Executable</a></h3>

<p>
  Our earlier application consisted of a single EXE file, but now we
  have an additional file to distribute: the button.glade XML
  file. Fortunately, we can embed button.glade directly into our
  executable.
</p>

<p>
  To do that, we'll use a different constructor when creating the gxml
  object. This constructor uses four parameters, the first of which is
  the System.Reflection.Assembly object that we want to contain our file.
</p>

<pre class="code">
Glade.XML gxml = new Glade.XML (<b>null</b>, "button.glade", "window1", null);
gxml.Autoconnect (this);
</pre>


<p>
  The null value there forces the application to look in the current
  assembly to find the file, instead of looking for it in the actual
  filesystem. Then, we use the resource flag on the compiler to
  compile the button.glade file into the executable:
</p>

<pre class="code">
mcs -unsafe -resource:button.glade -pkg:gtk-sharp,glade-sharp  GladeTest.cs
</pre>

</body>
</html>
