<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Rsvg#</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Charles Iliya Krempeaux" />

	<link rel="stylesheet" type="text/css" href="../../../style.css" />
</head>
<body> 

<h3>Introduction</h3>
<p>Rsvg# is a .NET binding to the librsvg library.
(<em>librsvg</em> is sometimes also call <em>rsvg</em>.) Rsvg# lets
you make use of SVG files in your applications.</p>
<p>SVG is vector graphics format which looks similar to HTML. More
specifically, SVG is a W3C vector graphics format and language for
describing two-dimensional graphics in XML.</p>
<p>One of the important things to understand about Rsvg# is that it
is a <em>rendering</em> library for SVG files. (In fact, the
"<em>R</em>" in <em>Rsvg</em> stands for <em>render</em>.) What
this means is that Rsvg does not automatically do any scaling or
resizing for you. If you want to resize or rescale, then you must
re-render. (When SVG files are rendered, they are turned into
Pixmap images, and stores in a <code>Gtk.Pixbuf</code>.)</p>
<p>This section describes how to build applications which use
Rsvg#.</p>

<h3>SVG Hello World</h3>
<p><code>svghelloworld.cs</code>:</p>
<pre class="code">
    class SvgHelloWorld
    {
            static void Main(string[] args)
            {
                    Gnome.Program program =
                    new Gnome.Program("SVG Hello World", "1.0", Gnome.Modules.UI, args);

                    MyMainWindow app = new MyMainWindow(program);
                    app.ShowAll();
 
                    program.Run();
            }
    }



    class MyMainWindow
            : Gnome.App
    {
            Gnome.Program program;

            public MyMainWindow(Gnome.Program gnome_program)
                    : base("SVG Hello World", "SVG Hello World")
            {
                    this.program = gnome_program;

                    this.DeleteEvent += delete_event;


                    string svg_file_name = "cool.svg";
                    Gdk.Pixbuf pixbuf = Rsvg.Tool.PixbufFromFile(svg_file_name);

                    Gtk.Image image = new Gtk.Image();
                    image.Pixbuf = pixbuf;

                    this.Contents = image;
            }

            private void delete_event(object obj, Gtk.DeleteEventArgs args)
            {
                    this.program.Quit();
            }
    }
</pre>
<p>compile:</p>
<pre class="console">
mcs svghelloworld.cs -pkg:rsvg-sharp,gnome-sharp,gdk-sharp
</pre>
<p>run:</p>
<pre class="console">
mono svghelloworld.exe
</pre>
<p>This code has been based on the
<a href="../gnome/hello_world.html">GNOME# Hello World</a> code.
(So, if you haven't read that tutorial yet, please go read that
first.)</p>
<p>The only lines of code that (essentially) differ from that of
the <a href="../gnome/hello_world.html">GNOME# Hello World</a>
tutorial are:</p>
<pre class="code">
                    string svg_file_name = "cool.svg";
                    Gdk.Pixbuf pixbuf = Rsvg.Tool.PixbufFromFile(svg_file_name);

                    Gtk.Image image = new Gtk.Image();
                    image.Pixbuf = pixbuf;

                    this.Contents = image;
</pre>
<p>So this is what we will focus on.</p>
<p>First we see:</p>
<pre class="code">
                    string svg_file_name = "cool.svg";
                    Gdk.Pixbuf pixbuf = Rsvg.Tool.PixbufFromFile(svg_file_name);
</pre>
<p>Here we first create a variable called
<code>svg_file_name</code> which holds the name of our SVG file
(which we are going to view). In our case, the name of our file is
<code>cool.svg</code>. In your own programs, you will have to
change this to the name of the SVG file that you have.</p>
<p>Next is where all the magic happens. Here, we make a call to the
<code>Rsvg.Tool.PixbufFromFile</code> procedure. This procedure
reads in a SVG file (which we tell it about with the
<code>svg_file_name</code> variable that we pass to it). It then
renders this SVG file into a Pixmap image and stores it in the
<code>Gdk.Pixbuf</code> variable, which we called
<code>image</code>. (If you don't know or understand the
differences between a <em>vector graphics image</em> and a
<em>pixmap graphics image</em> please read the section titled
<a href="vector_vs_pixmap.html">Vector Graphics vs. Pixmap
Graphics</a>.)</p>
<p>Now, although we have rendered our SVG file with this code. This
code does not display anything (on the screen). The next little bit
of code helps us display our rendered SVG file. This code is:</p>
<pre class="code">
                    Gtk.Image image = new Gtk.Image();
                    image.Pixbuf = pixbuf;

                    this.Contents = image;
</pre>
<p>The <code>Gtk.Image</code> class will let us display our
rendered SVG file. The first line of code above creates our
<code>Gtk.Image</code>. (Nothing complicated about that.)</p>
<p>The next line of code puts our rendered SVG image (which is
stored in the <code>pixbuf</code> variable), into our our
<code>Gtk.Image</code> variable, which we called
<code>image</code>. As you can see from the code above, we use the
<code>Pixbuf</code> property of <code>Gtk.Image</code>; anything
(of type <code>Gdk.Pixbuf</code>) that we assign to this property
gets displayed in the <code>Gtk.Image</code>.</p>
<p>The final line of code puts our <code>image</code> (our
<code>Gtk.Image</code>) into our application window. (Remember, you
have to put your GUI widgets [like <code>image</code>] into an
application window for it to be displayed on the screen. If you
don't do that, then you won't see it!)</p>

</body>
</html>
