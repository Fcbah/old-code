<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
<title>Embedding Mono - Philosophy</title>
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<h1>Embedding Mono: Philosophy</h1>

<h3>Basic concepts</h3>

<p>
  The Mono runtime can be embedded into an existing C, C++ or
  Objective-C based application.  Embedding allows developers to keep
  their existing investment on their current code base while
  extending its functionality with CIL-based components.  This is a
  key concept: to take advantage of Mono, you do not need to rewrite
  your software from scratch: you can keep everything you have today,
  and write new code in Mono, and have both universes communicate with
  each other. 
</p>

<p>
  Embedding is also known as "hosting" to developers coming from the
  .NET Framework.
</p>

<p>
  Embedding is particularly useful when you have an existing
  application, but you would like to extend its functionality either
  by reusing third-party Mono, .NET components or Java components, or
  enable developers to "script" components of your application with
  any of the .NET or Java supported languages.
</p>

<p>
  The embedding API of Mono requires some little knowledge about C and
  C#.  You might not need to read this entire document, it depends
  very much on the needs of your application.
</p>

<h3>Embedding and Platform Invocation (P/Invoke)</h3>

<p>
  P/Invoke allows Mono developers to call from the managed world APIs
  that are exposed by the C universe and provides various automatic
  marshalling mechanisms to convert information back and forth between
  the managed world and the unmanaged world.  For example, the UTF-16
  based strings that are used by Mono are transparently transformed
  into UTF-8, or UCS-2 encodings by the runtime.  Structures are
  mapped back and forth and so on.   For more details on the P/Invoke
  platform, you are encouraged to read the <a
  href="../wrapping/clibs.html">Platform Invocation</a>. 
</p>

<h3>How embedding works</h3>

<p>
  Typically you would begin with an existing C application:
</p>

<img src="existing.png"/>

<p>
  Embedding links the mono runtime with your application, so your
  application now has a full virtual execution system running
  side-by-side with it.   This is done by linking `libmono' with your
  application (we will cover the details about this later).  Once
  linked, the address space of your application would look like this:
</p>

<img src="linked.png"/>

<p>
  The Mono embedded API exposes the Mono Runtime to the existing C
  code.  The interface exposed by the Mono runtime lets the developer
  control various aspects of the runtime and inspect the code that
  runs on the CIL world inside the Mono runtime.
</p>

<p>
  Once you have the Mono runtime initialized, the most interesting
  thing to do is to load some managed code, possibly written in C#,
  Java, Basic or any other of the supported languages that the Mono
  runtime supports, this will result in an address space like this:
</p>

<img src="loaded.png"/>
<p>
  But to make the system more interesting than just load some managed
  code and have it run side-by-side with your code, Mono provides ways
  of registering callbacks in the C code that can then be invoked by
  the managed world.  
</p>

<p>
  Like this:
</p>

<img src="exposing.png"/>

<p>
  Now your existing C code can trigger methods in the managed world,
  and the managed world can react and notify of any interesting
  changes to the C code:
</p>

<img src="callback.png"/>

<p>
  The loaded assembly can be as simple as you want, some common things
  that developers have done:

  <ul>
    <li>Load a library of methods that are wired to the user interface
    of an application: GUI elements, dialog boxes are then handled on
    the managed world, while core processing remains in C.</li>

    <li>Load user defined code as assemblies, and trigger invocations
    of those from the existing C code base.</li>

    <li>Move some of the development to the managed world, gaining all
    of the benefits of managed development (exception handling,
    runtime type checking, just-in-time compilation, rich
    introspection system, type-safe libraries and more) while keeping
    your existing investment in C intact.</li>

    <li>A launcher that launches background threads to perform some
    work on behalf of the application.</li>

    <li>Embed a web application or a web service server inside your
    application.</li>

    <li>Use Mono to host the user scripting interface, turning Mono
    and the scripts into a generic plugin interface.</li>

    <li>Integrate the Mono object system with third-party object
    systems. </li>
  </ul>
</p>

<p>
  Since the Mono framework is a fairly powerful framework there are
  almost no limitations on the different kind of applications that you
  can create with the above setup.
</p>

<p>
  Next section: <a href="basics.html">The Basics</a>
</p>p>

</body>
</html>
