<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
<title>Embedding Mono - The Basics</title>
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<h1>Embedding Mono: The Basics</h1>
<br/>

<h2>Embeeding the Runtime</h2>

<p>
  In this section we cover the basics of embedding the Mono runtime in
  an application.  We use some small code snippets in the
  documentation.  If you want to look at complete samples, you are
  encouraged to look at the `samples/embed' directory in the Mono
  distribution.
</p>

<p>
  The C API for Mono is a C-based object oriented API and there are
  various conventions followed to make the API exposed to the user
  consistent.
</p>

<h3>Compiling and Linking</h3>

<p>
  As we described on the <a href="philosophy.html">introductory
  section</a> embedding the Mono runtime into your application links
  the Mono runtime with your software.
</p>

<p>
  To embed the runtime, you have to link your code against the
  Mono runtime libraries.  To do this, you want to pass the
  flags returned by pkg-config to your compiler:
</p>

        <pre class="console">

      pkg-config --cflags --libs mono
        </pre>

<p>
  <tt>pkg-config</tt> is a very convenient tool for consuming third
  party libraries in a portable fashion.  
</p>

<p>This is how you would compile and link a program with the Mono libraries:</p>

        <pre class = "console">

      $ gcc sample.c `pkg-config --cflags --libs mono`
        </pre>

<p>
  You can also separate the compilation flags from the linking flags, for
  instance, you can use the following macros in your makefile:
</p>
    
        <pre class="console">

     CFLAGS=`pkg-config --cflags mono`
     LDFLAGS=`pkg-config --libs mono`
        </pre>

<h3>Initializing the Mono Runtime</h3>

<p>To initialize the runtime, call mono_jit_init, like this:</p>

<pre class="code">
      MonoDomain *domain;
     
      domain = mono_jit_init ("domain-name");
</pre>

<p>
        That will return a MonoDomain where your code will be
        executed.  You can create multiple domains.  Each domain is
        isolated from the other domains and code in one domain will
        not interfere with code in other domains.  This is useful if
        you want to host different applications in your program.
</p>

<p>
        Now, it is necessary to transfer control to Mono, and setup
        the threading infrastructure, you do this like this:
</p>
   
<pre class="code">
      void *user_data = NULL;

      mono_runtime_exec_managed_code (domain, main_thread_handler, user_data);
</pre>

<p>Where your main_thread_handler can load your assembly and execute it:</p>

<pre class="code">

      static void main_thread_handler (gpointer user_data)
      {
              MonoAssembly *assembly;
      
              assembly = mono_domain_assembly_open (domain, "file.dll");
              if (!assembly)
                      error ();
      }
</pre>

<p>
  In the above example, the contents of `file.dll' will be
  loaded into the domain.  This only loads the code, but it will
  not execute anything yet.  You can replace `file.dll' with
  another transport file, like `file.exe'
</p>
<p>
  To start executing code, you must invoke a method in the
  assembly, or if you have provided a static Main method (an
  entry point), you can use the convenience function:
</p>
   
<pre class="code">
      retval = mono_jit_exec (domain, assembly, argc - 1, argv + 1);
</pre>

<p>
  If you want to invoke a different method, look at the
  `Invoking Methods in the CIL universe' section later on.
</p>

<h3>Shutting down the runtime</h3>
<p>
        To shutdown the Mono runtime, you have to clean up all the
        domains that were created, use this function:
</p>

<pre class="code">
     mono_jit_cleanup (domain);
</pre>

<p>
  The exit code from the running the assembly is available by calling
  the <tt>mono_environment_exitcode_get()</tt> function. 
</p>

<h3>Assemblies and Images</h3>

<p>
   In the previous section we informally introduced the `MonoAssembly *' 
   type: this represents an assembly loaded in memory.   Assemblies
   are a unit of deployment in the ECMA CLI: they contain code and
   resources in a single package.
</p>

<p>
   Here is the public API for dealing with assemblies in Mono:
</p>

<dl class="box">
  <dt><tt>MonoAssembly *mono_assembly_open (const char *filename, MonoImageOpenStatus *status);</tt></dt>
   
  <dd>
   <br/>
   Loads the assembly located in filename.  Returns NULL on failure
   (and the status pointer is set to the details for the failure) or
   a MonoAssembly pointer on success'.</dd><br/>
   
  <dt><tt>MonoImage *mono_assembly_get_image  (MonoAssembly *assembly);</tt></dt>
  <dd>
    <br/>
    Returns the image containing the code and metadata for the given assembly.
  </dd><br/>

  <dt><tt>MonoImage *mono_assembly_load_module (MonoAssembly
   *assembly, guint32 idx);</tt></dt>
   <dd>
    <br/>
     Loads a specific module from the assembly as opposed to the
   default one
   </dd><br/>
</dl>

<h3>Types</h3>

<p>
  CIL types are represented in C with the `MonoClass *' type and
  objects are represented with the `MonoObject *' type.  These APIs
  are of the Object-oriented C fashion, the accessor methods for
  MonoClass and MonoObjects are:
</p>

<dl class="box">
  <dt><tt>MonoClass *mono_class_from_name (MonoImage *image, const char* namespace, const char *name);</tt></dt>
  <dd>
    <br/>
    Obtains a MonoClass with a given namespace and a given name which
    is located in the given MonoImage.   Given a MonoImage.
    <br/>
    You can also pass `NULL' to the image, and that will lookup for
    a type with the given namespace and name in all of the loaded
    assemblies: notice that since there might be a name clash in this
    case, passing NULL is not encouraged if you need a precise type.
  </dd><br/>
   
  <dt><tt>MonoClass *
mono_class_from_name_case  (MonoImage *image, const char* name_space, const char *name);</tt></dt>

  <dd>
    <br/>
    Obtains a MonoClass with a given namespace and a given name which
    is located in the given MonoImage.   The namespace and name
    lookups are case insensitive.
    <br/>
    You can also pass `NULL' to the image, and that will lookup for
    a type with the given namespace and name in all of the loaded
    assemblies: notice that since there might be a name clash in this
    case, passing NULL is not encouraged if you need a precise type.
  </dd><br/>

  <dt><tt>MonoImage *mono_class_get_image (MonoClass *klass);</tt></dt>
   <dd>
     Returns the MonoImage from a given MonoClass.
   </dd>
</dl>

<h3>Looking up Methods</h3>

<p>
  Calling a method in the CIL universe from C requires a number of steps:
  <ul>
    <li>Obtaining the MonoMethod handle to the method.</li>
    <li>The method invocation.</li>
  </ul>
</p>

<p>
  There are various ways of obtaining a method, you can use the
  iterator API to find the appropriate method in your class:
</p>

<dl class="box">
  <dt><tt>MonoMethod *mono_class_get_methods (MonoClass *klass, gpointer *iter)</tt></dt>
  <dd>
    <br/>
    This routine is an iterator routine for retrieving the fields in a class.
    <br/>
    You must pass a gpointer that points to zero and is treated as an opaque handle to
    iterate over all of the elements.  When no more values are
    available, the return value is NULL.
    <br/>
    Returns a MonoMethod on each iteration or NULL when no more methods are available.
  </dd>
</dl>

<p>
  For example, the following is a simple mechanism to looks up the method `Main':
</p>

<pre class="code">
        gpointer iter = NULL;
	MonoMethod *method;

        while ((m = mono_class_get_methods (klass, &amp;iter))) {
                if (strcmp (mono_method_get_name (m), "Main") == 0) {
                        method = m;
			break;
                } 
        }
</pre>

<p>
  At the end of the loop, the variable `method' will contain a
  description of the Main method, and it is ready to be invoked.
</p>
  
<p>
  The iterator model is convenient if you want to extract various
  methods in one pass.  If this is not required, you can use a higher
  level routine:
</p>


<dl class="box">
  <dt><tt>MonoMethod *mono_method_get (MonoImage *image, const char *name)</tt></dt>
  <dd>
    <br/>
    Returns the method matching `name', which conforms to the following
    specification:
    <br/>
    [namespace.]classname:methodname[(args...)]
    <br/>
    It looks for it on the `image', or if NULL is specified, in all of
    the loaded assemblies.
  </dd>
</dl>

<h3>Invoking Methods</h3>

<p>There are two functions to call a managed method:</p>

<dl class="box">
  <dt><tt>MonoObject* mono_runtime_invoke (MonoMethod *method, void *obj, void **params, MonoObject **exc);</tt></dt>
  <dt><tt>MonoObject* mono_runtime_invoke_array (MonoMethod *method, void *obj, MonoArray *params, MonoObject **exc);</tt></dt>
  <dd>
    <br/>
    Invokes the method represented by `method' on the object `obj'.
    <p>
    obj is the 'this' pointer, it should be NULL for static
    methods, a MonoObject* for object instances and a pointer to
    the value type for value types.
    </p>
    <p>
    The params array contains the arguments to the method with the
    same convention: MonoObject* pointers for object instances and
    pointers to the value type otherwise. The _invoke_array
    variant takes a C# object[] as the params argument (MonoArray
    *params): in this case the value types are boxed inside the
    respective reference representation.
    </p>
    <p>
    From unmanaged code you'll usually use the
    mono_runtime_invoke() variant.
    </p>
    <p>
    Note that this function doesn't handle virtual methods for
    you, it will exec the exact method you pass: we still need to
    expose a function to lookup the derived class implementation
    of a virtual method (there are examples of this in the code,
    though).
    </p>
    <p>
    You can pass NULL as the exc argument if you don't want to
    catch exceptions, otherwise, *exc will be set to the exception
    thrown, if any.  if an exception is thrown, you can't use the
    MonoObject* result from the function.
    </p>
    <p>If the method returns a value type, it is boxed in an object
    reference.</p>
  </dd>
</dl>

<h3>Instantiation of objects</h3>

<p>
   Mono objects are represented as pointers to instances of the
   MonoObject C type, there are various operations available on
   MonoObjects, but for now we will focus on the most common of the
   operations: instantiating an object from C.
</p>

<dl class="box">
  <dt><tt>MonoObject *mono_object_new (MonoDomain *domain, MonoClass *klass);</tt></dt>
  <dd>
    Returns a newly created object whose definition is
    looked up using @klass.   This will not invoke any constructors, 
    so the consumer of this routine has to invoke any constructors on
    its own to initialize the object.
  </dd>
</dl>
  
<p>
  The above API call creates an instance of the class referenced by
  `klass' in the specified `domain'.  The domain is used to specify in
  which application domain the object will be created.  Domain was one
  of the first things that we covered, and we will get back to this
  with more detail in the upcoming sections.
</p>

<p>
  The object created has not invoked any constructors on it, it is the
  responsibility of the caller to initialize the object.
</p>

<pre class="code">
	MonoMethod *ctor = mono_method_get (image, "MyNS.MyType:.ctor");
	MonoObject *obj = mono_object_new (domain, klass);

	/* Ignore exceptions, pass no parameters */
	mono_runtime_invoke (method, obj, NULL, NULL);
</pre>

<h3>Mappings</h3>

</body>
</html>
