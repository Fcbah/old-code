<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
<title>The Mono Handbook - Using the Mono Debugger</title>
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<h1>Using the Mono Debugger</h1>
<h2>Contents</h2>
<ol>
<li><a href="#intro">Introduction</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#run">Run</a></li>
<li><a href="#commands">Commands</a></li>
<li><a href="#credits">Credits</a></li>
</ol>

<h2><a id="intro">Introduction</a></h2>
A debugger is an important tool for development. Martin Baulig, the
author of the mono debugger has probably written the best debugger
on the planet ;-). It takes not only mono applications, but can
also debug C native code. It is splitted in front- and backends, so
a console version is available, as well as a grafical Gtk#
frontend.

<h2>Preparing your Program</h2>

<p>
  To use the debugging facilities in Mono, you should compile your
  program with debugging information.   This is achieved by passing
  the <tt>-debug+</tt> or its alias <tt>-g</tt> option to the command
  line compiler.
</p>

<pre class="console">
      $ mcs -g hello.cs
</pre>

<p> 
  Stack traces in Mono by default do not include line-number
  information, as they have a performance hit on JIT compilation.  To
  obtain stack traces, pass the --debug option to mono when running
  your application:
</p>

<pre class="console">
      $ mono --debug hello.exe
</pre>
  
<h2><a id="run">Run</a></h2>

<p>Start the command line version of the debugger like this:</p>

<pre class="console">
      $ mdb Application.exe
</pre>

<p>to debug a managed application or</p>

<pre class="console">
      $ mdb nativeapplication
</pre>

<p>to debug a native application.</p>

<p>In both cases, the debugger stops at the beginning of your application's
entry point (for unmanaged applications, this is <i>main ()</i>, for managed
ones, it's <i>Someclass:Main</i>).</p>

<p>(FIXME: There should be a <i>start</i> command to specify the target
after starting the debugger).</p>

<h2><a id="commands">Commands</a></h2>

<h3>Quitting and restarting</h3>

<p>To quit a debugging session, just type</p>
<pre class="console">
(mdb) quit
</pre>

<p>You can also restart a debugging session by typing</p>
<pre class="console">
(mdb) restart
</pre>

<p>This'll restart your debugging session and stop at the applications's
entry point.  However, all your breakpoints are preserved.</p>

<h3>Running and single stepping</h3>

<p>The debugger has several commands to single step the target:</p>

<dl>
<dt><b>continue</b>, <b>c</b></dt>
<dd>Resume execution of the target until it exists or receives a signal.</dd>
<dt><b>step</b>, <b>s</b></dt>
<dd>Step one source line.</dd>
<dt><b>next</b>, <b>n</b></dt>
<dd>Step one source line, but step over method calls.</dd>
<dt><b>finish</b></dt>
<dd>Run until the end of the current method.</dd>
<dt><b>stepi</b>, <b>i</b></dt>
<dd>Step one machine instruction.
<pre class="console">
(mdb) frame
#0: 0x401ba443 in X.Main()+0x3 at Foo.cs:218
 218 		Simple ();
(mdb) stepi
Process @3 stopped at #0: 0x401ba5a0 in X.Simple() at Foo.cs:111.
 111 	public static void Simple ()
X.Simple():
0x401ba5a0	push   %ebp
</pre>
This command will not enter JIT trampolines unless the <i>-native</i> argument
is given:
<pre class="console">
(mdb) frame
#0: 0x401ba443 in X.Main()+0x3 at Foo.cs:218
 218 		Simple ();
(mdb) stepi -native
Process @3 stopped at #0: 0x0830f878.
0x0830f878	push   $0x82b4398
</pre></dd>
<dt><b>nexti</b>, <b>t</b></dt>
<dd>Step one machine instruction, but step over method calls.</dd>
</dl>

<p>Of course, the debugger may stop earlier if the target receives a
signal (or exists).</p>

<h3>Stack frames and backtraces</h3>

<p>When the target stopped, you normally want to see the current stack
frame or get a backtrace:</p>

<dl>
<dt><b>backtrace</b>, <b>bt</b></dt>
<dd>Prints a backtrace.
<pre class="console">
Process @3 stopped at #0: 0x401ba5cd in X.Simple()+0x2d at Foo.cs:113.
 113 		int a = 5;
(mdb) bt
(*) #0: 0x401ba5cd in X.Simple()+0x2d at Foo.cs:113
    #1: 0x401ba448 in X.Main()+0x8 at Foo.cs:219
</pre>
Takes an optional <i>-max</i> command specifying the maximum number of frames to print:
<pre class="console">
(mdb) bt -max 8
</pre></dd>
<dt><b>frame</b>, <b>f</b></dt>
<dd>Show the current stack frame or the frame specified by the optional
<i>-frame</i> argument:
<pre class="console">
Process @3 stopped at #0: 0x401ba5cd in X.Simple()+0x2d at Foo.cs:113.
 113 		int a = 5;
(mdb) frame -frame 1
#1: 0x401ba448 in X.Main()+0x8 at Foo.cs:219
 219 		BoxedValueType ();
</pre></dd>
<dt><b>up</b>, <b>down</b></dt>
<dd>Walks one frame up or down in the current backtrace.  Prints the new
stack frame.
<pre class="console">
Process @3 stopped at #0: 0x401ba5cd in X.Simple()+0x2d at Foo.cs:113.
 113 		int a = 5;
(mdb) up
#1: 0x401ba448 in X.Main()+0x8 at Foo.cs:219
 219 		BoxedValueType ();
(mdb) frame
#1: 0x401ba448 in X.Main()+0x8 at Foo.cs:219
 219 		BoxedValueType ();
(mdb) dis
0x401ba448	call   X.BoxedValueType()
</pre>
</dd>
</dl>

<h3>Printing expressions</h3>

<p>The debugger has a built-in expression evaluator which uses a C#-like
language.</p>

<p>Let's assume you're debugging the following C# method:</p>

<pre class="code">
public static void Simple ()
{
	int a = 5;
	long b = 7;
	float f = (float) a / (float) b;

	string hello = "Hello World";

	// You are stopped here.
	Console.WriteLine (a);
	Console.WriteLine (b);
	Console.WriteLine (f);
	Console.WriteLine (hello);
}	
</pre>

<p>Now you can print variables or simple expressions:</p>

<pre class="console">
(mdb) print 8
8
(mdb) print "Hello World"
"Hello World"
(mdb) print a
5
(mdb) print b
7
(mdb) print f
0.7142857
(mdb) print hello
"Hello World"
</pre>

<p>You can also modify variables in the target while printing them
(FIXME: There should be a <i>set</i> or <i>eval</i> command for this).</p>

<pre class="console">
(mdb) print a
5
(mdb) print a=8
8
(mdb) print a
8
(mdb) print hello
"Hello World"
(mdb) print hello="Boston"
"Boston"
(mdb) print hello
"Boston"
</pre>

<p>The debugger also does type checking when assigning managed variables:</p>

<pre class="console">
(mdb) print hello=a
Type mismatch: cannot assign expression of type `System.Int32' to variable
`hello', which is of type `System.String'.
</pre>

<p>To view the type of an expression, use the <i>ptype</i> command:</p>

<pre class="console">
(mdb) ptype a
System.Int32
(mdb) ptype b
System.Int64
(mdb) ptype f
System.Single
(mdb) ptype hello
System.String
</pre>

<p>You can also view the contents of a processor register:</p>

<pre class="console">
(mdb) print %eax
0x401b7440
(mdb) print %ebp
0x40bbe888
(mdb) print %esp
0x40bbe888
(mdb) show registers
EAX=401b7440 EBX=4019f3f8 ECX=00000000 EDX=0816fee0 ESI=0817bfc0 EDI=081e4990
EBP=40bbe888 ESP=40bbe888 EIP=401b7443 EFLAGS=PF ZF TF IF ID
</pre>

<h3>Invoking methods in the target</h3>

<p>The debugger can also invoke methods in the target.  Let's have a look
at the following example:</p>

<pre class="code">
using System;

class X
{
	public static void Foo (int a)
	{
		Console.WriteLine ("Foo: {0}", a);
	}

	public static void Foo (string b)
	{
		Console.WriteLine ("Foo with a string: {0}", b);
	}

	public static void Hello (int a)
	{
		Console.WriteLine ("Hello: {0}", a);
	}

	public static void Main ()
	{
		int a = 5;
		string hello = "Boston";

		// You are stopped here.
		Foo (a);
		Foo (hello);
		Hello (a);
	}
}
</pre>

<p>Now you're stopped in <i>Main</i> and want to invoke methods.</p>

<pre class="console">
(mdb) print Foo (3)
Foo: 3
Method `Foo ()' doesn't return a value.
(mdb) print Foo ("Hello World")
Foo with a string: Hello World
Method `Foo ()' doesn't return a value.
(mdb) print Hello (9)
Hello: 9
Method `Hello ()' doesn't return a value.
(mdb) print Hello (a)
Hello: 9
Method `Hello ()' doesn't return a value.
(mdb) print Foo (hello)
Foo with a string: Boston
Method `Foo ()' doesn't return a value.
</pre>

<p>Note how the debugger automatically does overload resolution
when calling <i>Foo</i>.</p>

<h3>Breakpoints</h3>

<p>Breakpoints are inserted with the <i>break</i> command.  Without
arguments, this command inserts a breakpoint at the current source
line.</p>

<pre class="console">
Process @3 stopped at #0: 0x401b7443 in X.Main()+0x3 at Foo.cs:218.
 218 		Simple ();
(mdb) b
Inserted breakpoint 2 at Foo.cs:218
</pre>

<p>After inserting the breakpoint, the debugger tells you the breakpoint
number which can be used to enable, disable or remove the breakpoint:</p>

<pre class="console">
(mdb) show breakpoints
Breakpoints:
2 (global): * Mono.Debugger.SimpleBreakpoint (2:Foo.cs:218)
(mdb) disable 2
(mdb) show breakpoints
Breakpoints:
2 (global):   Mono.Debugger.SimpleBreakpoint (2:Foo.cs:218)
(mdb) enable 2
(mdb) show breakpoints
Breakpoints:
2 (global): * Mono.Debugger.SimpleBreakpoint (2:Foo.cs:218)
(mdb) delete 2
(mdb) show breakpoints
Breakpoints:
</pre>

<p>However, most of the time, you don't want to insert a breakpoint at
the current location, but somewhere else.  Let's have a look at the following
example:</p>

<pre class="code">
using System;

class X
{
	public static void Foo (int a)
	{
		Console.WriteLine ("Foo: {0}", a);
	}

	public static void Foo (string b)
	{
		Console.WriteLine ("Foo with a string: {0}", b);
	}

	public void Test (long a)
	{
		Console.WriteLine ("Test: {0}", a);
	}

	public static void Hello (int a)
	{
		Console.WriteLine ("Hello: {0}", a);
	}

	public static void Main ()
	{
		int a = 5;
		string hello = "Boston";
		X x = new X ();

		// You are stopped here.
		Foo (a);
		Foo (hello);
		Hello (a);
		x.Test (9);
	}
}
</pre>

<p>The syntax to insert a breakpoint is very similar to the one to invoke a method
in the target:</p>

<pre class="console">
Process @3 stopped at #0: 0x401b749a in X.Main()+0x5a at /home/martin/work/Test.cs:32.
  32 		Foo (a);
(mdb) b Hello
Inserted breakpoint 2 at X.Hello(System.Int32)
(mdb) b X.Hello
Inserted breakpoint 3 at X.Hello(System.Int32)
(mdb) b x.Test
Inserted breakpoint 4 at X.Test(System.Int64)
</pre>

<p>Note how similar it is to invoking a method; you cannot use the method name alone
to insert a breakpoint on an instance method if you're in static context:</p>

<pre class="console">
(mdb) b Test
No such method.
(mdb) b X.Test
Expression `X.Test' is not a variable or value.
</pre>

<p>Of course, this only applies if you're in static context - just like you'd do
things in C#:</p>

<pre class="console">
Process @3 stopped at #0: 0x40bc082e in X.Test(System.Int64)+0xe at Test.cs:17.
  17 		Console.WriteLine ("Test: {0}", a);
(mdb) b Test
Inserted breakpoint 2 at X.Test(System.Int64)
</pre>

<p>If the method is ambiguous, overload resolution is performed using types:</p>

<pre class="console">
Process @3 stopped at #0: 0x401b749a in X.Main()+0x5a at Test.cs:32.
  32 		Foo (a);
(mdb) b Foo(System.Int32)
Inserted breakpoint 2 at X.Foo(System.Int32)
(mdb) b Foo(System.String)
Inserted breakpoint 3 at X.Foo(System.String)
</pre>

<p>If you just use a method name, the debugger presents you a list and you can
just pick a method from that list:</p>

<pre class="console">
Process @3 stopped at #0: 0x401b749a in X.Main()+0x5a at Test.cs:32.
  32 		Foo (a);
(mdb) b Foo
More than one method matches your query:
   1  X.Foo(System.Int32)
   2  X.Foo(System.String)

(mdb) b -id 1
Inserted breakpoint 2 at X.Foo(System.Int32)
(mdb) b -id 2
Inserted breakpoint 3 at X.Foo(System.String)
</pre>

<p>You can also specify a source file and line number to insert a breakpoint:</p>

<pre class="console">
Process @3 stopped at #0: 0x401b749a in X.Main()+0x5a at Test.cs:32.
  32 		Foo (a);
(mdb) list Hello
  18 
  19 	public static void Hello (int a)
  20 	{
  21 		Console.WriteLine ("Hello: {0}", a);
  22 	}
  23 
  24 	public static void Main ()
  25 	{
  26 		int a = 5;
  27 		string hello = "Boston";
(mdb) b 21
Inserted breakpoint 2 at /home/martin/work/Test.cs:21
(mdb) b /home/martin/work/Test.cs:26
Inserted breakpoint 3 at /home/martin/work/Test.cs:26
</pre>

<p><b>FIXME:</b> In the current version of the debugger, you need to specify the
file's full pathname, even it it's in the same directory.</p>

<h3>Displaying a method's source code</h3>

<p>You can also view a method's source code by using the <i>list</i> command.
The syntax is identical to <i>break</i>:</p>

<pre class="console">
Process @3 stopped at #0: 0x401b749a in X.Main()+0x5a at Test.cs:32.
  32 		Foo (a);
(mdb) list
  30 		// You are stopped here.
  31 		Foo (a);
  32 		Foo (hello);
  33 		Hello (a);
  34 		x.Test (9);
  35 	}
  36 }
(mdb) list Hello
  18 
  19 	public static void Hello (int a)
  20 	{
  21 		Console.WriteLine ("Hello: {0}", a);
  22 	}
  23 
  24 	public static void Main ()
  25 	{
  26 		int a = 5;
  27 		string hello = "Boston";
</pre>

<p>This command takes an optional <i>-count</i> argument to specify the number of
source lines to display:</p>

<pre>
Process @3 stopped at #0: 0x401b749a in X.Main()+0x5a at Test.cs:32.
  32 		Foo (a);
(mdb) list -count 5
  30 		// You are stopped here.
  31 		Foo (a);
  32 		Foo (hello);
  33 		Hello (a);
  34 		x.Test (9);
</pre>

<h3>Disassembling</h3>

<p>To disassembly the current instruction or the current method,
use the <i>dis</i> command:</p>

<pre class="console">
(mdb) Process @3 stopped at #0: 0x401b7443 in X.Main()+0x3 at Foo.cs:218.
 218 		Simple ();
(mdb) dis
0x401b7443	call   X.Simple()
(mdb) dis -method
X.Main():
0x401b7440	push   %ebp
0x401b7441	mov    %esp,%ebp
0x401b7443	call   X.Simple()
0x401b7448	call   X.BoxedValueType()
0x401b744d	call   X.BoxedReferenceType()
0x401b7452	call   X.SimpleArray()
0x401b7457	call   X.MultiValueTypeArray()
0x401b745c	call   X.StringArray()
0x401b7461	call   X.MultiStringArray()
0x401b7466	call   X.StructType()
0x401b746b	call   X.ClassType()
0x401b7470	call   X.InheritedClassType()
0x401b7475	call   X.ComplexStructType()
0x401b747a	call   X.FunctionStructType()
0x401b747f	leave  
0x401b7480	ret    
</pre>

<p><b>TODO:</b> In a future version of the debugger, this command will
take an address expression as argument to allow you to disassemble
arbitrary regions of memory.  The syntax will most likely be similar to
the one of the <i>examine</i> command.</p>

<h3>Examining Memory</h3>

<p>The <i>examine</i> (short: <i>x</i>) command takes an address expression
as argument.  Such an address expression can be a processor register, an
absolute address or the address of a variable:</p>

<pre class="console">
(mdb) p %ebp
0x40bbe880
(mdb) x %ebp
0x40bbe880   88 e8 bb 40 48 74 1b 40 - b0 e8 bb 40 a3 74 1b 40
(mdb) p %eip
0x401b7619
(mdb) x 0x401b7619
0x401b7619   56 e8 b9 5c 16 c8 83 c4 - 04 ff 75 ec ff 75 e8 e8
(mdb) x &amp;f
0x40bbe864   6e db 36 3f 07 00 00 00 - 00 00 00 00 48 74 1b 40
</pre>

<p>When trying to take the address of a variable, keep in mind that some
variables may be stored in a processor register, so they don't have an
address:</p>

<pre class="console">
(mdb) p a
5
(mdb) ptype a
System.Int32
(mdb) x &amp;a
Cannot take address of expression `a'
</pre>

<p>By default, the <i>examine</i> command prints 16 bytes of memory, but
you can change this by giving it the optional <i>-size</i> argument:</p>

<pre class="console">
(mdb) x -size 64 %esp
0x40bbe888   b0 e8 bb 40 a3 74 1b 40 - b0 e8 bb 40 e0 d7 05 40
0x40bbe898   48 db 2a 08 8b 6b 01 00 - e0 e8 bb 40 c8 d7 05 40
0x40bbe8a8   d8 fe 16 08 f8 f3 19 40 - e0 e8 bb 40 84 d9 05 40
0x40bbe8b8   00 00 00 00 30 e9 bb 40 - 00 00 00 00 40 74 1b 40
</pre>

<p>If you want to see more data, just hit return:</p>

<pre class="console">
(mdb) x -size 32 %esp
0x40bbe888   b0 e8 bb 40 a3 74 1b 40 - b0 e8 bb 40 e0 d7 05 40
0x40bbe898   48 db 2a 08 8b 6b 01 00 - e0 e8 bb 40 c8 d7 05 40
(mdb) 
0x40bbe8a8   d8 fe 16 08 f8 f3 19 40 - e0 e8 bb 40 84 d9 05 40
0x40bbe8b8   00 00 00 00 30 e9 bb 40 - 00 00 00 00 40 74 1b 40
(mdb) 
0x40bbe8c8   20 32 13 42 98 48 30 08 - 40 74 1b 40 88 74 1b 40
0x40bbe8d8   60 d6 2a 08 f8 f3 19 40 - 00 e9 bb 40 c8 97 0b 40
(mdb) 
0x40bbe8e8   48 db 2a 08 00 00 00 00 - 30 e9 bb 40 00 00 00 00
0x40bbe8f8   40 1e 1e 08 f8 f3 19 40 - 40 e9 bb 40 34 a7 0b 40
</pre>

<h2><a id="credits">Credits</a></h2>
Author: <a href="mailto:martin%20at%20ximian.com">Martin Baulig</a>

<div class="copyright">The Mono Handbook -
<a href="http://www.go-mono.org">&#169; Copyright 2002 by Johannes
Roith</a></div>
</body>
</html>
