<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>C# &amp; VB Compiler - Introduction</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Miguel de Icaza" />
	<meta name = "DC.Contributor" content = "Johannes Roith" />


	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>

<h2>Contents</h2>
<ul>
<li>1. <a href="#mcs">MCS: The Ximian C# compiler</a></li>
<li>2. <a href="#mbas">MBAS: Mono's Basic.NET Compiler</a></li>
<li>3. <a href="#credits">Credits</a></li>
</ul>
<h2><a name="mcs" id="mcs">MCS: The Ximian C# compiler</a></h2>

<p>
The Mono C# compiler is considered feature C# 1.0 complete at this
point and mature. MCS is able to compile itself and many more C#
programs (there is a test suite included that you can use). It is
routinely used to compile Mono, roughly 1.7 million lines of C# code.
</p>

<p>
The compiler is also fairly fast. On a IBM ThinkPad t40 it compiles 18,000 lines of C# code per second.
</p>

<p>
Work on C# 2.0 has started: some pieces of it are available on the
standard compiler with the -2 switch (iterators, method conversions)
and some others are available on the `gmcs' branch on CVS (generics)
</p>

<p>MCS is the Mono C# compiler. Interestingly, it's written in C#
itself and therefore highly portable. (There is no need to port it).</p>

<p>Mcs doesn't compile native code, but a kind of bytecode, that
can be processed by the mono runtime, like the image shows:</p>
<p><img src="compiling.png" /></p>
<h4>History</h4>
<p>MCS was able to parse itself on April 2001, MCS compiled itself
for the first time on December 28 2001. MCS became self hosting on
January 3rd, 2002. The Mono Runtime and the Mono execution engine
were able to make our compiler self hosting on March 12, 2002.</p>
<h4>Obtaining and running MCS</h4>
<p>The Mono C# compiler is part of the `mcs' module in the Mono CVS
you can get it from our <a href="anoncvs.html">Anonymous CVS</a>
server, or you can get nightly <a href="download.html">download
page</a>.<br />
MCS is written in C# and uses heavily the .NET APIs. MCS runs on
Linux with the Mono runtime and on Windows with both the .NET
runtime and the Mono runtime.</p>

<h4>CIL Optimizations.</h4>
<p>The compiler performs a number of simple optimizations on its
input: constant folding (this is required by the C# language spec)
and can perform dead code elimination. Other more interesting
optimizations like hoisting are not possible at this point since
the compiler output at this point does not generate an intermediate
representation that is suitable to perform basic block
computation.<br />
<br />
Adding an intermediate layer to enable the basic block computation
to the compiler should be a simple task, but we are considering
having a generic CIL optimizer. Since all the information that is
required to perform basic block-based optimizations is available at
the CIL level, we might just skip this step altogether and have
just a generic IL optimizer that would perform hoisting on
arbitrary CIL programs, not only those produced by MCS.<br />
<br />
If this tool is further expanded to perform constant folding (not
needed for our C# compiler, as it is already in there) and dead
code elimination, other compiler authors might be able to use this
generic CIL optimizer in their projects reducing their time to
develop a production compiler.</p>
<h4>Reporting Bugs in MCS</h4>
<p>When you report a bug, try to provide a small test case that
would show the error so we can include this as part of the Mono C#
regression test suite. If the bug is an error or a warning that we
do not flag, write a sample program called `csXXXX.cs' where XXXX
is the code number that is used by the Microsoft C# compiler that
illustrates the problem. That way we can also do regression tests
on the invalid input.</p>
<h4>Questions and Answers</h4>
<p><a name="q1" id="q1"></a><b>Question 1:</b> Why not write a C#
front-end for GCC?</p>
<p>I wanted to learn about C#, and this was an exercise in this
task. The resulting compiler is highly object-oriented, which has
lead to a very nice, easy to follow and simple implementation of
the compiler.</p>
<p>I found that the design of this compiler is very similar to
Guavac's implementation.</p>
<p>Targeting the CIL/MSIL byte codes would require to
re-architecting GCC, as GCC is mostly designed to be used for
register machines. The GCC Java engine that generates Java byte
codes cheats: it does not use the GCC backend; it has a special
backend just for Java, so you can not really generate Java
bytecodes from the other languages supported by GCC.</p>
<p><a name="q2" id="q2"></a><b>Question 2:</b> If your C# compiler
is written in C#, how do you plan on getting this working on a
non-Microsoft environment.</p>
<p>We will do this through an implementation of the CLI Virtual
Execution System for Unix (our JIT engine).</p>
<p>Our JIT engine is working for the purposes of using the
compiler. The supporting class libraries are being worked on to
fully support the compiler.</p>
<p><a name="q3" id="q3"></a><b>Question 3:</b> Do you use
Bison?</p>
<p>No, currently I am using Jay which is a port of Berkeley Yacc to
Java that I later ported to C#. This means that error recovery is
not as nice as I would like to, and for some reason error
productions are not being caught.</p>
<p>In the future I want to port one of the Bison/Java ports to C#
for the parser.</p>
<p><a name="q4" id="q4"></a><b>Question 4:</b> Should someone work
on a GCC front-end to C#?</p>
<p>I would love if someone does, and we would love to help anyone
that takes on that task, but we do not have the time or expertise
to build a C# compiler with the GCC engine. I find it a lot more
fun personally to work on C# on a C# compiler, which has an
intrinsic beauty.</p>
<p>We can provide help and assistance to anyone who would like to
work on this task.</p>
<p><a name="q5" id="q5"></a><b>Question 5:</b> Should someone make
a GCC backend that will generate CIL images?</p>
<p>I would love to see a backend to GCC that generates CIL images.
It would provide a ton of free compilers that would generate CIL
code. This is something that people would want to look into anyways
for Windows interoperation in the future.</p>
<p>Again, we would love to provide help and assistance to anyone
interested in working in such a project.</p>
<p><a name="q6" id="q6"></a><b>Question 6:</b> What about making a
front-end to GCC that takes CIL images and generates native
code?</p>
<p>I would love to see this, specially since GCC supports this same
feature for Java Byte Codes. You could use the metadata library
from Mono to read the byte codes (ie, this would be your
"front-end") and generate the trees that get passed to the
optimizer.</p>
<p>Ideally our implementation of the CLI will be available as a
shared library that could be linked with your application as its
runtime support.</p>
<p>Again, we would love to provide help and assistance to anyone
interested in working in such a project.</p>
<p><a name="q7" id="q7"></a><b>Question 7:</b> But would this work
around the GPL in the GCC compiler and allow people to work on
non-free front-ends?</p>
<p>People can already do this by targeting the JVM byte codes
(there are about 130 compilers for various languages that target
the JVM).</p>
<p><a name="q8" id="q8"></a><b>Question 8:</b> Why are you writing
a JIT engine instead of a front-end to GCC?</p>
<p>The JIT engine and runtime engine will be able to execute CIL
executables generated on Windows.</p>
<p>You might also want to look at the <a href=
"faq.html#gcc">GCC</a> section on the main FAQ.</p>
<h2><a name="mbas" id="mbas">MBAS: Mono's Basic.NET
Compiler</a></h2>
MBAS is a CIL compiler for the Visual Basic language, an extended
version of VisualBasic.NET. It's based on the MCS compiler and
still in heavy development, though many language features are
already supported.
<h4>What works</h4>
<ul>
<li>Classes, Fields and Methods. Properties are still being worked
on.</li>
<li>Module definition and Sub functionality (TODO: Function's) *
Namespace Import, so can you reference, instantiate and call
external assemblies</li>
<li>Parameter passing between Sub's. ByVal and ByRef parameters are
being worked on.</li>
<li>Delegates</li>
<li>Object creation</li>
<li>Events - to a limited extent. You can declare a Class-Field as
'WithEvents' and dynamic events (i.e AddHandler MyButton.Click,
Button1_OnClick). Please beware: just after committing the code, I
discovered that the handler field in the AddHandler call is
case-sensitive, a remnant of mBas' mcs heritage)</li>
<li>Statements supported are 'If..Then..Else' , 'While..End While'
and assignment statements. Simple operators (+, -, *, /, &gt;,
&lt;, =) should also work. Other statements (For..Next, etc.)
should be quite trivial to implement.</li>
</ul>
A lot of this stuff is implemented rebuilding proper expressions
and statements on top of the classes provided by mcs (look at the
grammar - mb-parser.jay - and compare it with cs-parser.jay, if
interested).
<h4>TODO-list</h4>
At this stage almost every element of the language must be still
checked for conformance to Microsoft's implementation. Help is particularly
needed for those areas I know little of (mcs internals are still
quite obscure to me). I'd like to implement class properties, the
missing statements, exception handling, structures and actual event
support (not necessarily in this order). Once we have all this
stuff set up and reasonably bug-free, more work could be done on
helper functions and Object-vars handling.
</body>
</html>
