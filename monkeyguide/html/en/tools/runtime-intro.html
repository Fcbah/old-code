<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Mono Handbook - The Mono runtime</title>
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<h1>The Mono runtime</h1>

<h1>The Mono runtime</h1>
<p>
	The Mono runtime engine is considered feature complete.
</p>
<p>
	It implements a Just-in-Time compiler engine for the CIL
	virtual machine, the class loader, the garbage collector,
	threading system and metadata access libraries.
</p>
<p>
	We currently have two runtimes:
</p>
<p>
	<ul>
<li><b>mono:</b> Our Just-in-Time and Ahead-of-Time code
		  generator for maximum performance.  This supports
		  x86, PowerPC and SPARC cpus.</li>
	
<li><b>mint:</b> The Mono interpreter.  This is an
		  easy-to-port runtime engine.</li>
	</ul>
</p>
<p>
	We are using the Boehm conservative garbage collector.
</p>
<p>
	The Mono runtime can be used as a stand-alone process, or it
	can be <a href="embedded-api.html">embedded into applications</a> (see
	the documentation in mono/samples/embed for more details).
</p>
<p>
	Embedding the Mono runtime allows applications to be extended
	in C# while reusing all of the existing C and C++ code.  
</p>
<p>
	Paolo Molaro did a presentation on the current JIT engine and
	the new JIT engine.  You can find his <a
	href="http://primates.ximian.com/~lupus/slides/jit/">slides
	here</a>
</p>
<h3>Current JIT Engine: technical details (<b>updated, June 28th, 2003</b>)</h3>
<p>
	We have re-written our JIT compiler. We wanted to support a
	number of features that were missing:
</p>
	<ul>
<li>Ahead-of-time compilation.  
<p>
	     The idea is to allow developers to pre-compile their code
	     to native code to reduce startup time, and the working
	     set that is used at runtime in the just-in-time compiler.
</p>
<p>
	     Although in Mono this has not been a visible problem, we
	     wanted to pro-actively address this problem.
</p>
<p>
	     When an assembly (a Mono/.NET executable) is installed in
	     the system, it would then be possible to pre-compile the
	     code, and have the JIT compiler tune the generated code
	     to the particular CPU on which the software is
	     installed. 
</p>
<p>
	     This is done in the Microsoft.NET world with a tool
	     called ngen.exe
</p>
</li>
<li>Have a good platform for doing code optimizations.
<p>
	     The design called for a good architecture that would
	     enable various levels of optimizations: some
	     optimizations are better performed on high-level
	     intermediate representations, some on medium-level and
	     some at low-level representations.
</p>
<p>
	     Also it should be possible to conditionally turn these on
	     or off.  Some optimizations are too expensive to be used
	     in just-in-time compilation scenarios, but these
	     expensive optimizations can be turned on for
	     ahead-of-time compilations or when using profile-guided
	     optimizations on a subset of the executed methods.
</p></li>
<li>Reduce the effort required to port the Mono code
             generator to new architectures.
<p>
	     For Mono to gain wide adoption in the Unix world, it is
	     necessary that the JIT engine works in most of today's
	     commercial hardware platforms. 
</p></li>
	</ul>
<p>
	The JIT engine implements a number of optimizations:
</p>
	<ul>
<li>Opcode cost estimates (our architecture allows
	 	  us to generate different code paths depending
		  on the target CPU dynamically).</li>
		  
<li>Inlining.</li>
<li>Constant folding, copy propagation, dead code elimination.
<p>
		  Although compilers typically do
		  constant folding, the combination of inlining with
		  constant folding gives some very good results.
</p></li>
<li>Linear scan register allocation.  In the past,
		  register allocation was our achilles heel, but now 
		  we have left this problem behind.</li>
<li>SSA-based framework.  Various optimizations are
		  implemented on top of this framework</li>
	</ul>
<p>
	There are a couple of books that deal with this technique: "A
	Retargetable C Compiler" and "Advanced Compiler Design and
	Implementation" are good references.  You can also get a
        technical description of <a
        href="http://research.microsoft.com/copyright/accept.asp?path=http://www.research.microsoft.com/~drh/pubs/iburg.pdf&amp;pub=ACM">lbrug</a>.
</p>
<p>
	The new JIT engines uses three intermediate representations:
	the source is the CIL which is transformed into a forest of
	trees; This is fed into a BURS instruction selector that
	generates the final low-level intermediate representation.
</p>
<p>
	The instruction selector is documented in the following
	papers:
</p>
	<ul>
<li><a href="http://research.microsoft.com/copyright/accept.asp?path=http://www.research.microsoft.com/~drh/pubs/interface.pdf&amp;pub=wiley">A code generation interface for ANSI C</a></li>
<li><a href="http://research.microsoft.com/copyright/accept.asp?path=http://www.research.microsoft.com/~drh/pubs/iburg.pdf&amp;pub=ACM">Engineering efficient code generators using tree matching and dynamic programming.</a></li>
	</ul>
<h3>Garbage Collection</h3>
<p>
	We are using the Boehm conservative GC.  We might consider
	adopting other GC engines in the future, like the Intel ORP GC
	engine.  The Intel ORP GC engine as it provides a precise
	garbage collector engine, similar to what is available on the
	.NET environment.
</p>
	<ul>
<li>Garbage collection list and FAQ:<br/>
		  <a href="http://www.iecc.com/gclist/">http://www.iecc.com/gclist/</a></li>
<li>"GC points in a Threaded Environment":<br/>
		  <a href="http://research.sun.com/techrep/1998/abstract-70.html">
		  http://research.sun.com/techrep/1998/abstract-70.html</a></li>
<li>"A Generational Mostly-concurrent Garbage Collector":
		  <a href="http://research.sun.com/techrep/2000/abstract-88.html">
		  http://research.sun.com/techrep/2000/abstract-88.html</a></li>
<li>Details on The Microsoft .NET Garbage Collection Implementation:<br/>
		  <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI.asp</a>
		  <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI2.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI2.asp</a></li>
	</ul>
<h3>IO and threading</h3>
<p>
	The ECMA runtime and the .NET runtime assume an IO model and a
	threading model that is very similar to the Win32 API.  
</p>
<p>
	Dick Porter has developed WAPI: the Mono abstraction layer
	that allows our runtime to execute code that depend on this
	behaviour.
</p>
<h3>Useful links</h3>
<p>
	Paolo Molaro found a few interesting links:
</p>
	<ul>
<li>On compilation of stack-based languages:<br></br>
		<a href="http://www.complang.tuwien.ac.at/projects/rafts.html">
		http://www.complang.tuwien.ac.at/projects/rafts.html</a></li>
<li>A paper on fast JIT compilation of a stack-based language:<br></br>
		  <a href="http://www.research.microsoft.com/~cwfraser/pldi99codegen.pdf">
		  http://www.research.microsoft.com/~cwfraser/pldi99codegen.pdf</a></li>
<li>Vmgen generates much of the code for efficient virtual machine (VM)
		  interpreters from simple descriptions of the VM instructions:<br></br>
		  <a href="http://www.complang.tuwien.ac.at/anton/vmgen/">
		  http://www.complang.tuwien.ac.at/anton/vmgen</a></li>
	</ul>
<h3>PInvoke</h3>
<p>
	PInvoke is the mechanism we are using to wrap Unix API calls
	as well as talking to system libraries.
</p>
<p>
	Initially we used libffi, but it was fairly slow, so we have
	reused parts of the JIT work to create efficient PInvoke
	trampolines.
</p>
<h3>Remoting</h3>
<p>
	Mono has support for remoting and proxy objects, just like
	.NET does.  The runtime provides these facilities.
</p>
<h3>Porting</h3>
<p>
	If you are interested in porting the Mono runtime to other
	platforms, you might find the pre-compiled <a
	href="archive/mono-tests.tar.gz">Mono regression test
	suite</a> useful to debug your implementation.
</p>

</body>
</html>
