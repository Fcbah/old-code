<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
  <head>
    <title>Wrapping GObject based C Libraries</title>
    <meta name="DC.Description" content="Wrapping GObject based C Libraries" />
    <meta name="DC.Contributor" content="Martin Willemoes Hansen" />
    <meta name="DC.Contributor" content="John Luke" />
    <link rel="stylesheet" type="text/css" href="../style.css" />
  </head>
  <body>
    <ol>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#dirlayout">Directory layout</a>
      </li>
      <li>
        <a href="#sources">The sources directory</a>
      </li>
      <li>
        <a href="#namespace">The namespace directory</a>
      </li>
      <li>
        <a href="#glue">The glue directory</a>
      </li>
      <li>
        <a href="#doc">The doc directory</a>
      </li>
      <li>
        <a href="#conclusion">Conclusion</a>
      </li>
      <li>
        <a href="#wrappers">Existing Wrappers</a>
      </li>
      <li>
        <a href="#credits">Credits</a>
      </li>
    </ol>
    <h2>
      <a name="introduction" id="introduction"></a>Introduction</h2>
    <p>The focus of this section is to wrap C Libraries that are based on GObject.</p>
    <p>You can wrap the library by typing in all the code and doing all 
	the manual labor, or you could make use of the wrapping tools from Gtk#.
    Basically the Gtk# wrapper tools works by parsing a GObject C-based library and extracting
	the right information to a xml file, and then generates C# code from it.</p>
    <p>
      <a href="http://www.sigs.de/download/dotnet_02/mo11_kestner.zip">Automated library binding with Gtk# presentation</a>
    </p>
    <p>This accomplishes a lot of the work, but it is not perfect. Therefore, you will still have to
	do your fair share of the work.
	However, it is still better than doing the wrapper by hand.
    Also, it is still a good idea to wrap something manually, just to get a hang of it. 
	The rest of this introduction shows some of the wrapping techniques.</p>
    <h3>Functions</h3>
    <p>To call a function, a technique called platform invoke, or
	P/Invoke for short, is used.</p>
    <p>Example of P/Invoke:
<pre class="code">
using System;
using System.Runtime.InteropServices;
 
public class Wrapper {
	[DllImport ("libhelloworld-1.0.dll")]
	public extern static void HelloWorld();
 
	static void Main()
	{
		HelloWorld();
	}
}
</pre>
</p>
    <p>If you are working to be cross-platform, the DllImport attribute can seem like a problem. 
However, you can map .dll files to the appropriate .so files using /etc/mono/config.</p>
    <h3>Typedefs</h3>
    <p>
	One way to deal with typedefs is to make an alias.
	<pre class="code">
typedef guint32 Color
</pre>becomes
	<pre class="code">
using Color = System.UInt32;
</pre></p>
    <h3>Macros</h3>
    <p>Unfortunately it is not possible to call macros from C#.
	A workaround for this problem is to provided similar functionality as methods, 
	possibly using some glue code.</p>
    <h2>
      <a name="dirlayout" id="dirlayout"></a>Directory layout</h2>
    <p>The common way to arrange the directory layout is to create a top-level directory 
	named after the library which is being wraped, ex. foobar-sharp.
	Four new directories are created inside, namely doc, glue, foobar (namespace) 
	and sources.</p>
    <pre>
foobar-sharp/
      |
      |------ doc/
      |
      |------ glue/
      |
      |------ foobar/
      |
      \------ sources/
</pre>
    <h2>
      <a name="sources" id="sources">The sources directory</a>
    </h2>
    <p>This is the place to put the source code of the library you are wrapping.
	The parser will work with this directory.</p>
    <p>Typical files which lives here:
<pre>
sources/
   |
   |---- foobar-sharp-sources.xml
   |
   \---- makefile
</pre>
</p>
    <p>foobar-sharp-sources.xml describes the following: 
	  <ul>
        <li>the location of the api output file,</li>
        <li>the name of the library to P/Invoke,</li>
        <li>the namespace to use, and</li>
        <li>the directories containing the C source code to be parsed.</li>
      </ul>
	</p>
    <p>Content of foobar-sharp-sources.xml:
<pre class="code">
&lt;gapi-parser-input&gt;
  &lt;api filename="../foobar/foobar-api.xml"&gt;
    &lt;library name="foobar-1.0"&gt;
      &lt;namespace name="Foobar"&gt;
        &lt;dir&gt;./foobar-1.0/src&lt;/dir&gt;
      &lt;/namespace&gt;
    &lt;/library&gt;
  &lt;/api&gt;
&lt;/gapi-parser-input&gt;
</pre>
</p>
    <p>The makefile is to automate the process, it takes care of getting the source code,
	ex. from cvs, a ftp or a website. If there are any patches it applies those as well.
	It takes care of starting the parsing process. Finally it provides a clean up procedure.</p>
    <p>Content of makefile:
<pre class="code">
PACKAGE=foobar-1.0
 
all:
        ../parser/gapi-parser foobar-sharp-sources.xml
 
get-source-code:
        #wget http://foobar.sourceforge.net/sourceforge/foobar/$(PACKAGE).tar.gz \
        #--output-document=- | tar -xz;
 
        export CVS_PASSWORD=""
        cvs -z3 -d:pserver:anonymous@cvs.sf.net:/cvsroot/foobar co $(PACKAGE)
 
        patch $(PACKAGE)/src/foobar.h foobar.h.diff
 
distclean:
        rm -rf $(PACKAGE)
</pre>
</p>
    
	<h2>
      <a name="namespace" id="namespace">The namespace directory</a>
    </h2>
	<p>After parsing the library, the parser
	generates an xml file as the result. The file is placed in this directory.
	Also, it contains the C# source code which is created by the
	Gtk# C# code generator, and other source files and customizations.</p>
	<p>Typical files which lives here:
<pre>
foobar/
  |
  |---- foobar-api.xml
  |
  |---- foobar-symbols.xml
  |
  |---- Foobar.metadata
  |
  |---- .custom files
  |
  |---- generated/
  |
  \---- makefile
</pre>
</p>
	<p>The foobar-api.xml file is generated by the parser.</p>
	<p>The foobar-symbols.xml file is used to correct symbols in the -api.xml file.
	It can be a simple type like FoobarType which is just an int or it can be a manual
	type like FoobarEvent which is created manually in a .custom file.</p>
	<p>The contents of the -symbols.xml file:
<pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;api&gt;
  &lt;symbol type="manual" cname="FoobarEvent" name="Foobar.Event"/&gt;
  &lt;symbol type="simple" cname="FoobarType" name="int"/&gt;
&lt;/api&gt;
</pre>
</p>
	<p>The makefile is used to automate the process of generating the sources,
	compiling, and installing them.
	It contains the information of which .xml files should be processed and
	which .xml files they depend on. First, it updates the api file using the
	metadata rules.
	Then, it launches the C# code generator and makes a timestamp to satisfy the 
	way make works.</p>
	<p>
	It also lists the assemblies which the library depends on, it launches
	the compilation process, it installs the library and finally it can
	clean up the mess it made.</p>
<p>The contents of the makefile:
<pre class="code">
PREFIX=         /usr
 
API=            foobar-api.xml     \
                foobar-symbols.xml
 
INCLUDE_API=    $(PREFIX)/share/gapi/art-api.xml                \
                $(PREFIX)/share/gapi/pango-api.xml              \
                $(PREFIX)/share/gapi/atk-api.xml                \
                $(PREFIX)/share/gapi/gnome-api.xml              \
                $(PREFIX)/share/gapi/gtk-api.xml                \
                $(PREFIX)/share/gapi/gdk-api.xml                \
                $(PREFIX)/share/gapi/gdk-symbols.xml
                
ASSEMBLIES=     -r gtk-sharp.dll \
                -r glib-sharp.dll \
                -r gnome-sharp.dll \
                -r gdk-sharp.dll \
                -r pango-sharp.dll \
                -r art-sharp.dll
                
LIBRARY=        foobar-sharp.dll

all: $(LIBRARY)

$(LIBRARY): generated/*.cs generated-stamp
        mcs --unsafe --target library $(ASSEMBLIES) --recurse '*.cs' -o $(LIBRARY)
 
generated-stamp: $(API)
	gapi-fixup.exe --api=foobar-api.xml --metadata=Foobar.metadata &amp;&amp; \
	gapi_codegen.exe --include $(INCLUDE_API) --generate $(API) &amp;&amp; touch generated-stamp
	
install:
        install -o root -g root -m 644 $(LIBRARY) $(PREFIX)/lib
 
clean:
	rm -f generated-stamp
	rm -f $(LIBRARY)
	rm -rf generated
</pre>
</p>

	<p>A directory named generated is created by the code generator and populated with .cs files.
	Some of them start with FoobarSharp. to indicate that they are in the namespace FoobarSharp. It is
	a namespace which is created by the generator to be used for extra glue code, such as signal
	handling.</p><p> Sometimes it would be nice to add some extra methods to the generated code and luckily you
	can. The .custom files are used for this purpose.</p><p> A sample .custom file.
<pre class="code">
// Point.Custom - customizations
//
// Author: Foo Bar &lt;foo@bar.baz&gt;
//
// Copyright (C) 2003 Foo Bar
//
// This code is inserted after the automatically generated code.
 
public Point (double x, double y)
{
        this.x = x;
        this.y = y;
}
 
public override string ToString()
{
        return String.Format ("({0}, {1})", x, y);
}
</pre>
</p>

<p>Foobar.metadata is very interesting, since you will work with it a lot more than
	the other files
	Once the makefile and foobar-sharp-sources.xml file are made they will not be touched very
	often, but this file will be your friend through out your wrapping endeavor.</p>
    <p>The content is metadata, data about the data. It can be used to make customizations and corrections to api of the library.
	This is very handy when you find that method signatures, a type parent, a constructor etc.
	are not generated correctly, or you want to hide some private API.
	It is also used to turn the C API into a more .NET like API.</p>
    <p>The structure of a .metadata file:
<pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;metadata&gt;

&lt;!-- type hides --&gt;
&lt;!-- method signal and property hides --&gt;
&lt;!-- renames --&gt;
&lt;!-- disable default constructor --&gt;
&lt;!-- ref and out parameters --&gt;
&lt;!-- variable arguments --&gt;
&lt;!-- return value --&gt;
&lt;!-- constructor collision hints --&gt;
&lt;!-- overloads --&gt;

&lt;/metadata&gt;
</pre>
</p>
    <p>
        <h5>Type hides</h5>
	 Sometimes its needed to hide some of the API because its private or not needed, 
	 the following rule shows how it is done.
    </p>
<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarCanvas']" name="hidden"&gt;1&lt;/attr&gt;
</pre>
    <p>
	 But what exactly does this rule mean? Let us disect it.
	 <ul>
        <li>path: uses XPath to specify the node in the .metadata file.</li>
        <li>name: specifies the attribute of the node to modify</li>
     </ul>
	 In this case we target the class and wants it hidden.

	 This information will be present in the -api.xml file and the generator, 
	 will not generate code for this type.
	</p>
	
	<h5>Method hides</h5>
    <p>A method hide:
<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarConstraint']/method[@name='AddExpression']" name="hidden"&gt;1&lt;/attr&gt;
</pre>
</p>
    <p>Signal and property hides are similar to a method hide, 
	 just substitute method with either signal or property.
	</p>
	
    <h5>Renames</h5>
    <p>Renames are usually needed to prevent method, signal and property identifier collisions.</p>
    <p>A method rename:
<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarCanvas']/method[@name='SnapToGrid']" name="name"&gt;SnapToGridCoordinates&lt;/attr&gt;
</pre>
</p>
    <p>To rename a signal or a property substitute method with either signal or property.</p>
    
    <h5>Disabling of default constructor</h5>
    <p>If the generated default constructor is not good enough and you want to replace it with
	 a custom made constructor you will probably have to disable the first mentioned with a rule
	 like this: 

<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarCanvasLine']" name="disabledefaultconstructor"&gt;1&lt;/attr&gt;
</pre>
</p>

    <h5>Ref and out parameters</h5>
    <p>In C# you specify if a parameter to a method should be a ref, out or neither parameter,
	 but it is not so in C. Therefore this rule can be helpful.
<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarEditable']/method[@name='InsertText']" name="pass_as"&gt;ref&lt;/attr&gt;
</pre>
</p>
    <p>
	 To specify an out parameter, substitute ref with out.</p>
	 
    <h5>Variable arguments</h5>
    <p>Sometimes the actual parameters for a method is variable, like an array of values, in
	 such a case you can use this rule.

<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarTreeStore']/constructor[@cname='foobar_tree_store_newv']" name="va_type"&gt;length_param&lt;/attr&gt;
</pre>
</p>
    <h5>Return value</h5>
    <p>If the return value is wrongly generated fix it with this rule:
<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarFileSelection']/method[@name='GetSelections']/return-type" name="type"&gt;array&lt;/attr&gt;
</pre>
</p>
    <p>In this case the return type should be an array.</p>
    
    <h5>Constructor collision hints</h5>
    <p>This rule is used, when a type has some constructors, which will collide when turned into C# constructors, 
	 only one can be a real constructor the others must be methods. Which one should be selected is specified here.
    <pre class="code">
&lt;attr path="/namespace/class[@name='FoobarButton']/constructor[@name='foobar_button_new_with_mnemonic']" name="preferred"&gt;1&lt;/attr&gt;
</pre>
</p>

    <h5> Overloads </h5>
    <p>
	 No overloading exist in the C world, therefore this rule is used.

<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarBox']/method[@name='PackStartDefaults']" name="name"&gt;PackStart&lt;/attr&gt;
</pre>
</p>
    <p>This is a rename rule too, but a special one.</p>
    
    <h5>Missing parent</h5>
	 Sometimes a type is missing the base type it is inheriting from, its parent.<p>
	 Correct it with this rule.

<pre class="code">
&lt;attr path="/namespace/class[@name='FoobarProgressBar']" name="parent"&gt;FoobarWidget&lt;/attr&gt;
</pre>
</p>
	<h2>
      <a name="glue" id="glue">The glue directory</a>
    </h2><p>This directory is for so called glue code, C code which interfaces with the
	C# code in .custom files.</p><p>Typical files which lives here:
<pre>
glue/
  |
  |---- .c files
  |
  \---- makefile
</pre>
</p>
	<p>The C files could be creating objects in the C world which can not be generated in
	the mono world and passed down. They could also expose private fields.</p><p>An example C glue code file:
<pre class="code">
/* foobar-canvas.c : Glue for accessing fields in the FoobarCanvas class.
 *
 * Author: Foo Bar &lt;foo@bar.baz&gt;
 *
 * Copyright (C) 2003 Foo Bar
 *
 */
  
#include &lt;foobar/foobar-canvas.h&gt;
  
/* Forward declarations */
FoobarCanvasItem * foobarsharp_canvas_get_root (FoobarCanvas * canvas);
/* */
  
FoobarCanvasItem *
foobarsharp_canvas_get_root (FoobarCanvas * canvas)
{
        return canvas-&gt;root;
}
</pre>
</p>
	<p>The root field of the FoobarCanvas was not exposed as a GObject property and
	therefore could	not be accessed directly from C#.
	After the creation of this glue code a .custom file can be created which 
	P/Invokes FoobarCanvasItem * foobarsharp_canvas_get_root (FoobarCanvas * canvas);</p>
	<h2>
      <a name="doc" id="doc">The doc directory</a>
    </h2>
	<p>This directory contains the API documentation for the library, it makes use of the 
	MonoDoc tools.
	To be honest, it is not part of the wrapping process, but you will most
	likely want to implement this part too.</p><p>Layout of the doc directory.
<pre>
doc/
 |
 |---- foobar-docs.source
 |
 |---- foobar-docs.tree
 |
 |---- foobar-docs.zip
 |
 |---- en/
 |      |
 |      |---- Foobar
 |      |
 |      \---- FoobarSharp
 |
 |---- makefile
 |
 \---- tmp
</pre>
</p>
	<p>What is interesting here is the foobar-docs.source file and the makefile. The rest I
	generated with the MonoDoc tools.</p>
	<p>The foobar-docs.source file contains information about which provider should 
	be used to render the documentation, most likely it will be the ecma provider.
	But if you include some kind of html tutorial then take a look at the monohb provider,
	it might be useful to you.
	Then, it specifies the basefile, that way MonoDoc can find the files it need. Finally,
	a path is provided, which MonoDoc uses to place the documentation in the documentation 
	tree.</p>
	<p>An example -docs.source file.
<pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;monodoc&gt;
  &lt;source provider="ecma" basefile="foobar-docs" path="classlib-foobar"/&gt;
&lt;/monodoc&gt;	
</pre>
</p>
	<p>The makefile automates the generation of the documentation.
	First a couple of variables are set to the location of the assembler and updater tool.
	Generation of xml documentation stubs are provided in the update section, the result is
	put in the en directory and then split up acording to namespace.
	Then the -docs.zip and docs.tree are generated from the xml files in the en directory.
	Installation and clean up procedures are also provided.</p><p>An example makefile.
<pre class="code">
ASSEMBLER=../../monodoc/browser/assembler.exe
UPDATER=../../monodoc/generator/updater.exe
 
all: foobar-docs.zip foobar-docs.tree
 
foobar-docs.zip foobar-docs.tree: en/*/*.xml
        mono $(ASSEMBLER) --ecma en -o foobar-docs
 
install: foobar-docs.zip foobar-docs.tree
        install -m 644 foobar-docs.zip foobar-docs.tree `monodoc --get-sourcesdir`
        install -m 644 foobar-docs.source `monodoc --get-sourcesdir`
 
update:
        mono $(UPDATER) ../foobar/foobar-sharp.dll -o ./en -f
 
clean:
        rm -f *.tree
        rm -f *.zip
        rm -f tmp
        rm -f ..zip
</pre>
</p>
	<p>Now the only thing left, is to fill out the generated documentation framework. 
	By the way it is the hardest part ;)</p>
	<h2>
      <a name="conclusion" id="conclusion"></a>Conclusion</h2>
	<p>You have now learned a great deal about how you can make Gtk# work for you in the 
	wrapping effort. It's not that hard after all. If you experience some bugs, or are
	missing some .metadata rules, you are in luck. The tools are free software, 
	thus you can get the source code and fix the problem.</p>
	<p>In case you do not have the time or money, please report the problem to the 
	<a href="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">Gtk# mailinglist</a> 
	and the bugzilla <a href="http://bugzilla.ximian.com">bug database.</a></p>
	<h2>
      <a name="wrappers" id="wrappers"></a>Existing Wrappers</h2>
	For more inspiration take a look at these existing wrappers.

	<ul>
      <li>
        <a href="http://gtk-sharp.sourceforge.net/">
		Gtk#</a>Many wrappers of GNOME libraries</li>
      <li>
        <a href="http://www.go-mono.com/anoncvs.html">
		DiaCanvas#</a>Module diacanvas-sharp</li>
      <li>
        <a href="http://www.go-mono.com/anoncvs.html">
		GtkMozEmbed#</a>Module gtkmozembed-sharp</li>
      <li>
        <a href="http://www.go-mono.com/anoncvs.html">
		Vorbis#</a>Module csvorbis</li>
      <li>
        <a href="http://charon.ucam.org/~rjw57/pub_files/xine-sharp-0.1.tar.bz2">
		Xine#</a>
      </li>
      <li>
        <a href="http://amy.udd.htu.se/~malte/esd-sharp">
		Esd#</a>
      </li>
    </ul>
  </body>
</html>
