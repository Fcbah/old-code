<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>The Global Assembly Cache</title>
	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>

<body>
<h1>The Global Assembly Cache</h1>

  <p>
  <h2>Intro to the GAC</h2>
  </p>

  <p> 

    This section explains what the GAC is, how to use it, and when to
    use it.

  </p>
    
  <p>
    The Global Assembly Cache (GAC) is a central repository for
    storing shared assemblies.  The GAC allows multiple versions of the
    same assembly to be installed concurrently and also prevents
    different assembly vendors from overwriting each other's assemblies.
  </p>

  <p>
    The use of the GAC is encouraged for assemblies that will be used
    by more than one application on the system, and also for assemblies
    that are expected to be versioned in the future.  When an
    application is launched, Mono extracts the name of the assembly,
    the version and its public key token and loads the
    required assembly from the GAC.
  </p>

  <ul>
    <li><a href="#definitions">Definitions</a>:
    Terms commonly used when talking about the GAC</li>

    <li><a href="#shared_assembly_names">Assembly Names 101</a>:
    An introduction to the elements that make up an assembly name</li>
    
    <li><a href="#installing">Installing Assemblies to the
    GAC</a>: How to install shared assemblies into the GAC</li>

    <li><a href="#what_should_be_installed">What should be installed
    to the GAC</a>: Guidelines on which assemblies 
    should be installed into the GAC</li>

    <li><a href="#multiple">Multiple GACs:</a> How to setup and use
        multiple GACs.</li>

    <li><a href="#developers">Developing software:</a>
    How do developers cope with different versions of assemblies on the
    system. </li>
  </ul>

<a name="#definitions" />
<h2>Definitions</h2>

  <p>
    The GAC is built on the foundation of strongnames. Strongnames can be
    difficult to understand because they serve a dual purpose: 
    manageability and security. Hopefully these definitions can help
    everyone understanding the difference between the two.
  </p>

<a name="delay_signed_assembly" />
<h4>Delay Signed Assembly</h4>

  <p>
    An assembly that has a <a href="#strongname">strongname</a> but no
    <a href="#strongname_signature">strongname signature</a>. While they
    are a kind of <a href="#strongnamed_assembly">strongnamed assembly</a>
    the runtime will, by default, refuse to load them (as they are unsigned).
    They are often used in development to keep the private signing key 
    confidential.
  </p>

<a name="ecma_key" />
<h4>ECMA Key</h4>

  <p>
    The ECMA key isn't a public key (or a key at all). It is a special 16
    bytes header that the runtime detect in an assembly (where the assembly 
    public key should be). If found the runtime uses it's own public key to
    validate the <a href="#strongname_signature">strongname signature</a>.
    This hack allows an assembly to reference a <a href="#standard_assembly">
    standard assembly</a> (e.g. System.dll) in a uniform way (i.e. 
    independent of the runtime) without having ECMA (or anyone else) involved
    in the signing process.
  </p>

<a name="gac" />
<h4>GAC</h4>

  <p>
    The Global Assembly Cache. A black boxed repository of assemblies 
    capable of keeping multiple version/cultures of a same assembly. A
    <a href="#strongname">strongname</a> is considered a unique entry in 
    the GAC (i.e. the GAC requires all it's assemblies to be strongnamed
    and signed). Note that the GAC has nothing to do with security! In fact
    assemblies in the GAC aren't verified when loaded from the runtime.
    The GAC is for manageability (avoiding DLL hell).
  </p>

<a name="standard_assembly" />
<h4>Standard Assembly</h4>

  <p>
    Assemblies that are defined in the ECMA standards. They are signed 
    using the <a href="#ecma_key">ECMA key</a> (although other assemblies 
    are also signed with that <a href="#ecma_key">ECMA key</a>, like 
    System.Windows.Forms).
  </p>

<a name="strongname" />
<h4>Strongname</h4>

  <p>
    An assembly filename with a version number, a culture and a public key
    token. As a <a href="#strongname">strongname</a> uniquely identifies 
    an assembly this is the best way to reference them.
  </p>

<a name="strongname_signature" />
<h4>Strongname Signature</h4>

  <p>
    A binary blob inside an assembly that can be verified as the digital
    signature of the assembly (i.e. providing integrity). Because the the
    public key (inside the assembly) is part of the signature it is not 
    possible to modify the assembly contents without detection (providing 
    integrity).
  </p>

<a name="strongnamed_assembly" />
<h4>Strongnamed Assembly</h4>

  <p>
    An assembly that has a all the required informations to create a <a 
    href="#strongname">strongname</a> (i.e. a public key). Note that this
    doesn't mean that the assembly is signed! (see <a 
    href="#delay_signed_assembly">delay signed assemblies</a>).
  </p>

<a name="snk" />
<h4>SNK</h4>

  <p>
    Strongname Key (file extension). These are files created by the tool
    sn.exe, it can contains a 1024 bits RSA key pair (private and public
    keys) or only the public key.
  </p>

<a name="#shared_assembly_names" />
<h2>Assembly Names 101</h2>

  <p>
    The Mono Runtime uses the following components to make up unique
    names for the assemblies: The
    <a href="#assembly_name">assembly name</a>, the <a
    href="#assembly_culture">assembly culture</a>, the <a
    href="#assembly_version">assembly version</a>, and the <a
    href="#assembly_token">assembly public key token</a>.
  </p>

  <p>
    All of those elements are used to make a unique assembly name that
    can be referenced from the GAC.
  </p>



<a name="assembly_name" />
<h4>Assembly Names</h4>
  <p>
    The assembly name is the human readable name you give your assembly,
    and is also the physical name of the assembly minus the extension. You
    don't need to do anything special to create an assembly name. Its added
    to the assemblies metadata when the assembly is compiled.
  </p>


<a name="assembly_culture" />
<h4>Assembly Culture</h4>
  <p>
    All assemblies have a culture associated with them. If you do not
    specify a culture the invariant (neutral) culture is associated with your
    assembly. By giving an assembly a culture you can create localized
    versions of assemblies and install them side-by-side in the GAC
    without them interfering with each other. The assembly culture is
    specified using an assembly attribute:
  </p>
<pre class="code">
  [assembly: AssemblyCulture ("en-CA")]
</pre>



<a name="assembly_version" />
<h4>Assembly Version</h4>
  <p>
    The assembly version is specified as a four part number. The parts
    are: <br />
    &lt;Major&gt;.&lt;Minor&gt;.&lt;Build&gt;.&lt;Revision&gt;
  </p>
  <p>
    The assembly version is specified using an assembly attribute:
  </p>
<pre class="code">
[assembly: AssemblyVersion ("1.3.3.7")]
</pre>

  <p>
    Common practice is to update the major and minor version numbers for
    changes that break backwards compatibility. 
  </p>
  <p>
    If you don't want to specify a build and revision number you can use a
    wild card and the compiler will automatically generate one for you:
  </p>
<pre class="code">
[assembly: AssemblyVersion ("1.0.*")]
</pre>




<a name="assembly_token" />
<h4>Assembly Public Key Token</h4>
  <p>
    The assembly public key token is a short representation of the public
    key compiled in the assembly. The token value is the first 8 bytes of
    the SHA-1 hash of public key. Having a public key inside the assembly
    allows, once the assembly is signed, to verify it's integrity. It
    also ensures that there will be no naming conflicts with shared
    assembly names. To generate a key pair we use the sn.exe tool:
  </p>
<pre class="console">
$ sn -k my.key
Mono StrongName 0.30.99.0
Copyright 2002, 2003 Motus Technologies. Copyright 2004 Novell. BSD licensed.
 
A new strong name key pair has been generated in my.key
</pre>

  <p>
    Once the key pair is generated we must then reference that key
    from inside of our assembly using an assembly attribute:
  </p>
<pre class="code">
[assembly: AssemblyKeyFile ("my.key")]
</pre>



<a name="installing" />
<h2>Installing Assemblies to The GAC</h2>
  <p>
    Once you have given an assembly a proper shared name with a version
    and public key it can be installed into the GAC. Not all assemblies
    should be installed to the GAC. See the <a
    href="#what_should_be_installed">what should be installed to the
    GAC</a> section to help you decide whether your assembly should be
    installed into the GAC.
  </p>
  <p>
    To install an assembly to the GAC we use the gacutil tool. Gacutil can
    be used to install assemblies, uninstall assemblies, and list the
    assemblies in the GAC. Here is a sample installation:
  </p>
    
<pre class="console">
$ gacutil -i gac_lib.dll
gac_lib installed into the gac (/usr/lib/mono/gac)
</pre>
    
  <p>
    The -i directive tells gacutil to install the assembly. If we want to
    see what assemblies we have installed in our GAC we can use the /l directive:
  </p>
    
<pre class="console">
$ gacutil -l
The following assemblies are installed into the GAC:
        Accessibility, Version=1.0.5000.0, Culture=neutral,
PublicKeyToken=b03f5f7f11d50a3a
        Accessibility, Version=2.0.3600.0, Culture=neutral,
PublicKeyToken=b03f5f7f11d50a3a
....
        gac_lib, Version=1.2.3.4, Culture=neutral, PublicKeyToken=29fba40140d13a14
        gac_lib, Version=1.2.3.4, Culture=en-US, PublicKeyToken=29fba40140d13a14
</pre>
    
  <p>
    At the top of the list you can see that there are two versions of the
    Accessibility assembly installed. One for version 1.0.5000.0 and one
    for version 2.0.3600.0.
  </p>
    
  <p>
    At the bottom of the list you can see there are two versions of
    gac_lib installed. One for the neutral, or invariant culture, and one
    for the en-US culture.
  </p>

  <p>
    If you want to expose the assembly for developers, you should use
    the -package NAME option to gacutil:
  </p>

<pre class="console">
$ gacutil -i gac_lib.dll -package DEMO
gac_lib installed into the gac (/usr/lib/mono/gac)
</pre>

  <p>
    The above will surface the assembly on /usr/lib/mono/DEMO, which is
    a convenient location to pass to the compiler as a assembly
    directory: 
  </p>

<pre class="console">
$ mcs -lib:/usr/lib/mono/DEMO sample.cs
Compilation succeeded
$ 
</pre>

<a name="multiple" />
<h2>Using multiple GACs</h2>

  <p>
    The Mono runtime allows you to reference multiple GACs and the
    Mono gacutil will allow you to create GACs in multiple
    locations. These features are useful during development and for
    certain deployment scenarios.
  </p>

  <p>
    The default GAC is located in &lt;prefix&gt;/lib/mono/gac. To install
    your libraries to another location you use the -gacdir option with the
    Mono gacutil. -gacdir is a Mono only gacutil feature and will not work
    with other gacutil implementations. To use -gacdir you simply specify
    a location you would like your gac installed to. If there is currently
    no GAC directory structure at that location a new one will be created:
  </p>

  <p>
<pre class="console">
$ gacutil /i gac_lib.dll -gacdir ~/.mono
gac_lib installed into the gac (/home/monkey/.mono/lib/mono/gac)
$ ls ~/.mono/lib/mono/gac/gac_lib/1.2.3.4_en-us_29fba40140d13a14/gac_lib.dll
</pre>
  </p>

  <p>
    mono/gac is always appended to the path that is supplied to
    -gacdir. lib will be appended if the supplied path does not end with a
    lib directory. The reason for this is to ease package creation.
  </p>

  <p>
    To reference this new GAC the MONO_GAC_PREFIX environment variable
    is used. MONO_GAC_PREFIX points to the prefix directory of an install
    or the directory supplied to -gacdir. The runtime will append the
    lib/mono/gac and search for the assembly in that directory. The
    following source code loads gac_lib.dll and prints out the assemblies
    codebase so we can see where it was loaded from:
   </p>

<pre class="code">
public class GacExe {
        public static void Main ()
        {
                GacLib g = new GacLib ();
                System.Console.WriteLine (g.GetType ().Assembly.CodeBase);
        }
}
</pre>

   <p>
     The first time this code is run the gac_lib.dll will be loaded
from the current directory because there is no gac_lib.dll found in
the default GAC:
   </p>

<pre class="console">
$ mono gac_exe.exe
file:///home/monkey/projects/mono/tests/gac_lib.dll
</pre>

   <p>
     If the MONO_GAC_PREFIX is set to the gacdir that gac_lib.dll was installed to
earlier the library will be loaded from the new GAC:
   </p>

<pre class="console">
$ export MONO_GAC_PREFIX=~/.mono
$ mono gac_exe.exe
file:///home/monkey/.mono/lib/mono/gac/gac_lib/1.2.3.4_en-us_29fba40140d13a14/ga
c_lib.dll
</pre>

<a name="developers"/>
<h2>Developing software</h2>

  <p>
    So having multiple versions of the same assembly is useful to the
    user: he does not have to worry about conflicting assembly filenames
    and he can have multiple versions of the same assembly installed
    at once without breaking his existing software when he updates
    software. 
  </p>

  <p>
    But how do developers cope with having multiple assemblies, and how
    does the compiler choose the right version of a assembly to link
    with?
  </p>

  <p>
    The compiler will automatically load assemblies that are located in
    the same directory as the compiler (by default /usr/lib/mono/1.0)
    and these include all the assemblies that are part of the standard
    Mono.  But for third party assemblies, it is necessary to indicate
    a directory that holds the assembly to link against.
  </p>

  <p>
    In the GAC world, the assemblies are exposed in two places: in the
    GAC (which is what the runtime uses to load assemblies) and to the
    compiler in a different location, this is done with the <tt>-package</tt>
    flag to the <tt>gacutil</tt> command.
  </p>

  <p> What the <tt>-package</tt> option does is to expose the assembly
    in a different location for the compiler to pick up (by default
    the assembly is only exposed in a cryptic location, for example::
    /usr/lib/mono/gac/monodoc/1.0.0.0__0738eb9f132ed756/monodoc.dll)
    which is not very practical to type.   The <tt>-package NAME</tt>
    option will surface the assembly (using a symbolic link) in
    /usr/lib/mono/NAME directory, which is a convenient assembly to
    pass to the compiler. 
  </p>

  <p>
    To further integrate into the Unix build process, we go one step
    beyond, and we encourage developers to not only install their
    assembly into the GAC and surface it for developers with the
    <tt>-package</tt> option, but to also ship a <tt>pkg-config</tt>
    configuration file.  The pkg-config configuration file has all the
    information required to build against a assembly.
  </p>

  <p> This can be used in conjunction with the compiler flag
    <tt>-pkg:</tt> to directly reference a software package, for
    example to compile with Gtk# and Pango#, this is the command line
    used:
  </p>

<pre class="console">
$ mcs -pkg:gtk-sharp,pango-sharp sample.cs
Compilation succeeded
$ 
</pre>

  <p>
    The above is convenient for developers as they do not have to
    remember the paths, or probe for the paths, they can just use
    pkg-config to probe on their configuration scripts for the
    presence and a specific version if they need to.
  </p>

  <p>
    The gtk-sharp.pc file is a file that is installed into
    /usr/lib/pkgconfig directory (on most systems) or on any directory
    references by the PKG_CONFIG_PATH.  This allows a developer to
    have multiple development versions installed at once, and have the
    compiler pick the right version based on the .pc file
  </p>

  <p>
    Here is what the gtk-sharp.pc file looks like:
  </p>

<pre class="code">
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib


Name: Gtk#
Description: Gtk# - GNOME .NET Binding
Version: 0.91.99
Libs: -r:${libdir}/mono/gtk-sharp/glib-sharp.dll     \
	-r:${libdir}/mono/gtk-sharp/pango-sharp.dll  \
	-r:${libdir}/mono/gtk-sharp/atk-sharp.dll    \
	-r:${libdir}/mono/gtk-sharp/gdk-sharp.dll    \
	-r:${libdir}/mono/gtk-sharp/gtk-sharp.dll
</pre>
 
  <p>
    Notice that the assemblies are referenced directly instead of
    passing the -lib: command line and then the -r option separately:
    This helps specifying exactly what assembly must be linked with.
  </p>


<a name="what_should_be_installed" />
<h2>What should be installed to the GAC</h2>
    
  <p>
    Not all assemblies should be installed to the GAC. In fact apart from
    system assemblies very few assemblies should be installed to the
    GAC. Here are the criteria an assembly should meet to be installed
    into the GAC:
  </p>

<ul>
  <li><b>Useful to more then one application</b> - There is no point
      to sharing a assembly if only one application is going to use
      it. If a assembly is only used by one application or is very
      tightly coupled to an application side-by-side deployment is a
      better solution then the GAC</li>
  <li><b>Only loads assemblies that are in the GAC</b> - If your
      assembly loads or references assemblies that are not in the GAC
      it should not be installed to the GAC.</li>
</ul>
  
</body>
</html>

