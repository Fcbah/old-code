<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Writing XML documents with XmlWriter</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Atsushi Enomoto" />

	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>

<h1>Writing XML documents with XmlWriter</h1>

<h2>Contents</h2>

<ol>
	<li><a href="#intro">Introduction</a></li>
	<li><a href="#methods">Writer methods</a>
	<ol>
		<li><a href="#writeelement">Writing elements</a></li>
		<li><a href="#writeattribute">Writing attributes</a></li>
		<li><a href="#writetext">Writing content string</a></li>
		<li><a href="#writenode">Writing nodes directly</a></li>
		<li><a href="#close">Don't forget to close</a></li>
	</ol>
	</li>
	<li><a href="#tips">XmlWriter tips</a>
	<ol>
		<li><a href="#indent">Indentation</a></li>
		<li><a href="#namespace">Namespace handling</a></li>
		<li><a href="#encoding">Writing arbitrary encoding</a></li>
		<li><a href="#multiple-element">How to allow multiple top-level element content</a></li>
	</ol>
	</li>
</ol>

<h2><a name="intro">1. Introduction</a></h2>

<p>XmlTextWriter API is used to write XML document to TextWriter, Stream 
or text file. There is an abstract XmlWriter class, but possibly you won't
ave to make any difference between XmlTextWriter and XmlWriter. There is
no other XmlWriter class in System.Xml namespace. If you are interested 
in another implementation, we have XmlNodeWriter in monodoc module.</p>

<p>XmlWriter is used widely in several XML classes.</p>

<h2><a name="methods">2. Writer methods</a></h2>

<p>Unlike XmlReader, you will use only writer methods.</p>

<h3><a name="writeelement">2.1. Writing elements</a></h3>

<p>WriteStartElement() writes element start tag. After calling it, write
contents subsequently. Finally WriteEndElement() call is required; it 
writes element end tag.</p>

<p>If you simply want to write only start tag, single content string and 
end tag, you can use WriteElementString().</p>

<p>When the element is empty, WriteEndElement() writes self-closing empty
tag such like &lt;empty />. If you want to write full end tag, you can use
WriteFullEndElement() and it writes &lt;empty>&lt;/empty>.</p>


<h3><a name="writeattribute">2.2. Writing attributes</a></h3>

<p>If you want to write attributes inside the start tag, you can
use WriteAttributeString() or WriteStartAttribute() after
WriteStartElement().</p>

<p>When you called WriteStartAttribute(), write
contents, and call WriteEndAttribute() to close attribute. Otherwise, you cannot write any content string anymore. The writer regards those method arguments as attribute value.</p>


<h3><a name="writetext">2.3. Writing content string</a></h3>

<p>WriteString() writes content string. If you want to write CDATA section,
you can use WriteCData() instead. But note that WriteCData() throws an error
when the argument string contains "\]\]\>", while WriteString() always escapes 
it.</p>

<p>If you want to write an entity reference inside string, you can use
WriteEntityRef().</p>

<p>There are some useful methods:</p>

<ul>
	<li>WriteName() writes name string. It raises an error if the
	argument is not a valid name. WriteNmToken() is similar (checks
	if the argument is a valid NMTOKEN).</li>

	<li>WriteChars() writes character array to the output. Usually you
	can do it by creating new string instance, but if you don't lose
	any performance for creating extraneous objects, it is 
	convenient.</li>

	<li>WriteQualifiedName() receives an XmlQualifiedName object and
	writes prefixed name to the output, where the prefix is mapped to
	the namespace which the argument indicates.</li>
</ul>

<p>(How are namespaces mapped to prefixes? It is done when you called
WriteStartElement() or WriteStartAttribute() with certain prefix and
namespace URI, or when used WriteStartAttribute() to write xmlns 
attributes.)</p>


<h3><a name="writenode">2.4. Writing nodes directly</a></h3>

<p>If you want to save node to XmlWriter, there are some ways to do:</p>

<ul>
	<li>As for XmlNode instances, you can use WriteTo() method of the 
	target node object, which takes an XmlWriter attribute.</li>
	<li>As for XmlReader instances, you can use WriteNode() method of
	the XmlWriter. You can also take this way for XmlNodes, by creating
	XmlNodeReader. </li>
</ul>

<p>(As for XPathNavigator, there is no standard way, but you can try my<a
href="http://www24.brinkster.com/ginga/XPathDocumentReader.cs.txt">XPathDocumentNavigator</a>.
Note that it is an experimental implementation and not ready to stable 
use.</p>


<h3><a name="close">2.5. Don't forget to close</a></h3>

<p>When you finished all writing jobs, maybe you have to call Close() to 
close the text writer.</p>



<h2><a name="tips">3. XmlWriter Tips</a></h2>

<p>Firstly, is should be warned that since there is no other public implementation than XmlTextWriter, we cannot distinguish if the behavior is XmlTextWriter specific, or common to XmlWriter interface (for example, what if we call WriteStartAttribute() with the same names? XmlTextWriter simply emits not well-formed XML).</p>


<h3><a name="indent">3.1. Indentation</a></h3>

<p>To specify indentation, you can set three properties:</p>

<ul>
	<li>Formatting property is an enumeration that specifies if the writer should indent or not. By default it never does indentation, so set Formatting = Formatting.Indented if you want to do.</li>
	<li>IndentChar property is used to get or set the character which is used to indent.</li>
	<li>Indentation property is used to get or set the amount of the indentation characters per one level depth.</li>
</ul>


<h3><a name="namespace">3.2. Namespace handling</a></h3>

<p>Since some WriteStartElement() and WriteStartAttribute() overrides accept namespace URI, it stores in-scope namespaces internally (you can use LookupPrefix() to check if a namespace is bound to any prefixes). When WriteStartElement() is called with namespace URI, this XmlTextWriter stores the URI as in-effect namespace URI.</p>

<p>However, when you call WriteStartAttribute() (or WriteAttributeString() as well) with the same prefix and different namespace, it causes inconsistent result. The writer emits the attribute's namespace URI, while it internally treats the element's namespace as in-effect (so it will result in inconsistent namespace output for the element's contents, and inconsistent return value for LookupPrefix() ). It should be strongly avoided.</p>

<p>To make it worse, when you use these WriteStartElement() method with null namespace (or omitting namespace URI argument), it <strong>does not</strong> mean that the element belongs to the default namespace. When you use WriteStartElement() with String.Empty namespace, it <strong>does</strong> mean that the element belongs to the default namespace. This fact brings the result that WriteStartElement() with String.Empty also emits <code>xmlns=""</code> (default namespace removal), white WriteStartElement() with null never emits that.</p>

<p>Finally, you can write the element's namespace attribute at your favorite timing. When the same name attribute is already written, xmlns will be never written. When the writer is going to write the element's content or the end of the element, it writes the missing xmlns attribute (if any).</p>


<h3><a name="encoding">3.3. Specify arbitrary encoding declaration</a></h3>

<p>Since WriteStartDocument() only takes boolean "standalone" argument, there is no way to specify the nominal encoding. Encoding declaration is automatically set by the actual Encoding of the input TextReader, or never specified when you use Stream to create the XmlTextWriter instance. For example, you cannot specify arbitrary encoding when you use StringWriter (it returns UnicodeEncoding as its Encoding property) and call WriteStartDocument().</p>

<p>In that case, you can use WriteProcessingInstruction() like this:</p>

<p class="code"><code>writer.WriteProcessingInstruction ("xml", "version='1.0' encoding='shift_jis'");</code></p>

<p>Since the name "xml" is prohibited for XML processing instruction, such
method invokation should raise an error, but in fact XmlTextWriter actually
passes this. And in fact, such way is used in some places such as WriteNode()
(to copy the corresponding XmlDeclaration node) and XSLT outputter (to
apply "encoding" attribute in "xsl:output" element).</p>

<p>(So this behavior should be documented clearly, otherwise another XmlWriter
implementors might implement WriteProcessingInstruction() to reject PI nodes
<strong>conformantly</strong>.</p>


<h3><a name="multiple-element">3.4. How to allow multiple top-level element content</a></h3>

<p>XML document entity must have exactly one element. However, sometimes we need to write more than one elements as output. In fact this "document element" check only works when you call WriteStartDocument(). So if you don't want to reject such XML, simply do not call that method.</p>

<p>But also wanted to write XML declaration (for example, write exteernal entity)? Then WriteProcessingInstruction() solution also applies here.</p>


</body>
</html>
