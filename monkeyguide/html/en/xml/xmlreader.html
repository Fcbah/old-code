<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Reading XML documents with XmlReader</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Atsushi Enomoto" />

	<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>

<h1>Reading XML documents with XmlReader</h1>

<h2>Contents</h2>

<ol>
	<li><a href="#intro">Introduction</a></li>
	<li><a href="#outline">Reader classes outline</a>
	<ol>
		<li><a href="#xmltextreader">XmlTextReader</a></li>
		<li><a href="#xmlnodereader">XmlNodeReader</a></li>
		<li><a href="#xmlvalidatingreader">XmlValidatingReader</a></li>
		<li><a href="#abstract-xmlreader">XmlReader: as a common XML Reading API</a></li>
	</ol>
	</li>
	<li><a href="#howtouse">How to use XmlReader</a>
	<ol>
		<li><a href="#properties">Node information properties</a></li>
		<li><a href="#methods">Reader methods</a></li>
		<li><a href="#attributes">Attribute handling</a></li>
		<li><a href="#api-notes">Important note</a></li>
	</ol>
	</li>
	<li><a href="#tips">XML Reader Tips</a>
	<ol>
		<li><a href="#namespaces-false">Parsing documents without namespace</a></li>
		<li><a href="#ctor">Consructors</a></li>
		<li><a href="#dtd">XmlReader and DTD</a></li>
	</ol>
	</li>
</ol>

<h2><a name="intro">1. Introduction</a></h2>

<p>Here I start XML guide from "XML Reader" interface. It is used to read
XML and to provide XML information set. And then? It depends on you what 
can be done.</p>

<p>If you merely want to look into document structure easily, this
"XML reader" won't be convenient. You can use XmlDocument or
XPathNavigator. They are much easier to use. XmlReader is used widely
as an XML input, so you will have to create these instances, but you
won't have to "use" it unless you need good performance related
to XML processing. XmlReader leaves behind almost all information what
it has read, so it is suitable if you would like to handle huge XML 
documents.</p>

<p>Well, to understand why I don't recommend it for easy usage, let's 
dive into some live code. Here is an example case that gets the latest
RSS entry from Mono Website. (Note that the code might not in sync with 
the latest web site.)</p>

<pre class="code">
XmlTextReader reader = new XmlTextReader ("http://www.go-mono.com/index.rss");
reader.Read ();
Console.WriteLine (reader.NodeType); // It prints "XmlDeclaration"

reader.MoveToContent ();
Console.WriteLine (reader.NodeType); // It prints "Element"
Console.WriteLine (reader.Name); // "rss"
Console.WriteLine (reader.GetAttribute ("version")); // Maybe "0.92"

// proceed content until we reach "item" element
while (!reader.EOF &amp;&amp; reader.Name != "item")
	reader.Read ();

reader.Read (); // Move from "item" to "title"
while (reader.NodeType == XmlNodeType.Whitespace)
	reader.Read ();
Console.WriteLine ("Title : " + reader.ReadString ());

reader.Read (); // from "&lt;/title>" to whitespace
reader.Read (); // from whitespace to &lt;link>
Console.WriteLine ("Link  : " + reader.ReadString ());

reader.Read (); // from "&lt;/link>" to whitespace
reader.Read (); // from whitespace to &lt;pubDate>
Console.WriteLine ("Date  : " + reader.ReadString ());

reader.Read (); // from "&lt;/pubDate>" to whitespace
reader.Read (); // from whitespace to &lt;description>
Console.WriteLine ("Description : " + reader.ReadString ());
</pre>

<p>Such long?? Should I really write such long code for that simple task??
No, you don't have to write such long code if you simply want to get
the summary without any resouce constraints. Use XmlDocument or 
XPathNavigator. And yes - if you want to use XmlReader.</p>

<p>(Well, this code is only an example and in fact it is bad code, so don't
mimick it. You should not rely on whitespaces existence.)</p>



<h2><a name="outline">2. XML Reader classes outline</a></h2>

<h3><a name="xmltextreader">2.1. XmlTextReader</a></h3>

<p>XML is tagged text markup language. You can write your custom text 
parser to read the content, but there is much more easy way to parse XML.
You can use XmlTextReader to parse XML text data.</p>

<p>Possible you can understand what XmlTextReader is, if you know some 
keywords I list here: SAX, XMLPull and StAX. XmlTextReader is kind of 
"pull parser."</p>

<p>It is constructed with a file name or URI string, a Stream or a 
TextReader. When we haven't ever met any errors yet, it holds "current 
node." You can get node information from several properties such as 
Name, Prefix, NamespaceURI and Value. When you call Read() method, it 
proceeds current node to the next node.</p>


<h3><a name="xmlnodereader">2.2. XmlNodeReader</a></h3>

<p>You don't have to "read" XML documents from its text representation. 
It is natural that once we parsed an XML document into the document 
object (XmlDocument), we don't have to parse the same XML infoset again. 
If you want to do the similar procedure what you have done on parsing 
documents, you can use XmlNodeReader. It is created with an XmlNode, 
and you can get Name, Prefix, NamespaceURI and Value the same as 
XmlTextReader (of course, they are already available by each node's 
properties).</p>


<h3><a name="xmlvalidatingreader">2.3. XmlValidatingReader</a></h3>

<p>Mono and Microsoft.NET supports some XML "validation" feature. Mono 
supports DTD, XML Schema and RELAX NG as validation languages. Microsoft.NET
supports DTD, XML Schema and XDR (XML Data Reduced). As for DTD and 
XML Schema (and XDR in Microsoft.NET), the validation feature is 
implemented in XmlValidatingReader. If you want to validate with RELAX NG
grammar, find about RelaxngValidatingReader.</p>


<h3><a name="abstract-xmlreader">2.4. XmlReader: as a common XML Reading API</a></h3>

<p>Since these classes are very common at infoset properties and reading
methods, they have common base class named XmlReader. Once you mastered
XmlTextReader, you will be able to use XmlNodeReader and 
XmlValidatingReader.</p>



<h2><a name="howtouse">3. How to use XmlReader</a></h2>

<h3><a name="reader-properties">3.1. Node information properties</a></h3>

<p>This chapter contains how to use XmlReader. Firstly this section starts from its node infoset properties (somewhat boring, but it needs to be described in prior).</p>

<p>These properties are available for current node:</p>

<ul>
	<li>Name: markup name (e.g. "xsl:template")</li>
	<li>LocalName: local part of the name (e.g. "template")</li>
	<li>Prefix: namespace prefix ("xsl")</li>
	<li>NamespaceURI: namespace URI declared in the document ("http://www.w3.org/1999/XSL/Transform")</li>
	<li>NodeType: one of the enumerated node kind. It is described immediate below.</li>
</ul>

<p>Note that they are somewhat different from the W3C DOM API. For example,
 we never return "#document" for the Value of a document node.</p>

<p>Since CLR supports enum types, so node type is represented as an enum 
type, not likely W3C Document Object Model represents as int. The type 
name is XmlNodeType. (Note that there is another XML node type named
XPathNodeType.)</p>

<p>The enumerated values are:</p>

<ul>
	<li>None</li>
	<li>Element</li>
	<li>Attribute</li>
	<li>Text</li>
	<li>CDATA</li>
	<li>EntityReference</li>
	<li>Entity (document type declaration content)</li>
	<li>ProcessingInstruction</li>
	<li>Comment</li>
	<li>Document</li>
	<li>DocumentType</li>
	<li>DocumentFragment</li>
	<li>Notation</li>
	<li>Whitespace</li>
	<li>SignificantWhitespace</li>
	<li>EndElement</li>
	<li>XmlDeclaration</li>
</ul>

<p>(Looks curious? Yes, it is not compatible with W3C DOM - it does not 
contain XmlDeclaration, Whitespace nor SignificantWhitespace. And also, 
it is not "Infoset" - XML Infoset is not aware of difference between Text 
and CDATA section.)</p>


<h3><a name="reader-methods">3.2. Reader methods</a></h3>

<p>Read() moves to the next node. Here the "next node" means:</p>
<ol>
<li>If there are one or more child nodes, then moves to the first child.</li>
<li>Otherwise when it just reached the end of the element, then it moves 
to the EndElement.</li>
<li>Otherwise if there are one or more next sibling nodes, then moves to 
the first child.</li>
<li>Otherwise it does not proceed.</li>
</ol>

<p>Note that attribute nodes are not children of the owner element node, 
so it never moves to attributes by Read(). If the reader is on attributes, 
then firstly it moves to the owner element and then moves to the next 
node above. As for attributes, it is described later.</p>

<p>If the reader is on the Element, or on the text content, ReadString() 
reads its content up and return it as a string value (on the other kind 
of node, it does nothing). It proceeds the reader to the matching 
EndElement.</p>

<p>ReadInnerXml() returns the markup string which represents the current 
node's content. ReadOuterXml() returns the markup string which represents 
the current node and its content.</p>

<p>MoveToContent() is a shortcut method to reach Element, Text, CDATA, or
 EndElement. Skip() skips to the next node of the current node.</p>


<h3><a name="attributes">3.3. Attribute handling</a></h3>

<p>We left attributes behind in the previous chapter. This section 
describes how attributes are handled.</p>

<p>Before starting introducing several methods, we have to describe how
attributes are structured. An element node contains zero ore more 
attribute nodes. an attribute node contains one or more attribute
value.</p>

<p>To access attributes, there are two ways in general:</p>

<ol>
	<li>Get attribute value string from the owner element.</li>
	<li>Navigate to an attribute node and use properties on the 
	reader, and read attribute value string by attribue value token.</li>
</ol>

<p>For the first kind, it simply handles attributes as containing one 
string value. The second kind accesses attributes more in depth.</p>

<p>More concretely, there are four ways to access attributes:</p>

<ul>
	<li>Use GetAttribute() to get attribute value string from the 
	owner element.</li>
	<li>Use indexer for XmlReader. It returns the same as 
	GetAttribute()</li>
	<li>Use MoveToFirstAttribute() or MoveToNextAttribute() to 
	navigate attributes in order</li>
	<li>Use MoveToAttribute() to navigate directly to the specified 
	attribute.</li>
</ul>

<p>
As to MoveToXXX() methods, they can get several properties from XmlReader 
itself, and it can read each attribute value node with ReadAttributeValue()
method.</p>

<p>Only Text, and EntityReference are possible to be a value node of 
an attribute. Inside attributes, Whitespaces are merely treated as Text. 
Even an empty string is also treated as it contains a Text node.</p>

<p>GetAttribute(), indexer and MoveToAttribute() take three types of 
arguments.</p>

<ol>
	<li>int index to specify ordered attribute items. (Yes, attributes 
	are "unordered" in XML Infoset Recommendation, but XmlReader has 
	its mandatory "order" between attributes.)</li>
	<li>string name to specify attribute by its markup.</li>
	<li>string local-name and namespace-URI to specify local part of 
	the name and mapped namespace URI.</li>
</ol>

<p>When the specified attribute was not found, then GetAttribute() and 
indexer returns null, and MoveToXXX() returns false (they return a 
boolean value).</p>


<h3><a name="api-notes">3.4. Important Note</a></h3>

<p>After using the reader, you have to call Close(). Especially, when you
created XmlTextReader and XmlValidatingReader, don't forget doing 
this.</p>


<h2><a name="tips">4. XML Reader Tips</a></h2>

<h3><a name="namespaces-false">4.1. Parsing documents without namespace</a></h3>

<p>Sometimes (mainly for legacy documents), you might want to parse XML
documents without correct namespaces. In such case, you can specify 
Namespaces = false on XmlTextReader.</p>


<h3><a name="ctor">4.2. Constructors</a></h3>

<p>There are many constructor overroads for XmlTextReader. As for entire
XML document, it can be created from string URI, Stream or TextReader,
with optional XmlNameTable and optional BaseURI (it is mainly useful
with Steam or TextReader).</p>

<p>Alternatively, it can be created from XML document string, with NodeType
and XmlParserContext arguments. XmlTextReader can be used to parse XML
fragments. This constructor is easy way to create XmlTextReader. And it 
is also used internally for DOM value setters.</p>


<h3><a name="dtd">4.3. XmlReader and DTD</a></h3>

<p>DTD (Document Type Definition) is used to constrain xml structure. 
It is not namespace-aware so it is not so recommended way to use it, 
but it is very commonly-used (since SGML, one of the ancestor of XML,
have required it by design).</p>

<p>You might not know, but DTD does not only affect to "validity", but 
also to "well-formedness", so XmlTextReader which only supports well 
formedness check also consumes DTD.</p>

<p>If you don't want to read external DTD resources which might affect 
to the parser performance, you can set XmlResolver = null.</p>

<p>If you don't want to be reported any validation errors, you can specify
ValidationEventHandler to XmlValidatingReader. When you set the handler, it
will never throw more validation errors unless you re-throw that error in
your delegated method. Note that you cannot recover from any well-formedness
errors.</p>


<!--
<h3><a name="known-bugs">4.4. Known bugs</a></h3>

<p>This is known MS bugs.</p>

<p>Don't use MoveToXxxAttribute() on XmlDeclaration. It leads to inconsistent
results. For example, XmlNodeReader never moves to version, encoding nor
standalone values, while XmlTextReder and XmlValidatingReader does.</p>
-->


</body>
</html>
