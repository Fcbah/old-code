<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Embedding the Mono runtime, preliminary version</title>

	<meta name ="DC.Description" content ="Monos Database Framework" />
	<meta name ="DC.Contributor" content ="Paolo Molaro" />
	<meta name ="DC.Contributor" content ="Miguel de Icaza " />

	<link rel="stylesheet" type="text/css" href="../style.css" />

	<meta name = "CVS.English.Version" content = "1.11" />
</head>
<body>

<h2>Contents</h2>

<ul>
	<li><a href="#helloworld">Introduction</a></li>
	<li><a href="#helloworld">Embedding the runtime</a></li>
	<li><a href="#helloworld"> Exposing C code to the CIL
	universe</a></li>
	<li><a href="#helloworld">Invoking Methods in the CIL
	universe</a></li>
	<li><a href="#helloworld">Invoking a Method</a></li>
	<li><a href="#helloworld">Samples</a></li></ul>

<h2> Introduction</h2>
<p>This document describes how to embed the Mono runtime in your
application, and how to invoke CIL methods from C, and how to
invoke C code from CIL Slides for Paolo's presentation at .NET ONE
on the embedding API are available here:
<a href="http://primates.ximian.com/~lupus/slides/embed">Hosting
the Mono Runtime</a>.</p>
<h2>Embedding the runtime.</h2>
<p>Embedding the runtime consists of various steps:</p>
<ul>
<li>Compiling and linking the Mono runtime</li>
<li>Initializing the Mono runtime</li>
<li>Optionally expose C code to the C#/CIL universe.</li></ul>
<p>These are discussed in detail next.</p>
<h3>Compiling and Linking</h3>
<p>To embed the runtime, you have to link your code against the
Mono runtime libraries. To do this, you want to pass the flags
returned by pkg-config to your compiler:</p>
<pre class="code">
                pkg-config --cflags --libs mono
</pre>
<p>Like this:</p>
<pre class="code">
                gcc sample.c `pkg-config --cflags --libs mono`
</pre>
<p>You can separate the compilation flags from the linking flags,
for instance, you can use the following macros in your
makefile:</p>
<pre class="code">
                CFLAGS=`pkg-config --cflags mono`
                LDFLAGS=`pkg-config --libs mono`
</pre>
<h3>Initializing the Mono runtime</h3>
<p>To initialize the runtime, call mono_jit_init, like this:</p>
<pre class="code">
                MonoDomain *domain;
<br />                domain = mono_jit_init ("domain-name");
</pre>
<p>That will return a MonoDomain where your code will be executed.
You can create multiple domains. Each domain is isolated from the
other domains and code in one domain will not interfere with code
in other domains. This is useful if you want to host different
applications in your program.</p>
<p>Then you can load an assembly containing code into the
domain:</p>
<pre class="code">
                MonoAssembly *assembly;
<br />                assembly = mono_domain_assembly_open (domain, "file.dll");
                if (!assembly)
                        error ();
</pre>
<p>In the above example, the contents of `file.dll' will be loaded
into the domain. This only loads the code, but it will not execute
anything yet. You can replace `file.dll' with another transport
file, like `file.exe'</p>
<p>To start executing code, you must invoke a method in the
assembly, or if you have provided a static Main method (an entry
point), you can use the convenience function:</p>
<pre class="code">
                retval = mono_jit_exec (domain, assembly, argc - 1, argv + 1);
</pre>
<p>If you want to invoke a different method, look at the `Invoking
Methods in the CIL universe' section later on.</p>
<h3>Shutting down the runtime</h3>
<p>To shutdown the Mono runtime, you have to clean up all the
domains that were created, use this function:</p>
<pre class="code">
                mono_jit_cleanup (domain);
</pre>
<h3>Applications that use threads.</h3>
<p>The Boehm GC system needs to catch your calls to the pthreads
layer, so in each file where you use pthread.h you should include
the &lt;gc/gc.h/&gt; file.</p>
<h2>Exposing C code to the CIL universe</h2>
<p>The Mono runtime provides two mechanisms to expose C code to the
CIL universe: internal calls and native C code. Internal calls are
tightly integrated with the runtime, and have the least overhead,
as they use the same data types that the runtime uses.</p>
<p>The other option is to use the Platform Invoke (P/Invoke) to
call C code from the CIL universe, using the standard P/Invoke
mechanisms.</p>
<p>To register an internal call, use this call in the C code:</p>
<pre class="code">
        mono_add_internal_call ("Hello::Sample", sample);
</pre>
<p>Now, you need to declare this on the C# side:</p>
<pre class="code">
                using System;
                using System.Runtime.CompilerServices;
</pre>
<pre class="code">
        class Hello {
                [MethodImplAttribute(MethodImplOptions.InternalCall)]
                extern static string Sample ();
        }
</pre>
<p>Since this routine returns a string, here is the C
definition:</p>
<pre class="code">
                static MonoString*
                Sample () 
                {
                        return mono_string_new (mono_domain_get (), "Hello!");
                }
</pre>
<p>Notice that we have to return a `MonoString', and we use the
`mono_string_new' API call to obtain this from a string.</p>
<h2>Invoking Methods in the CIL universe</h2>
<p>Calling a method in the CIL universe from C requires a number of
steps:</p>
<ul>
<li>Obtaining the MonoMethod handle to the method.</li>
<li>The method invocation.</li></ul>
<h3>Obtaining a MonoMethod</h3>
<p>To get a MonoMethod there are several ways.</p>
<p>You can get a MonoClass (the structure representing a type)
using:</p>
<pre class="code">
        MonoClass *
        mono_class_from_name (MonoImage *image, const char* name_space, const char *name);
</pre>
<p>and then loop in the returned class method array until you get
the one you're looking for. There are examples of such searches as
static functions in several C files in metadata/*.c: we need to
expose one through the API and remove the duplicates.</p>
<p>The other, simpler, way is to use the functions in
debug-helpers.h: there are examples of their use in monograph, mint
and the JIT as well. You basically use a string description of the
method, like:</p>
<pre class="code">
                "System.Object:GetHashCode()"
</pre>
and create a MonoMethodDesc out of it with: 
<pre class="code">
        MonoMethodDesc* mono_method_desc_new (const char *name, gboolean include_namespace);
</pre>
You can then use: 
<pre class="code">
        MonoMethod*     mono_method_desc_search_in_class (MonoMethodDesc *desc, MonoClass *klass);
        MonoMethod*     mono_method_desc_search_in_image (MonoMethodDesc *desc, MonoImage *image);
</pre>
to search for the method in a class or in an image. You would
typically do this just once at the start of the program and store
the result for reuse somewhere. 
<h2>Invoking a Method</h2>
<p>There are two functions to call a managed method:</p>
<pre class="code">
        MonoObject*
        mono_runtime_invoke         (MonoMethod *method, void *obj, void **params,
                                     MonoObject **exc);
        and
        MonoObject*
        mono_runtime_invoke_array   (MonoMethod *method, void *obj, MonoArray *params,
                                     MonoObject **exc);
</pre>
obj is the 'this' pointer, it should be NULL for static methods, a
MonoObject* for object instances and a pointer to the value type
for value types. 
<p>The params array contains the arguments to the method with the
same convention: MonoObject* pointers for object instances and
pointers to the value type otherwise. The _invoke_array variant
takes a C# object[] as the params argument (MonoArray *params): in
this case the value types are boxed inside the respective reference
representation. From unmanaged code you'll usually use the
mono_runtime_invoke() variant.</p>
<p>Note that this function doesn't handle virtual methods for you,
it will exec the exact method you pass: we still need to expose a
function to lookup the derived class implementation of a virtual
method (there are examples of this in the code, though).</p>
<p>You can pass NULL as the exc argument if you don't want to catch
exceptions, otherwise, *exc will be set to the exception thrown, if
any. if an exception is thrown, you can't use the MonoObject*
result from the function.</p>
<p>If the method returns a value type, it is boxed in an object
reference. We have plans for providing an additional method that
returns an unmanaged-&gt;managed thunk like this:</p>
<pre class="code">
        void* mono_method_get_unmanaged_thunk (MonoMethod *method);
</pre>
You'll be able to store the returned pointer in a function pointer
with the proper signature and call that directly from C: 
<pre class="code">
        typedef gint32 (*GetHashCode) (MonoObject *obj);
        
        GetHashCode func = mono_method_get_unmanaged_thunk (System_Object_GetHashCode_method);
        
        gint32 hashvalue = func (myobject);
</pre>
It may not be possible to manage exceptions in that case, though. I
need to think more about it. 
<h1>Samples</h1>
<p>See the sample programs in mono/sample/embed for examples of
embedding the Mono runtime in your application.</p>

</body>
</html>
