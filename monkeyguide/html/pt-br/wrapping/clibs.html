<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>

	<title>Wrapping GObject based C Libraries</title>
	<meta name = "DC.Description" content = "Wrapping GObject based C Libraries" />
	<meta name = "DC.Contributor" content = "Martin Willemoes Hansen" />

	<link rel="stylesheet" type="text/css" href="../style.css" />

	<meta name = "CVS.English.Version" content = "1.14" />
</head>

<body>

	<ol>
		<li><a href="#introduction">Introduction</a></li>
		
		<li><a href="#dirlayout">Directory layout</a></li>

		<li><a href="#sources">The sources directory</a></li>

		<li><a href="#api">The api directory</a></li>

		<li><a href="#namespace">The namespace directory</a></li>

		<li><a href="#glue">The glue directory</a></li>

		<li><a href="#doc">The doc directory</a></li>

		<li><a href="#conclusion">Conclusion</a></li>

		<li><a href="#wrappers">Existing Wrappers</a></li>

		<li><a href="#credits">Credits</a></li>
	</ol>

	<h2><a name="introduction" id="introduction"></a>Introduction</h2>
	The focus of this section is to wrap C Libraries that are based on GObject.<br />
	You can wrap the library manually by typing in all the code and doing all 
	the tedious labour, or you could make use of the wrapping tools from Gtk#.

	<p />Basically the Gtk# wrapper tools works by parsing a GObject C-based library, extracting
	the right information to a xml file, and generate C# code from it.
	<a href="http://www.sigs.de/download/dotnet_02/mo11_kestner.zip">Automated library binding with Gtk# presentation</a><br />
	That is wonderfull and all, but it is not perfect; therefore, you will still have to
	do your fair share of the work. <br />
	But remember it is still way better than doing the wrapper by hand.

	<p />Also, it is still a good idea to wrap something manually, just to get a hang of it. 
	The rest of this introduction shows some of the wrapping techniques.

	<h3>Functions</h3>To
	call a function, a technique called platform invoke, or
	P/Invoke for short, is used.

	<p>Example of P/Invoke:</p>
<pre class="code">
using System;
using System.Runtime.InteropServices;
 
public class Wrapper {
	[DllImport ("libhelloworld-1.0.dll")]
	public extern static void HelloWorld();
 
	static void Main()
	{
		HelloWorld();
	}
}
</pre>

If you are working to be cross-platform, the DllImport attribute can seem like a problem. 
However, you can map .dll files to the appropriate .so files using /etc/mono/config.

	<h3>Typedefs</h3>
	One way to deal with typedefs is to make an alias.
	<pre class="code">
typedef guint32 Color
</pre>becomes
	<pre class="code">
using Color = System.UInt32;
</pre>

	<h3>Macros</h3>
	Unfortunately it is not possible to call macros from C# :( tough luck.<br />
	A workaround for this problem is to provided similar functionality as methods, 
	possibly using some glue code.

	<h2><a name="dirlayout" id="dirlayout"></a>Directory layout</h2>
	The common way to arrange the directory layout is to create a top-level directory 
	named after the library which is being wraped, ex. foobar-sharp. <br />
	Five new directories are created inside, namely api, doc, glue, foobar (namespace) 
	and sources.

<pre>
foobar-sharp/
      |
      |------ api/
      |
      |------ doc/
      |
      |------ glue/
      |
      |------ foobar/
      |
      \------ sources/
</pre>

	<h2><a name="sources" id="sources">The sources directory</a></h2>
	This is the place to put the source code of the library you are wrapping.<br />
	The parser will work with this directory.
	<p />Typical files which lives here:
<pre>
sources/
   |
   |---- Foobar.metadata
   |
   |---- foobar-sharp.sources
   |
   \---- makefile
</pre>

	foobar-sharp.sources is a file describing where the source code is, so it can be parsed,
	which namespace should be used and what library should be used when P/Invoking.

	<p />Content of foobar-sharp.sources:

<pre class="code">
./foobar-1.0/src Foobar foobar-1.0
</pre>

	<p />The makefile is to automate the process, it takes care of getting the source code,
	ex. from cvs, a ftp or a website. If there are any patches it applies those as well.<br />
	It takes care of starting the parsing process. Finally it provides a clean up procedure. 

	<p />Content of makefile:

<pre class="code">
PACKAGE=foobar-1.0
 
all:
        gapi.pl foobar-sharp.sources ../api
 
get-source-code:
        #wget http://foobar.sourceforge.net/sourceforge/foobar/$(PACKAGE).tar.gz \
        #--output-document=- | tar -xz;
 
        export CVS_PASSWORD=""
        cvs -z3 -d:pserver:anonymous@cvs.sf.net:/cvsroot/foobar co $(PACKAGE)
 
        patch $(PACKAGE)/src/foobar.h foobar.h.diff
 
distclean:
        rm -rf $(PACKAGE)
</pre>

	<p />Foobar.metadata is very interesting, since you will work with it a lot more than
	the other files <br />
	Once the makefile and foobar-sharp.sources file are made they will not be touched very
	often, but this file will be your friend through out your wrapping endeavor.

	<p />The content is metadata, data about the data, you can use it to make rules which
	make the parser modify its result from parsing the library.<br />
	This is very handy when you find that method signatures, a type parent, a constructor etc.
	are wrongly generated, or you want to hide some private API.<br />
	It is also used to turn the C API into a more .NET like API.

	<p />The structure of a .metadata file:

<pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;metadata&gt;

&lt;!-- type hides --&gt;
&lt;!-- method signal and property hides --&gt;
&lt;!-- renames --&gt;
&lt;!-- disable default constructor --&gt;
&lt;!-- ref and out parameters --&gt;
&lt;!-- variable arguments --&gt;
&lt;!-- return value --&gt;
&lt;!-- constructor collision hints --&gt;
&lt;!-- overloads --&gt;

&lt;/metadata&gt;
</pre>

	<p />The rules:
	<ul>
	 <li /> Type hides <br />
	 Sometimes its needed to hide some of the API because its private or not needed, 
	 the following rule show how it is done.

<pre class="code">
 &lt;rule&gt;
  &lt;class name="FoobarCanvas"/&gt;
  &lt;class name="FoobarLine"/&gt;
  &lt;data&gt;
    &lt;attribute target="class"&gt;
      &lt;name&gt;hidden&lt;/name&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>

         As you can see the rules are pretty structured.<br />
	 But what exactly do the tags mean? Let us disect them.
	 <ul>
	  <li />&lt;rule&gt; specifies a rule in the .metadata file.
	  <li />&lt;class&gt; this section specifies the type and which type members, if any should be modified<br />
	  In this case no members are specified, because we will hide all of the type, not only a member.
	  <li />&lt;data&gt; narrows down the what data of the type should be modified and what the modification is.<br />
	  In this case we target the class and wants it hidden.
	 </ul>

	 <p>This information will be present in the -api.xml file and the generator, 
	 will not generate code for these two types. </p>

	 <li /> Method, signal and property hides <br />
	 These rules hides methods, signals and properties.

	 <p />A method hide:
<pre class="code">
&lt;rule&gt;
   &lt;class name="FoobarConstraint"&gt;
    &lt;method&gt;AddExpression&lt;/method&gt;
   &lt;/class&gt;
   &lt;data&gt;
    &lt;attribute target="method"&gt;
      &lt;name&gt;hidden&lt;/name&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/attribute&gt;
   &lt;/data&gt;
&lt;/rule&gt;
</pre>
         Signal and property hides are similar to a method hide, 
	 just substitute method with either signal or property.<br />
	 Notice that a member is added in the &lt;class&gt; section, more members could be specified, if
	 the same modification applied to them as well.
	 <p />

	 <li /> Renames <br />
	 Renames are usually needed, to prevent method, signal and property identifier collisions.

	 <p />A method rename:
<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarCanvas"&gt;
    &lt;method&gt;SnapToGrid&lt;/method&gt;
  &lt;/class&gt;
  &lt;data&gt;
    &lt;attribute target="method"&gt;
      &lt;name&gt;name&lt;/name&gt;
      &lt;value&gt;SnapToGridCoordinates&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>
         To rename a signal or a property substitute method with either signal or property.<p />

	 <li /> Disabling of default constructor <br />
	 If the generated default constructor is not good enough and you want to replace it with
	 a custom made constructor you will probably have to disable the first mentioned with a rule
	 like this: 

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarCanvasLine"/&gt;
  &lt;data&gt;
    &lt;attribute target="class"&gt;
      &lt;name&gt;disabledefaultconstructor&lt;/name&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>

	 <li /> Ref and out parameters <br />
	 In C# you specify if a parameter to a method should be a ref, out or neither parameter,
	 but it is not so in C. Therefore this rule can be helpful.

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarEditable"&gt;
    &lt;method&gt;InsertText&lt;/method&gt;
  &lt;/class&gt;
  &lt;data&gt;
    &lt;attribute target="param"&gt;
      &lt;filter level="type"&gt;gint*&lt;/filter&gt;
      &lt;name&gt;pass_as&lt;/name&gt;
      &lt;value&gt;ref&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>

         An interesting tag is presented here, the &lt;filter&gt;, which can be used to make a more fine grained selection. 
	 In this case it is the type but it could be the identifier of the parameter as well.<br />
	 To specify an out paramter, substitute ref with out. <p />

	 <li /> Variable arguments <br />
	 Sometimes the actual parameters for a method is variable, like an array of values, in
	 such a case you can use this rule.

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarTreeStore"&gt;
    &lt;constructor&gt;foobar_tree_store_newv&lt;/constructor&gt;
  &lt;/class&gt;
  &lt;data&gt;
    &lt;attribute target="parameters"&gt;
      &lt;name&gt;va_type&lt;/name&gt;
      &lt;value&gt;length_param&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>

	 <li /> Return value <br />
	 If the return value is wrongly generated fix it with this rule:

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarFileSelection"&gt;
    &lt;method&gt;GetSelections&lt;/method&gt;
  &lt;/class&gt;
  &lt;data&gt;
    &lt;attribute target="return"&gt;
     &lt;name&gt;array&lt;/name&gt;
     &lt;value&gt;1&lt;/value&gt;
    &lt;/attribute&gt;
 &lt;/data&gt;
&lt;/rule&gt;
</pre>
         In this case the return type should be an array.<p />

	 <li /> Constructor collision hints <br />
	 This rule is used, when a type has some constructors, which will collide when turned into C# constructors, 
	 only one can be a real constructor the others must be methods. Which one should be chosen is specified here.

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarButton"&gt;
    &lt;constructor&gt;foobar_button_new_with_mnemonic&lt;/constructor&gt;
  &lt;/class&gt;
  &lt;data&gt;
    &lt;attribute target="method"&gt;
      &lt;name&gt;preferred&lt;/name&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>

	 <li /> Overloads <br />
	 No overloading exist in the C world, therefore this rule is used.

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarBox"&gt;
    &lt;method&gt;PackStartDefaults&lt;/method&gt;
  &lt;/class&gt;
  &lt;data&gt;
    &lt;attribute target="method"&gt;
      &lt;name&gt;name&lt;/name&gt;
      &lt;value&gt;PackStart&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>
         This is a rename rule too, but a special one.<p />

	 <li /> Missing parent <br />
	 Sometimes a type is missing the base type its inheriting from, its parent.<br />
	 Correct it with this rule.

<pre class="code">
&lt;rule&gt;
  &lt;class name="FoobarProgressBar"/&gt;
  &lt;data&gt;
    &lt;attribute target="class"&gt;
      &lt;name&gt;parent&lt;/name&gt;
      &lt;value&gt;FoobarWidget&lt;/value&gt;
    &lt;/attribute&gt;
  &lt;/data&gt;
&lt;/rule&gt;
</pre>

	</ul>

	<h2><a name="api" id="api">The api directory</a></h2>
	After parsing the library and applying the rules from the .metadata file the parser
	generates an xml file as the result, this file is placed in the api directory.<br />
	The C# generator works with this directory as well as the namespace directory.

	<p />Typical files which lives here:
<pre>
api/
 |
 |---- foobar-api.xml
 |
 |---- foobar-symbols.xml
 |
 \---- makefile
</pre>

        The foobar-api.xml file is generated by the parser.

        <p />The foobar-symbols.xml file is used to correct symbols in the -api.xml file.<br />
	It can be a simple type like FoobarType which is just an int or it can be a manual
	type like FoobarEvent which is created manually in a .custom file, see the documentation
	for the namespace directory for more on .custom files.

	<p />The contents of the -symbols.xml file:
<pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;api&gt;
  &lt;symbol type="manual" cname="FoobarEvent" name="Foobar.Event"/&gt;
  &lt;symbol type="simple" cname="FoobarType" name="int"/&gt;
&lt;/api&gt;
</pre>

        <p />The makefile is used to automate the process.<br />
	It contains the information of which .xml files should be processed and
	which .xml files they depend on.<br />
	It launches the C# code generator and makes a timestamp to satisfy the 
	way make works.

<p />The contents of the makefile:
<pre class="code">
PREFIX=         /usr
 
API=            foobar-api.xml     \
                foobar-symbols.xml
 
INCLUDE_API=    $(PREFIX)/share/gapi/art-api.xml                \
                $(PREFIX)/share/gapi/pango-api.xml              \
                $(PREFIX)/share/gapi/atk-api.xml                \
                $(PREFIX)/share/gapi/gnome-api.xml              \
                $(PREFIX)/share/gapi/gtk-api.xml                \
                $(PREFIX)/share/gapi/gdk-api.xml                \
                $(PREFIX)/share/gapi/gdk-symbols.xml
 
all: generated-stamp
 
generated-stamp: $(API)
        gapi_codegen.exe --include $(INCLUDE_API) --generate $(API) &#38;&#38; touch generated-stamp
 
clean:
        rm -f generated-stamp
</pre>

	<h2><a name="namespace" id="namespace">The namespace directory</a></h2>
	This directory actually contains the C# source code which is created by the
	Gtk# C# code generator.

	<p />The directory layout is like this:
<pre>
foobar/
  |
  |---- .custom files
  |
  |---- generated/
  |
  \---- makefile
</pre>

        A directory named generated is created by the code generator and populated with .cs files.<br />
	Some of them start with FoobarSharp. to indicate that they are in the namespace FoobarSharp, it is
	a namespace which is created by the generator to be used for extra glue code, such as signal
	handling.

	<p /> Sometimes it would be nice to add some extra methods to the generated code and luckily you
	can. The .custom files are used for this purpose.

	<p /> A sample .custom file.

<pre class="code">
// Point.Custom - customizations
//
// Author: Foo Bar &lt;foo@bar.baz&gt;
//
// Copyright (C) 2003 Foo Bar
//
// This code is inserted after the automatically generated code.
 
public Point (double x, double y)
{
        this.x = x;
        this.y = y;
}
 
public override string ToString()
{
        return String.Format ("({0}, {1})", x, y);
}
</pre>

        The makefile is once again used to automate the process.<br />
	It lists the assemblies which the library is depending on, it lauches
	the compilation process, it installs the library and finally it can
	clean up the mess it made.

	<p />An example makefile:

<pre class="code">
PREFIX=         /usr
 
ASSEMBLIES=     -r gtk-sharp.dll \
                -r glib-sharp.dll \
                -r gnome-sharp.dll \
                -r gdk-sharp.dll \
                -r pango-sharp.dll \
                -r art-sharp.dll
 
LIBRARY=        foobar-sharp.dll
 
all: $(LIBRARY)
 
$(LIBRARY): generated/*.cs
        mcs --unsafe --target library $(ASSEMBLIES) --recurse '*.cs' -o $(LIBRARY)
 
install:
        install -o root -g root -m 644 $(LIBRARY) $(PREFIX)/lib
 
clean:
        rm -f $(LIBRARY)
        rm -rf generated
</pre>

	<h2><a name="glue" id="glue">The glue directory</a></h2>
	This directory is for so called glue code, C code which interfaces with the
	C# code in .custom files.<br />

	<p />Typical files which lives here:
<pre>
glue/
  |
  |---- .c files
  |
  \---- makefile
</pre>
	
	The C files could be creating objects in the c world which can not be generated in
	the mono world and passed down. They could also expose private fields.

	<p />An example C glue code file:

<pre class="code">
/* foobar-canvas.c : Glue for accessing fields in the FoobarCanvas class.
 *
 * Author: Foo Bar &lt;foo@bar.baz&gt;
 *
 * Copyright (C) 2003 Foo Bar
 *
 */
  
#include &lt;foobar/foobar-canvas.h&gt;
  
/* Forward declarations */
FoobarCanvasItem * foobarsharp_canvas_get_root (FoobarCanvas * canvas);
/* */
  
FoobarCanvasItem *
foobarsharp_canvas_get_root (FoobarCanvas * canvas)
{
        return canvas->root;
}
</pre>

        The root field of the FoobarCanvas was not exposed as a GObject property and
	therefore could	not be accessed directly from C#. <br /> 
	After the creation of this glue code a .custom file can be created which 
	P/Invokes FoobarCanvasItem * foobarsharp_canvas_get_root (FoobarCanvas * canvas);

	<h2><a name="doc" id="doc">The doc directory</a></h2>
	This directory contains the API documentation for the library, it makes use of the 
	MonoDoc tools. <br />
	To be honest, it is not part of the wrapping process, anyways you will most
	likely want to implement this part too.

	<p />Layout of the doc directory.
<pre>
doc/
 |
 |---- foobar-docs.source
 |
 |---- foobar-docs.tree
 |
 |---- foobar-docs.zip
 |
 |---- en/
 |      |
 |      |---- Foobar
 |      |
 |      \---- FoobarSharp
 |
 |---- makefile
 |
 \---- tmp
</pre>

        What is interesting here is the foobar-docs.source file and the makefile. The rest I
	generated with the MonoDoc tools.

	<p />The foobar-docs.source file contains information about which provider should 
	be used to render the documentation, most likely it will be the ecma provider. <br />
	But if you include some kind of html tutorial then take a look at the monohb provider,
	it might be useful to you.<br />
	Then, it specifies the basefile, that way MonoDoc can find the files it need. Finally,
	a path is provided, which MonoDoc uses to place the documentation in the documentation 
	tree.

	<p />An example -docs.source file.
<pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;monodoc&gt;
  &lt;source provider="ecma" basefile="foobar-docs" path="classlib-foobar"/&gt;
&lt;/monodoc&gt;	
</pre>

        The makefile automates the generation of the documentation.<br />
	First a couple of variables are set to the location of the assembler and updater tool.
	Generation of xml documentation stubs are provided in the update section, the result is
	put in the en directory and then split up acording to namespace.
	Then the -docs.zip and docs.tree are generated from the xml files in the en directory.
	Installation and clean up procedures are also provided.

	<p />An example makefile.
<pre class="code">
ASSEMBLER=../../monodoc/browser/assembler.exe
UPDATER=../../monodoc/generator/updater.exe
 
all: foobar-docs.zip foobar-docs.tree
 
foobar-docs.zip foobar-docs.tree: en/*/*.xml
        mono $(ASSEMBLER) --ecma en -o foobar-docs
 
install: foobar-docs.zip foobar-docs.tree
        install -m 644 foobar-docs.zip foobar-docs.tree `monodoc --get-sourcesdir`
        install -m 644 foobar-docs.source `monodoc --get-sourcesdir`
 
update:
        mono $(UPDATER) ../foobar/foobar-sharp.dll -o ./en
 
clean:
        rm -f *.tree
        rm -f *.zip
        rm -f tmp
        rm -f ..zip
</pre>

        Now the only thing left, is to fill out the generated documentation framework. 
	By the way it is the hardest part ;)

	<h2><a name="conclusion" id="conclusion"></a>Conclusion</h2>
	You have now learned a great deal about how you can make Gtk# work for you in the 
	wrapping effort. Its not that hard after all :o)<br />
	If you experience some bugs, or are missing some .metadata rules, you are in luck, because
	the tools are free software, thus you can get the source code and fix the problem.

	<p />In case you do not have the time or money, please report the problem to the 
	<a href="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">Gtk# mailinglist</a> 
	and the bugzilla <a href="http://bugzilla.ximian.com">bug database.</a>

	<h2><a name="wrappers" id="wrappers"></a>Existing Wrappers</h2>
	For more inspiration take a look at these existing wrappers.

	<ul>
		<li><a href="http://gtk-sharp.sourceforge.net/">
		Gtk#</a>Many wrappers of GNOME libraries</li>

		<li><a href="http://www.go-mono.com/anoncvs.html">
		DiaCanvas#</a>Module diacanvas-sharp</li>
		
		<li><a href="http://www.go-mono.com/anoncvs.html">
		GtkMozEmbed#</a>Module gtkmozembed-sharp</li>

		<li><a href="http://www.go-mono.com/anoncvs.html">
		Vorbis#</a>Module csvorbis</li>

		<li><a href="http://charon.ucam.org/~rjw57/pub_files/xine-sharp-0.1.tar.bz2">
		Xine#</a></li>

		<li><a href="http://amy.udd.htu.se/~malte/esd-sharp">
		Esd#</a></li>
	</ul>

</body>
</html>
