<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>GstElement</title>

	<meta name = "DC.Description" content = "" />
	<meta name = "DC.Contributor" content = "Johannes Roith" />

	<link rel="stylesheet" type="text/css" href="../../../style.css" />

	<meta name = "CVS.English.Version" content = "1.7" />
</head>
<body> 

<h2>Contents</h2>
<ul>
<li>1. The popt interface</li>
</ul>
<h2>What is a GstElement</h2>GstElement is the basic building block
for the media pipeline. All the different components you are going
to use are derived from GstElement. This means that a lot of
functions you are going to use operate on objects of this class.
<p>Elements, from the perspective of GStreamer, are viewed as
"black boxes" with a number of different aspects. One of these
aspects is the presence of "pads", or connection points. This
terminology arises from soldering; pads are where wires can be
attached.</p>
<h3>Source elements</h3>Source elements generate data for use by a
pipeline, for example reading from disk or from a sound card.
<p>Below you see how we will visualize the element. We always draw
a source pad to the right of the element.</p>
<p>Visualisation of a source element</p>
<p>Source elements do not accept data, they only generate data. You
can see this in the figure because it only has a source pad. A
source pad can only generate data.</p>
<h3>Filters and codecs</h3>Filter elements both have input and
output pads. They operate on data they receive in their sink pads
and produce data on their source pads. For example, MPEG decoders
and volume filters would fall into this category.
<p>Elements are not constrained as to the number of pads they might
have; for example, a video mixer might have two input pads (the
images of the two different video streams) and one output pad.</p>
<p>Visualisation of a filter element</p>
<p>The above figure shows the visualisation of a filter element.
This element has one sink (input) pad and one source (output) pad.
Sink pads are drawn on the left of the element.</p>
<p>Figure 5.3. Visualisation of a filter element with more than one
output pad</p>
<p>The above figure shows the visualisation of a filter element
with more than one output pad. An example of such a filter is the
AVI splitter (demultiplexer). This element will parse the input
data and extract the audio and video data. Most of these filters
dynamically send out a signal when a new pad is created so that the
application programmer can connect an arbitrary element to the
newly created pad.</p>
<h3>Sink elements</h3>Sink elements are terminal points in a media
pipeline. They accept data but do not produce anything. Disk
writing, sound card playback, and video output would all be
implemented by sink elements.
<p>Visualisation of a sink element</p>
<h2>Creating a GstElement</h2>A GstElement object is created from a
factory. To create an element, you have to get access to a
GstElementFactory object using a unique factory name.
<p>The following code example is used to get a factory that can be
used to create the 'mad' element, an mp3 decoder.</p>
<pre classs="code">
 GstElementFactory *factory;

 factory = gst_element_factory_find ("mad");
</pre>Once you have the handle to the element factory, you can
create a real element with the following code fragment:
<pre class="code">
 GstElement *element;

 element = gst_element_factory_create (factory, "decoder");
</pre>gst_element_factory_create will use the element factory to
create an element with the given name. The name of the element is
something you can use later on to look up the element in a bin, for
example. You can pass NULL as the name argument to get a unique,
default name.
<p>A simple shortcut exists for creating an element from a factory.
The following example creates an element named "decoder" from the
element factory named "mad". This convenience function is most
widely used to create an element.</p>
<pre class="code">
 GstElement *element;

 element = gst_element_factory_make ("mad", "decoder");
</pre>When you don't need the element anymore, you need to unref
it, as shown in the following example.
<pre class="code">
 GstElement *element;

  ...
 gst_element_unref (element);
    
</pre>
<h2>Gst properties</h2>A GstElement can have several properties
which are implemented using standard GObject properties. The usual
GObject methods to query, set and get property values and
GParamSpecs are therefore supported.
<p>Every GstElement inherits at least one property of its parent
GstObject: the "name" property. This is the name you provide to the
functions gst_element_factory_make or gst_element_factory_create.
You can get and set this property using the functions
gst_object_set_name and gst_object_get_name or use the GObject
property mechanism as shown below.</p>
<pre class="code">
 GstElement *element;
 GValue value = { 0, }; /* initialize the GValue for g_object_get()
*/

 element = gst_element_factory_make ("mad", "decoder");
 g_object_set (G_OBJECT (element), "name", "mydecoder", NULL);
 ...

 g_value_init (&amp;value, G_TYPE_STRING);
 g_object_get_property (G_OBJECT (element), "name", &amp;value);
 ...
</pre>Most plugins provide additional properties to provide more
information about their configuration or to configure the element.
gst-inspect is a useful tool to query the properties of a
particular element, it will also use property introspection to give
a short explanation about the function of the property and about
the parameter types and ranges it supports.
<p>For more information about GObject properties we recommend you
read the GObject manual.</p>
</body>
</html>
