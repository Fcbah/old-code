<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Gtk# - Range widgets</title>

	<meta name ="DC.Description" content ="" />
	<meta name ="DC.Contributor" content ="Johannes Roith" />

	<link rel="stylesheet" type="text/css" href="../../../style.css" />

	<meta name = "CVS.English.Version" content = "1.8" />
</head>
<body>

<p>The Range widget class is fairly complicated internally, but,
like all the "base class" widgets, most of its complexity is only
interesting if you want to hack on it. Also, almost all of the
functions and signals it defines are only really used in writing
derived widgets. There are, however, a few useful functions that
are defined in &amp;li;gtk/gtkrange.h&gt; and will work on all
range widgets.</p>
<h3>Setting the Update Policy</h3>
The "update policy" of a range widget defines at what points during
user interaction it will change the value field of its Adjustment
and emit the "value_changed" signal on this Adjustment. The update
policies, defined in &amp;li;gtk/gtkenums.h&gt; as type enum
GtkUpdateType, are: 
<pre class="code">
Gtk.Update.Continuous
</pre>
This is the default. The "ValueChanged" event is emitted
continuously, i.e., whenever the slider is moved by even the
tiniest amount. 
<pre class="code">
Gtk.Update.Discontinuous
</pre>
The "ValueChanged" event is only emitted once the slider has
stopped moving and the user has released the mouse button. 
<pre class="code">
Gtk.Update.Delayed
</pre>
The "ValueChanged" event is emitted when the user releases the
mouse button, or if the slider stops moving for a short period of
time. The update policy of a range widget can be set by casting it
using the GTK_RANGE(widget) macro and passing it to this function: 
<pre class="code">
range1.UpdatePolicy = UpdateType  policy;
</pre>
<h3>Getting and Setting Adjustments</h3>
Getting and setting the adjustment for a range widget "on the fly"
is done, predictably, with: GtkAdjustment*
gtk_range_get_adjustment( GtkRange *range ); 
<pre class="code">
range1.Adjustment = Adjustment adjustment;
</pre>
range1.Adjustment returns a pointer to the adjustment to which
range is connected. 
<p>range1.Adjustment does absolutely nothing if you assign to it
the adjustment that range is already using, regardless of whether
you changed any of its fields or not. If you pass it a new
Adjustment, it will unreference the old one if it exists (possibly
destroying it), connect the appropriate signals to the new one, and
call the private function range1.AdjustmentChanged(), which will
(or at least, is supposed to...) recalculate the size and/or
position of the slider and redraw if necessary. As mentioned in the
section on adjustments, if you wish to reuse the same Adjustment,
when you modify its values directly, you should emit the "changed"
signal on it, like this:</p>
<pre class="code">
g_signal_emit_by_name (G_OBJECT (adjustment), "changed");
</pre>

</body>
</html>
