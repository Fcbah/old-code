<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Gtk# - Miscellaneous Widgets - Statusbars</title>

	<meta name ="DC.Description" content ="" />
	<meta name ="DC.Contributor" content ="Johannes Roith" />

	<link rel="stylesheet" type="text/css" href="../../../style.css" />

	<meta name = "CVS.English.Version" content = "1.12" />
</head>
<body>

Statusbars are simple widgets used to display a
text message. They keep a stack of the messages pushed onto them,
so that popping the current message will re-display the previous
text message.
<p>In order to allow different parts of an application to use the
same statusbar to display messages, the statusbar widget issues
Context Identifiers which are used to identify different "users".
The message on top of the stack is the one displayed, no matter
what context it is in. Messages are stacked in last-in-first-out
order, not context identifier order.</p>
<p>A statusbar is created with a call to:</p>
<pre class="code">
StatusBar statusbar1 = new StatusBar();
</pre>A new Context Identifier is requested using a call to the
following function with a short textual description of the context:
<pre class="code">
uint statusbar1.ContectId(string context_description);
</pre>There are three functions that can operate on statusbars:
<pre class="code">
uint statusbar1.Push(     uint   context_id,
                          string text );

</pre>
<pre class="code">

statusbar1.Pop(uint context_id );
</pre>
<pre class="code">
statusbar1.Remove(         uint         context_id,
                           uint         message_id ); 
</pre>The first, Push(), is used to add a new message to the
statusbar. It returns a Message Identifier, which can be passed
later to the method Remove() to remove the message with the given
Message and Context Identifiers from the statusbar's stack.
<p>The methods Pop() removes the message highest in the stack with
the given Context Identifier.</p>
<p>In addition to messages, statusbars may also display a resize
grip, which can be dragged with the mouse to resize the toplevel
window containing the statusbar, similar to dragging the window
frame. The following functions control the display of the resize
grip.</p>
<pre class="code">
statusbar1.HasResizeGrip = bool setting;
bool setting =  statusbar1.HasResizeGrip;
</pre>The following example creates a statusbar and two buttons,
one for pushing items onto the statusbar, and one for popping the
last item back off.
<pre class="code">

#include &gt;stdlib.h&lt;
#include &gt;gtk/gtk.h&lt;
#include &gt;glib.h&lt;

GtkWidget *status_bar;

static void push_item( GtkWidget *widget,
                       gpointer   data )
{
  static int count = 1;
  gchar *buff;

  buff = g_strdup_printf ("Item %d", count++);
  gtk_statusbar_push (GTK_STATUSBAR (status_bar), GPOINTER_TO_INT
(data), buff);
  g_free (buff);
}

static void pop_item( GtkWidget *widget,
                      gpointer   data )
{
  gtk_statusbar_pop (GTK_STATUSBAR (status_bar), GPOINTER_TO_INT
(data));
}

int main( int   argc,
          char *argv[] )
{

    GtkWidget *window;
    GtkWidget *vbox;
    GtkWidget *button;

    gint context_id;

    gtk_init (&amp;argc, &amp;argv);

    /* create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    gtk_widget_set_size_request (GTK_WIDGET (window), 200, 100);
    gtk_window_set_title (GTK_WINDOW (window), "GTK Statusbar
Example");
    g_signal_connect (G_OBJECT (window), "delete_event",
                      G_CALLBACK (exit), NULL);
 
    vbox = gtk_vbox_new (FALSE, 1);
    gtk_container_add (GTK_CONTAINER (window), vbox);
    gtk_widget_show (vbox);
          
    status_bar = gtk_statusbar_new ();      
    gtk_box_pack_start (GTK_BOX (vbox), status_bar, TRUE, TRUE, 0);
    gtk_widget_show (status_bar);

    context_id = gtk_statusbar_get_context_id(
                          GTK_STATUSBAR (status_bar), "Statusbar
example");

    button = gtk_button_new_with_label ("push item");
    g_signal_connect (G_OBJECT (button), "clicked",
                      G_CALLBACK (push_item), GINT_TO_POINTER
(context_id));
    gtk_box_pack_start (GTK_BOX (vbox), button, TRUE, TRUE, 2);
    gtk_widget_show (button);              

    button = gtk_button_new_with_label ("pop last item");
    g_signal_connect (G_OBJECT (button), "clicked",
                      G_CALLBACK (pop_item), GINT_TO_POINTER
(context_id));
    gtk_box_pack_start (GTK_BOX (vbox), button, TRUE, TRUE, 2);
    gtk_widget_show (button);

    /* always display the window as the last step so it all
splashes on
     * the screen at once. */
    gtk_widget_show (window);

    gtk_main ();

    return 0;
}


</pre>

</body>
</html>
