<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Gtk# - Miscellaneous Widgets - Progress Bars</title>

	<meta name ="DC.Description" content ="" />
	<meta name ="DC.Contributor" content ="Johannes Roith" />

	<link rel="stylesheet" type="text/css" href="../../../style.css" />

	<meta name = "CVS.English.Version" content = "1.14" />
</head>
<body>
Progress bars are used to show the status of
an operation. They are pretty easy to use, as you will see with the
code below. But first lets start out with the calls to create a new
progress bar.
<pre class="code">
ProgressBar progressbar1 = new ProgressBar();
</pre>Now that the progress bar has been created we can use it.
<pre class="code">
progressbar1.Fraction = double fraction;
</pre>The value is the amount "completed", meaning the amount the
progress bar has been filled from 0-100%. It can be a number form 0
to 1, e.g. 0.55 would be 55%.
<p>Gtk# has functionality that enables it to display its value in
different ways, and to inform the user of its current value and its
range.</p>
<p>A progress bar may be set to one of a number of orientations
using the method</p>
<pre class="code">
progressbar1.Orientation = ProgressBarOrientation orientation;
</pre>The orientation argument may take one of the following values
to indicate the direction in which the progress bar moves:
<pre class="code">
  Gtk.Progress.LeftToRight
  Gtk.Progress.RightToLeft
  Gtk.Progress.BottomToTop
  Gtk.Progress.TopToBottom
</pre>As well as indicating the amount of progress that has
occured, the progress bar may be set to just indicate that there is
some activity. This can be useful in situations where progress
cannot be measured against a value range. The following method
indicates that some progress has been made.
<pre class="code">
progressbar1.Pulse();
</pre>The step size of the activity indicator is set using the
following property.
<pre class="code">
progressbar1.PulseStep = double fraction;
</pre>When not in activity mode, the progress bar can also display
a configurable text string within its trough, using the following
property.
<pre class="code">
progressbar1.Text = string text;
</pre>Note that progressbar1.Text doesn't support the printf()-like
formatting of the GTK+ 1.2 Progressbar.
<p>You can turn off the display of the string by calling
progressbar1.Text(string text, null).</p>
<p>The current text setting of a progressbar can of course also be
retrieved with the property.</p>
<pre class="code">
string progress1.Text;
</pre>Progress Bars are usually used with timeouts or other such
functions (see section on Timeouts, I/O and Idle Functions) to give
the illusion of multitasking. All will employ the
progressbar1.Fraction() and progressbar1.Pulse() methods in the
same manner.
<p>Here is an example of the progress bar, updated using timeouts.
This code also shows you how to reset the Progress Bar.</p>
<p>
<img src="progress.png" border="0" />
</p>
<pre class="code">
using GLib;
using Gtk;
using GtkSharp;
using System;
	
class ProgressBarSample {
	public struct ProgressData {
		public Gtk.Window window;
		public Gtk.ProgressBar pbar;
		public uint timer;
		public bool activity_mode;
	}

	static ProgressData pdata;
	
	/* Update the value of the progress bar so that we get
	 * some movement */
	static bool progress_timeout()
	{
		double new_val;
		
		if (pdata.activity_mode)
			pdata.pbar.Pulse();
		else {
			/* Calculate the value of the progress bar using the
			 * value range set in the adjustment object */
			new_val = pdata.pbar.Fraction + 0.01;
			if (new_val > 1.0)
				new_val = 0.0;
			
			/* Set the new value */
			pdata.pbar.Fraction = new_val;
		}
			
		/* As this is a timeout function, return TRUE so that it
		 * continues to get called */
		
		return true;
	}


	/* Callback that toggles the text display within the progress bar trough */
	static void toggle_show_text (object obj, EventArgs args)
	{
		if (pdata.pbar.Text == "")
			pdata.pbar.Text = "some text";
		else
			pdata.pbar.Text = "";
	}

	/* Callback that toggles the activity mode of the progress bar */
	static void toggle_activity_mode (object obj, EventArgs args)
	{
		pdata.activity_mode = !pdata.activity_mode;
		if (pdata.activity_mode)
			pdata.pbar.Pulse();
		else
			pdata.pbar.Fraction = 0.0;
	}

	/* Callback that toggles the orientation of the progress bar */
	static void toggle_orientation (object obj, EventArgs args)
	{
		switch (pdata.pbar.Orientation) {
			case Gtk.ProgressBarOrientation.LeftToRight:
				pdata.pbar.Orientation = Gtk.ProgressBarOrientation.RightToLeft;
				break;
			case Gtk.ProgressBarOrientation.RightToLeft:
				pdata.pbar.Orientation = Gtk.ProgressBarOrientation.LeftToRight;
				break;
			}
	}

	
	static void destroy_progress (object obj, DeleteEventArgs args)
	{
		app_quit();
	}

	static void button_click (object obj, EventArgs args)
	{
		app_quit();
	}

	static void app_quit() {
		GLib.Source.Remove (pdata.timer);
		pdata.timer = 0;
		Application.Quit ();
	}
	
	static void Main()
	{
		Gtk.HSeparator separator;
		Gtk.Table table;
		Gtk.Button button;
		Gtk.CheckButton check;
		Gtk.VBox vbox;

		Application.Init ();
		
		/* Allocate memory for the data that is passed to the callbacks*/
		pdata = new ProgressData();
		pdata.activity_mode = false;
		pdata.window = new Gtk.Window(Gtk.WindowType.Toplevel);
		pdata.window.Resizable = true;

		pdata.window.DeleteEvent += new DeleteEventHandler (destroy_progress);
		pdata.window.Title = "GtkProgressBar";
		pdata.window.BorderWidth = 0;

		vbox = new Gtk.VBox(false, 5);
		vbox.BorderWidth = 10;
		pdata.window.Add(vbox);
		vbox.Show();
		
		/* Create a centering alignment object */
		Gtk.Alignment align = new Gtk.Alignment( 1, 1, 0, 0);
		vbox.PackStart(align, false, false, 5);
		align.Show();
		
		/* Create the GtkProgressBar */
		pdata.pbar = new Gtk.ProgressBar();
		pdata.pbar.Text = "";
		align.Add(pdata.pbar);
		pdata.pbar.Show();
		
		/* Add a timer callback to update the value of the progress bar*/
		pdata.timer = GLib.Timeout.Add(100, new GLib.TimeoutHandler (progress_timeout) );

		
		separator = new Gtk.HSeparator();
		vbox.PackStart(separator, false, false, 0);
		separator.Show();
		
		/* rows, columns, homogeneous */
		table = new Gtk.Table(2, 3, false);
		vbox.PackStart(table, false, true, 0);
		table.Show();
		
		/* Add a check button to select displaying of the trough text*/
		check = new Gtk.CheckButton("Show text");
		table.Attach(check, 0, 1, 0, 1, 
				Gtk.AttachOptions.Expand | Gtk.AttachOptions.Fill, 
				Gtk.AttachOptions.Expand | Gtk.AttachOptions.Fill, 
				5, 5);
		check.Clicked += new EventHandler(toggle_show_text);
		check.Show();
		
		/* Add a check button to toggle activity mode */
		check = new Gtk.CheckButton("Activity mode");
		table.Attach(check, 0, 1, 1, 2, 
				Gtk.AttachOptions.Expand | Gtk.AttachOptions.Fill, 
				Gtk.AttachOptions.Expand | Gtk.AttachOptions.Fill, 
				5, 5);
		check.Clicked += new EventHandler(toggle_activity_mode);
		check.Show();
	
		/* Add a check button to toggle orientation */
		check = new Gtk.CheckButton("Right to Left");
		table.Attach(check, 0, 1, 2, 3, 
				Gtk.AttachOptions.Expand | Gtk.AttachOptions.Fill, 
				Gtk.AttachOptions.Expand | Gtk.AttachOptions.Fill, 
				5, 5);
		check.Clicked += new EventHandler(toggle_orientation);
		check.Show();
		
		/* Add a button to exit the program */
		button = new Gtk.Button("close");
		button.Clicked += new EventHandler(button_click);
		vbox.PackStart(button, false, false, 0);
		
		/* This makes it so the button is the default. */
		button.CanDefault = true;
		
		/* This grabs this button to be the default button. Simply hitting
		* the "Enter" key will cause this button to activate. */
		button.GrabDefault();
		button.Show();
		
		pdata.window.ShowAll();
		
		Application.Run ();
	}
}
</pre>

</body>
</html>
