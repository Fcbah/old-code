<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:monodoc="http://www.go-mono.org/xml/monodoc">
<head>
	<title>Classes - Static Members</title>

	<meta name ="DC.Description" content ="" />
	<meta name ="DC.Contributor" content ="Johannes Roith" />
	<meta name ="DC.Contributor" content ="PJ Cabrera" />
	<meta name ="DC.Contributor" content ="Carlos Alberto Cortez Guevara" />

	<link rel="stylesheet" type="text/css" href="../style.css" />

	<meta name = "CVS.English.Version" content = "1.2" />
</head>
<body>

<p>
The static members are elements of a class that don't need 
to belong to any instance class. This is, elements that
exist without the need of the creation of an instance.
</p>
<p>
For example: there is a class called Clocks, that
is a virtual representation of the real world clocks
for a market. But it is neccessary to register the number of
clocks selled. So, we can have an independient int element, 
<i>selled</i>, which will exist inside the class.
</p>
<p>
Because coding is better than explaining, let's just write a small sample:
<pre class="code">
//
// Static elements inside a class
//

using System;

 public enum ClockType
 {

	Analogic,
	Digital,
	Modern,
	Cucu

 };

 public class Clock
 {

	// Constructor
	public Clock ( ClockType theType )
	{
		this.type = theType;

		// For each new Clock,
		// the static member selled will
		// increment in 1
		<b>selled++;</b>

	}

	// Read-only type Property
	public ClockType Type
	{

		get {
			return this.type;
		}

	}

	// Private element type
	private ClockType type;

	// Static element
	// Doesn't need an instance class to be used
	<b>public static int selled = 0;</b>

 }

 public class Tester 
 {

	public static void Main ()
	{

		//
		// Let's create three clocks for selling
		//
		Clock[] clocks = new Clock[3];
		clocks[0] = new Clock(ClockType.Analogic);
		clocks[1] = new Clock(ClockType.Digital);
		clocks[2] = new Clock(ClockType.Cucu);

		// Now let's print the Clocks selled
		foreach ( Clock clock in clocks ) {
			Console.WriteLine("Clock is type {0}", clock.Type);
		}

		// Finally we use the public static field
		<b>Console.WriteLine("{0} Clocks selled.", Clock.selled );</b>

	}

 }

</pre>
</p>
<p>
Now let's review the important sections. First of all, observe the field:
<pre class="code">
	<b>public static int selled = 0;</b>
</pre>
Note the reserved keyword <b>static</b>; it goes after the access modifier but
before the type of the field. This word tells the environment to reserve space
in memory, because it is created without the need of any instance class. Because of this,
we initialized it in the beginning ( no class memebers initialization ). It is possible
to avoid assign a value for a static field, but take care when trying to access its value
before any initialization.
</p>
<p>
The next important section is the class constructor:
<pre class="code">
 	// Constructor
        public Clock ( ClockType theType )
        {
                this.type = theType;

                // For each new Clock,
                // the static member selled will
                // increment in 1
                <b>selled++;</b>

        }
</pre>
The important line is the last, <b>selled++</b>. This causes to increment the selled private field
selled. How is it possible to recognize between a static and a non-static field? Well, most of times
the compiler will look for a field, ignoring if it is or not a static member. There's no problem if, 
for example, you only write <b>type=theType;</b>. Note that it is a good idea to work with all
the non-static field as <b>this.something</b> rather than <b>something</b>, because of
a good documented code ( remember than this referes to the current instance ). Also note that it is 
impossible to declare a pair of field with the same name, event if one is static and the other not.
</p>
<p>
Next, if we want to use a static member of a class, we have to write: first the name
of the class, a dot, and the name of the member ( if public ). In this case, our class is <b>Clock</b>,
and our current member <b>selled</b>, so for accessing it we write <b>Clock.selled</b>:
<pre class="code">
	<b>Console.WriteLine("{0} Clocks selled.", Clock.selled );</b>
</pre>
</p>
<p>
Compile and runt it; you should get:
<pre class="console">
Clock is type Analogic
Clock is type Digital
Clock is type Cucu
3 Clocks selled.
</pre>
</p>

<h3>More about static members</h3>
<p>
I introduced you to static elements, but we use only a field. Static members can be all kind
of class elements. To show it, let's add a property, and keep private our selled field.
In some part of the class add this code:
<pre class="code">
	public static int Selled {
	
		get 
		{
			return selled;
		}
			
	}
</pre>
And make private the selled field:
<pre class="code">
	private int selled = 0;
</pre>
Finally, don't forget to change the last line ( we don't need to access the Clock.selled field,
but the Clock.Selled property ).
<pre class="code">
 	Console.WriteLine("{0} Clocks selled.", Clock.Selled );
</pre>
</p>
Compile and runt it. If you get the same last message, you are on your way. Now you are able
to use the static members.

<h3>Static Constructor</h3>
<p>
I wanted to leave this, the static constructor. A constructor is a method called when creating
a new instance class. There are differente kind of constructors, as viewed in a previous section.
However, there still is one more constructor, the static one.
</p>
<p>
This constructor is called before any instance class is created in the current application. 
You can use it, for example, for initializing an DateTime object, or something like that. You must
see the difference between initializing a field when the application is executed, and initializing
one exactly before any instance class is created ( maybe no one in created, and the static constructor
will never be called ).
</p>
<p>
Let's finish write the right application whe have been working on. We will be initializing the int
<b>selled</b> field before any instance class is created. The you should change the field declaration to
<pre class="code">
	private static int selled;
</pre>
Yes, no initialization. Also add the static constructor:
<pre class="code">
	<b>static Clock
	{
		selled = 0;
	}</b> 
</pre>
This way our programm look beter.
</p>
<p>
But be careful; for example, in the last modification, if you want to access to the Selled property
before any instance class is created, you will receive an error message. Try to see when it is important
to use it and when not.
</p>
<p>
By the way, if you exaclty modify the application as I told you, you should see the same last messages.
</p>

</body>
</html>
