<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Mono Handbook - The Mono runtime</title>
<link rel="stylesheet" type="text/css" href="../style.css" />

	<meta name = "CVS.English.Version" content = "1.6" />
</head>
<body>
<div class="topframe" width="100%">
<a href="../index.html"><img src="../images/mg.png" border="0" />
</a></div>
<div class="navbar" width="100%"><a href="../index.html">The Mono
Handbook</a> &gt; <b>The Mono runtime</b></div>
<h1>The Mono runtime</h1>
<h2>Contents</h2>
<ul>
<li>1. <a href="#mcs">Current JIT Engine</a></li>
<li>2. <a href="#mbas">New JIT engine</a></li>
<li>3. <a href="#credits">Garbage Collection</a></li>
<li>4. <a href="#credits">IO and threading</a></li>
<li>5. <a href="#credits">Useful links</a></li>
<li>6. <a href="#credits">PInvoke</a></li>
<li>7. <a href="#credits">Remoting</a></li>
<li>8. <a href="#credits">Porting</a></li>
<li>9. <a href="#credits">COM and XPCOM</a></li></ul>
<p>The Mono runtime implements a JIT engine for the CIL virtual
machine (as well as a byte code interpreter, this is to quickly
port it to new systems), the class loader, the garbage collector,
threading system and metadata access libraries.</p>
<p>We currently have two runtimes:</p>
<ul>
<li><b>mono:</b> The Just In Time compiler implemented using a BURS
instruction selector. We only support x86 machines in the JIT
engine at this point.</li>
<li><b>mint:</b> The Mono interpreter. This is an easy-to-port
runtime engine.</li></ul>
<p>Currently we are using the Boehm conservative garbage
collector.</p>
<p>The Mono runtime can be used as a stand-alone process, or it can
be <a href="embedded-api">embedded into applications</a> (see the
documentation in mono/samples/embed for more details).<br />
 Embedding the Mono runtime allows applications to be extended in
C# while reusing all of the existing C and C++ code.</p>
<p>Paolo Molaro did a presentation on the current JIT engine and
the new JIT engine. You can find his
<a href="http://primates.ximian.com/~lupus/slides/jit/">slides
here</a></p>
<h2>Current JIT Engine (<b>January 12th, 2002</b>)</h2>
<p>The JIT engine uses a code-generator generator approach for
compilation. Given the properties of CIL byte codes, we can take
full advantage of a real instruction selector for our code
generator.</p>
<p>The JIT engine implements a number of optimizations:</p>
<ul>
<li>Opcode cost estimates (our architecture allows us to generate
different code paths depending on the target CPU dynamically).</li>
<li>Inlining.</li>
<li>Constant folding. Although compilers typically do constant
folding, the combination of inlining with constant folding gives
some very good results.</li>
<li>Linear scan register allocation. In the past, register
allocation was our achilles heel, but now we have left this problem
behind.</li></ul>
There are a couple of books that deal with this technique: "A
Retargetable C Compiler" and "Advanced Compiler Design and
Implementation" are good references. You can also get a technical
description of
<a href="http://research.microsoft.com/copyright/accept.asp?path=http://www.research.microsoft.com/~drh/pubs/iburg.pdf&amp;pub=ACM">
lbrug</a>. A few papers that describe the instruction selector: 
<ul>
<li>
<a href="http://research.microsoft.com/copyright/accept.asp?path=http://www.research.microsoft.com/~drh/pubs/interface.pdf&amp;pub=wiley">
A code generation interface for ANSI C</a></li>
<li>
<a href="http://research.microsoft.com/copyright/accept.asp?path=http://www.research.microsoft.com/~drh/pubs/iburg.pdf&amp;pub=ACM">
Engineering efficient code generators using tree matching and
dynamic programming.</a></li></ul>
<h2>New JIT engine.</h2>
<p>We are working on a new JIT engine. The new JIT engine focuses
on portability and in two intermediate representations that
simplify the development of optimizations. This together with the
Ahead-of-Time compilation will allow developers to deploy
applications that match the speed of natively compiled code.</p>
<h2>Garbage Collection</h2>
<p>Currently we are using the Boehm conservative GC. Although our
plans are to move to the Intel ORP GC engine, our plans on a next
generation dual-JIT engine have to be taken into account.</p>
<p>We will be using the Intel ORP GC engine as it provides a
precise garbage collector engine, similar to what is available on
the .NET environment.</p>
<p>Although using a conservative garbage collector like Bohem's
would work, all the type information is available at runtime, so we
can actually implement a better collector than a conservative
collector.</p>
<ul>
<li>Garbage collection list and FAQ:
<a href="http://www.iecc.com/gclist/">http://www.iecc.com/gclist/</a></li>
<li>"GC points in a Threaded Environment":
<a href="http://research.sun.com/techrep/1998/abstract-70.html">http://research.sun.com/techrep/1998/abstract-70.html</a></li>
<li>"A Generational Mostly-concurrent Garbage Collector":
<a href="http://research.sun.com/techrep/2000/abstract-88.html">http://research.sun.com/techrep/2000/abstract-88.html</a></li>
<li>Details on The Microsoft .NET Garbage Collection
Implementation:
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI.asp">
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI.asp</a>
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI2.asp">
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmag00/html/GCI2.asp</a></li></ul>
<h2>IO and threading</h2>
<p>The ECMA runtime and the .NET runtime assume an IO model and a
threading model that is very similar to the Win32 API.</p>
<p>Dick Porter has been working on the Mono abstraction layer that
allows our runtime to execute code that depend on this
behaviour.</p>
<h2>Useful links</h2>
<p>Paolo Molaro found a few interesting links:</p>
<ul>
<li>On compilation of stack-based languages:
<a href="http://www.complang.tuwien.ac.at/projects/rafts.html">http://www.complang.tuwien.ac.at/projects/rafts.html</a></li>
<li>A paper on fast JIT compilation of a stack-based language:
<a href="http://www.research.microsoft.com/~cwfraser/pldi99codegen.pdf">
http://www.research.microsoft.com/~cwfraser/pldi99codegen.pdf</a></li>
<li>Vmgen generates much of the code for efficient virtual machine
(VM) interpreters from simple descriptions of the VM instructions:
<a href="http://www.complang.tuwien.ac.at/anton/vmgen/">http://www.complang.tuwien.ac.at/anton/vmgen</a></li></ul>
<h2>PInvoke</h2>
<p>PInvoke is the mechanism we are using to wrap Unix API calls as
well as talking to system libraries.<br />
 Initially we used libffi, but it was fairly slow, so we have
reused parts of the JIT work to create efficient PInvoke
trampolines.</p>
<h2>Remoting</h2>
<p>Mono has support for remoting and proxy objects, just like<br />
 .NET does. The runtime provides these facilities.</p>
<h2>Porting</h2>
<p>If you are interested in porting the Mono runtime to other
platforms, you might find the pre-compiled<br />
 <a href="archive/mono-tests.tar.gz">Mono regression test suite</a>
useful to debug your implementation.</p>
<h1>COM and XPCOM</h1>
<p>We plan on adding support for XPCOM on Unix and COM on Microsoft
Windows later in our development process.</p>
<h2>A. Credits</h2>
Author: Johannes Roith
(<a href="mailto:johannes@jroith.de">johannes@jroith.de</a>)<br />
Author: Miguel de Icaza
(<a href="mailto:miguel@ximian.com">miguel@ximian.com</a>)<br />
 <br />
<div class="copyright">The Mono Handbook -
<a href="http://www.go-mono.org">&#169; Copyright 2002 by Johannes
Roith</a></div>
</body>
</html>
