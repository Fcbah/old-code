#!/usr/bin/ruby
require 'pp'
require 'set'
require 'erb'
class Tag
    attr_accessor :name, :file, :expr
    
    def initialize(hash)
        hash.each do |k,v|
            instance_variable_set "@#{k}", v
        end
    end

    def to_s
        "<#{@kind} #{@name}>"
    end

    alias to_s inspect
end

class ClassTag < Tag
    attr_accessor :namespace, :inherits, :superclass, :fields

    def initialize(h)
        super
        @fields = Set[]
    end

    def is_cls? cls
        self == cls || @superclass && @superclass.is_cls?(cls)
    end

    def resolve classes
        @superclass = classes[@inherits]
    end

    def fields_closure
        if @superclass
            h = {}
            @superclass.fields_closure.each do |f|
                h[f.name] = f
            end
            # Override properties
            @fields.each do |f|
                h[f.name] = f
            end
            h.values
        else
            @fields
        end
    end

    def to_s
        "<#{@kind} #{[@name,@inherits].compact.join ':'}>"
    end
end

class FieldTag < Tag
    attr_accessor :type, :class
    def initialize(h)
        super
        # Remove namespace decorator
        @class.gsub!(/^.*\./, "")
    end

    def resolve classes
        classes[@class].fields << self
    end

    def to_s
        "<#{@kind} #{@name}:#{@type}>"
    end
end

class PropertyTag < FieldTag
end

kindmap = {"class" => ClassTag, "property" => PropertyTag, "field" => FieldTag}

input = `ctags -f - --fields=iKsz node.cs`

if input.empty?
    $stderr.puts "This script requires Exuberant Ctags"
    exit
end

# Create tag objects from tag lines
tags = []
input.each do |l|
    f = l.chomp.split(/\t/)
    name, file = f[0..1]
    expr = f[2][2..-5]
    props = {:name => name, :file => file, :expr => expr}
    f[3..-1].each do |x|
        k, v = x.split(":", 2)
        props[k.to_sym] = v
    end
    cls = kindmap[props[:kind]] || Tag
    tags << cls.new(props)
end

classes = {}

tags.each do |t|
    # Collect classes
    if t.is_a? ClassTag
        #qn = t.namespace + "." + t.name
        qn = t.name
        classes[qn] = t
    end
    # Extract field types
    if t.is_a? FieldTag
        m = /([a-zA-Z0-9_\[\]]+)\s+#{t.name}/.match t.expr
        t.type = m[1] if m
    end
end

# Resolve names to objects (superclasses, properties) etc.
tags.each do |t|
    t.resolve classes if t.respond_to? :resolve
end

nodeclass = classes["RNode"]
# Hack, RNode properties are bogus
nodeclass.fields = Set[]
# Find all node classes
nodes = tags.find_all { |t| t.is_a?(ClassTag) && t.is_cls?(nodeclass) && t != nodeclass }

tpl = ERB.new <<-'END'
//
// Automatically generated by tags.rb 
//

using System.Text;
using System.Collections;
using System.IO;

namespace NETRuby 
{
    class BlockPrinter
    {
        //StringBuilder sb = new StringBuilder();
        TextWriter tw;
        int indent = 0;
        Hashtable written = new Hashtable();
        int id = 1;
        NetRuby ruby;

        public BlockPrinter(NetRuby r, TextWriter t)
        {
            ruby = r;
            tw = t;
        }
        
        public void Write(string s)
        {
            if(s == null) {
                Write("null");
                return;
            }
            tw.Write(s);
        }

        public void Write(RNode n)
        {
            if(n == null) {
                Write("null");
                return;
            }
            if(written[n] != null) {
                Write("#");
                Write(n.print_id);
                return;
            }
            n.print_id = id++;
            written[n] = true;
            n.Print(this);
        }

        public void Write(uint n)
        {
            string s = ruby.id2name(n);
            if(s != null) {
                Write(":");
                Write(s);
            } else {
                tw.Write(n);
            }
        }

        public void Write(int n)
        {
            tw.Write(n);
        }

        public void Write(NOEX n)
        {
            Write(n.ToString());
        }

        public void Write(GlobalEntry n)
        {
            Write("<GlobalEntry>");
        }

        public void Write(uint[] n)
        {
            if(n == null) {
                Write("null");
                return;
            }
            //Write("<uint[]>");
            Write("[");
            for(int i = 0; i < n.Length; i++) {
                if(i != 0) Write(", ");
                Write(n[i]);
            }
            Write("]");
        }

        public void Write(bool n)
        {
            Write(n ? "true" : "false");
        }

        public void Write(object n)
        {
            if(n == null) {
                Write("null");
                return;
            }
            if(n is string || n is RString) {
                Write("\"");
                Write(n.ToString());
                Write("\"");
            } else if(n is int) {
                Write((int)n);
            } else {
                Write("<");
                Write(n.GetType().FullName);
                Write(">");
            }
        }

        public void NewLine()
        {
            Write("\n");
            for(int i = 0; i < indent; i++)
                Write("    ");
        }

        public void BeginBlock()
        {
            indent++;
        }

        public void EndBlock()
        {
            indent--;
        }
    }
    internal partial class RNode
    {
        public int print_id;
        internal virtual void Print(BlockPrinter p)
        {
            p.Write("<<Unknown node>>");
        }
        
        protected void WriteNode(BlockPrinter p, string name, RNode n, bool indent) 
        {
            if(n != null) {
                p.NewLine();
                p.Write(name+":");
                if(indent) p.BeginBlock();
                p.NewLine();
                p.Write(n);
                if(indent) p.EndBlock();
            }
        }
    }

    <% 
    skip = []
    skipprops = ["beg", "end"]
    nextprops = ["head", "next"]
    
    order = [
        "recv", "args",
        "iter", "var",
        "cond", "body", "nd_else",
        "head", "next"
    ]
    
    nodes.reject { |n| skip.include?(n.name) }.each do |n|
        flds = n.fields_closure.sort_by { |f| f.name }
        all_props = flds.
            find_all { |f| f.is_a?(PropertyTag) && !skipprops.include?(f.name) }.
            sort_by { |p| order.index(p.name) || order.length + flds.index(p) }

        # puts [n, all_props]
        nodeprops, plainprops = all_props.partition { |f| f.type == "RNode" }
        listprops, props = nodeprops.partition { |f| nextprops.include?(f.name) }
        iscons = !listprops.empty?
    %>
        internal partial class <%=n.name%> {
            internal override void Print(BlockPrinter p)
            {
                p.Write("(");
                p.Write("<%=n.name%>");
                <%# p.Write("("+print_id.ToString()+")"); %>
                <% plainprops.each do |p|%>
                    p.Write(" <%=p.name%>=");
                    p.Write(<%=p.name%>);
                <% end %>
                p.BeginBlock();
                <% props.each do |p| %>
                    WriteNode(p, "<%=p.name%>", <%=p.name%>, true);
                <% end %>
                p.EndBlock();
                <% listprops.each do |p| %>
                    WriteNode(p, " <%=p.name%>", <%=p.name%>, false);
                <% end %>
                p.Write(")");
            }
        }
    <% end %>
}
END

node_print_cs = tpl.result(binding)

File.open("node_print.cs","w") { |f| f.write node_print_cs }

# vim:et:sts=4:sw=4
