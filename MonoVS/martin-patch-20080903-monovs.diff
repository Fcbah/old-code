Index: martin-patch-20080903-monovs.diff
===================================================================
--- martin-patch-20080903-monovs.diff	(revision 112310)
+++ martin-patch-20080903-monovs.diff	(working copy)
@@ -1,1826 +0,0 @@
-Index: martin-patch-20080903-monovs.diff
-===================================================================
---- martin-patch-20080903-monovs.diff	(revision 112195)
-+++ martin-patch-20080903-monovs.diff	(working copy)
-@@ -1,819 +0,0 @@
--Index: RemotingContract/Contract.cs
--===================================================================
----- RemotingContract/Contract.cs	(revision 111699)
--+++ RemotingContract/Contract.cs	(working copy)
--@@ -84,8 +84,41 @@
--          * Stop all threads in the target.
--          */
--         void Stop ();
--+
--+        IAssemblerMethod DisassembleMethod (TargetAddress address);
-- 	}
-- 
--+    public interface IAssemblerMethod
--+    {
--+        IAssemblerLine[] Lines
--+        {
--+            get;
--+        }
--+    }
--+
--+    public interface IAssemblerLine
--+    {
--+        string Label
--+        {
--+            get;
--+        }
--+
--+        TargetAddress Address
--+        {
--+            get;
--+        }
--+
--+        int InstructionSize
--+        {
--+            get;
--+        }
--+
--+        string Text
--+        {
--+            get;
--+        }
--+    }
--+
-- 	public interface IServerThread
-- 	{
-- 		int ID
--@@ -146,4 +179,70 @@
-- 			get;
-- 		}
-- 	}
--+
--+    [Serializable]
--+    public struct TargetAddress
--+    {
--+        public readonly ulong Address;
--+
--+        public TargetAddress (ulong address)
--+        {
--+            this.Address = address;
--+        }
--+
--+        public TargetAddress (long address)
--+        {
--+            unchecked
--+            {
--+                this.Address =  (ulong) address;
--+            }
--+        }
--+
--+		public override string ToString ()
--+		{
--+            unchecked
--+            {
--+                long address = (long) Address;
--+                return String.Format ("0x{0}", FormatAddress (address));
--+            }
--+		}
--+
--+		public static string FormatAddress (long address)
--+		{
--+			int bits = 8;
--+			string saddr = address.ToString ("x");
--+			for (int i = saddr.Length; i < bits; i++)
--+				saddr = "0" + saddr;
--+			return saddr;
--+		}
--+
--+		public int CompareTo (object obj)
--+		{
--+			TargetAddress addr = (TargetAddress) obj;
--+
--+			if (Address < addr.Address)
--+				return -1;
--+			else if (Address > addr.Address)
--+				return 1;
--+			else
--+				return 0;
--+		}
--+
--+		public override bool Equals (object o)
--+		{
--+			if (o == null || !(o is TargetAddress))
--+				return false;
--+
--+			TargetAddress b = (TargetAddress)o;
--+			return Address == b.Address;
--+		}
--+
--+		public override int GetHashCode ()
--+		{
--+            unchecked
--+            {
--+                return (int) Address;
--+            }
--+		}
--+    }
-- }
--Index: Mono.VisualStudio.Debugger/MemoryAddress.cs
--===================================================================
----- Mono.VisualStudio.Debugger/MemoryAddress.cs	(revision 110947)
--+++ Mono.VisualStudio.Debugger/MemoryAddress.cs	(working copy)
--@@ -1,184 +1,189 @@
---using System;
---using System.Collections.Generic;
---using System.Text;
---using Microsoft.VisualStudio.Debugger.Interop;
---
---namespace Mono.VisualStudio.Debugger
---{
---    // And implementation of IDebugCodeContext2 and IDebugMemoryContext2. 
---    // IDebugMemoryContext2 represents a position in the address space of the machine running the program being debugged.
---    // IDebugCodeContext2 represents the starting position of a code instruction. 
---    // For most run-time architectures today, a code context can be thought of as an address in a program's execution stream.
---    class AD7MemoryAddress : IDebugCodeContext2
---    {
---        readonly Engine m_engine;
---        readonly ulong m_address;
---        IDebugDocumentContext2 m_documentContext;
---        
---        public AD7MemoryAddress(Engine engine, ulong address)
---        {
---            m_engine = engine;
---            m_address = address;
---        }
---
---        public void SetDocumentContext(IDebugDocumentContext2 docContext)
---        {
---            m_documentContext = docContext;
---        }
---
---        #region IDebugMemoryContext2 Members
---
---        // Adds a specified value to the current context's address to create a new context.
---        public int Add(ulong dwCount, out IDebugMemoryContext2 newAddress)
---        {
---            newAddress = new AD7MemoryAddress(m_engine, (uint)dwCount + m_address);
---            return COM.S_OK;
---        }
---
---        // Compares the memory context to each context in the given array in the manner indicated by compare flags, 
---        // returning an index of the first context that matches.
---        public int Compare(uint uContextCompare, IDebugMemoryContext2[] compareToItems, uint compareToLength, out uint foundIndex)
---        {
---            foundIndex = uint.MaxValue;
---
---            try
---            {
---                enum_CONTEXT_COMPARE contextCompare = (enum_CONTEXT_COMPARE)uContextCompare;
---
---                for (uint c = 0; c < compareToLength; c++)
---                {
---                    AD7MemoryAddress compareTo = compareToItems[c] as AD7MemoryAddress;
---                    if (compareTo == null)
---                    {
---                        continue;
---                    }
---
---                    if (!Engine.ReferenceEquals(this.m_engine, compareTo.m_engine))
---                    {
---                        continue;
---                    }
---
---                    bool result;
---
---                    switch (contextCompare)
---                    {
---                        case enum_CONTEXT_COMPARE.CONTEXT_EQUAL:
---                            result = (this.m_address == compareTo.m_address);
---                            break;
---
---                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN:
---                            result = (this.m_address < compareTo.m_address);
---                            break;
---
---                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN:
---                            result = (this.m_address > compareTo.m_address);
---                            break;
---
---                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN_OR_EQUAL:
---                            result = (this.m_address <= compareTo.m_address);
---                            break;
---
---                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN_OR_EQUAL:
---                            result = (this.m_address >= compareTo.m_address);
---                            break;
---
---                        // The sample debug engine doesn't understand scopes or functions
---                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_SCOPE:
---                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_FUNCTION:
---                            result = (this.m_address == compareTo.m_address);
---                            break;
---
---                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_PROCESS:
---                            result = true;
---                            break;
---
---                        default:
---                            // A new comparison was invented that we don't support
---                            return COM.E_NOTIMPL;
---                    }
---
---                    if (result)
---                    {
---                        foundIndex = c;
---                        return COM.S_OK;
---                    }
---                }
---
---                return COM.S_FALSE;
---            }
---                      catch (Exception e)
---            {
---                return Utils.UnexpectedException(e);
---            }
---        }
---
---        // Gets information that describes this context.
---        public int GetInfo(uint dwFields, CONTEXT_INFO[] pinfo)
---        {           
---            try
---            {
---                pinfo[0].dwFields = 0;
---
---                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS) != 0)
---                {
---                    pinfo[0].bstrAddress = m_address.ToString();
---                    pinfo[0].dwFields |= (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS;
---                }
---
---                // Fields not supported by the sample
---                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSOFFSET) != 0){}
---                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE) != 0){}
---                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_MODULEURL) != 0){}
---                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTION) != 0) {}
---                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTIONOFFSET) != 0) {}
---
---                return COM.S_OK;
---            }
---            catch (Exception e)
---            {
---                return Utils.UnexpectedException(e);
---            }
---        }
---
---        // Gets the user-displayable name for this context
---        // This is not supported by the sample engine.
---        public int GetName(out string pbstrName)
---        {
---            throw new Exception("The method or operation is not implemented.");
---        }
---
---        // Subtracts a specified value from the current context's address to create a new context.
---        public int Subtract(ulong dwCount, out IDebugMemoryContext2 ppMemCxt)
---        {
---            ppMemCxt = new AD7MemoryAddress(m_engine, (uint)dwCount - m_address);
---            return COM.S_OK;
---        }
---
---        #endregion
---
---        #region IDebugCodeContext2 Members
---
---        // Gets the document context for this code-context
---        public int GetDocumentContext(out IDebugDocumentContext2 ppSrcCxt)
---        {
---            ppSrcCxt = m_documentContext;
---            return COM.S_OK;
---        }
---
---        // Gets the language information for this code context.
---        public int GetLanguageInfo(ref string pbstrLanguage, ref Guid pguidLanguage)
---        {
---            if (m_documentContext != null)
---            {
---                m_documentContext.GetLanguageInfo(ref pbstrLanguage, ref pguidLanguage);
---                return COM.S_OK;
---            }
---            else
---            {
---                return COM.S_FALSE;
---            }
---        }
---
---        #endregion
---    }
---}
--+using System;
--+using System.Collections.Generic;
--+using System.Text;
--+using Microsoft.VisualStudio.Debugger.Interop;
--+
--+namespace Mono.VisualStudio.Debugger
--+{
--+    // And implementation of IDebugCodeContext2 and IDebugMemoryContext2. 
--+    // IDebugMemoryContext2 represents a position in the address space of the machine running the program being debugged.
--+    // IDebugCodeContext2 represents the starting position of a code instruction. 
--+    // For most run-time architectures today, a code context can be thought of as an address in a program's execution stream.
--+    class AD7MemoryAddress : IDebugCodeContext2
--+    {
--+        readonly Engine m_engine;
--+        readonly ulong m_address;
--+        IDebugDocumentContext2 m_documentContext;
--+        
--+        public AD7MemoryAddress(Engine engine, ulong address)
--+        {
--+            m_engine = engine;
--+            m_address = address;
--+        }
--+
--+        public ulong Address
--+        {
--+            get { return m_address; }
--+        }
--+
--+        public void SetDocumentContext(IDebugDocumentContext2 docContext)
--+        {
--+            m_documentContext = docContext;
--+        }
--+
--+        #region IDebugMemoryContext2 Members
--+
--+        // Adds a specified value to the current context's address to create a new context.
--+        public int Add(ulong dwCount, out IDebugMemoryContext2 newAddress)
--+        {
--+            newAddress = new AD7MemoryAddress(m_engine, (uint)dwCount + m_address);
--+            return COM.S_OK;
--+        }
--+
--+        // Compares the memory context to each context in the given array in the manner indicated by compare flags, 
--+        // returning an index of the first context that matches.
--+        public int Compare(uint uContextCompare, IDebugMemoryContext2[] compareToItems, uint compareToLength, out uint foundIndex)
--+        {
--+            foundIndex = uint.MaxValue;
--+
--+            try
--+            {
--+                enum_CONTEXT_COMPARE contextCompare = (enum_CONTEXT_COMPARE)uContextCompare;
--+
--+                for (uint c = 0; c < compareToLength; c++)
--+                {
--+                    AD7MemoryAddress compareTo = compareToItems[c] as AD7MemoryAddress;
--+                    if (compareTo == null)
--+                    {
--+                        continue;
--+                    }
--+
--+                    if (!Engine.ReferenceEquals(this.m_engine, compareTo.m_engine))
--+                    {
--+                        continue;
--+                    }
--+
--+                    bool result;
--+
--+                    switch (contextCompare)
--+                    {
--+                        case enum_CONTEXT_COMPARE.CONTEXT_EQUAL:
--+                            result = (this.m_address == compareTo.m_address);
--+                            break;
--+
--+                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN:
--+                            result = (this.m_address < compareTo.m_address);
--+                            break;
--+
--+                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN:
--+                            result = (this.m_address > compareTo.m_address);
--+                            break;
--+
--+                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN_OR_EQUAL:
--+                            result = (this.m_address <= compareTo.m_address);
--+                            break;
--+
--+                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN_OR_EQUAL:
--+                            result = (this.m_address >= compareTo.m_address);
--+                            break;
--+
--+                        // The sample debug engine doesn't understand scopes or functions
--+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_SCOPE:
--+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_FUNCTION:
--+                            result = (this.m_address == compareTo.m_address);
--+                            break;
--+
--+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_PROCESS:
--+                            result = true;
--+                            break;
--+
--+                        default:
--+                            // A new comparison was invented that we don't support
--+                            return COM.E_NOTIMPL;
--+                    }
--+
--+                    if (result)
--+                    {
--+                        foundIndex = c;
--+                        return COM.S_OK;
--+                    }
--+                }
--+
--+                return COM.S_FALSE;
--+            }
--+                      catch (Exception e)
--+            {
--+                return Utils.UnexpectedException(e);
--+            }
--+        }
--+
--+        // Gets information that describes this context.
--+        public int GetInfo(uint dwFields, CONTEXT_INFO[] pinfo)
--+        {           
--+            try
--+            {
--+                pinfo[0].dwFields = 0;
--+
--+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS) != 0)
--+                {
--+                    pinfo[0].bstrAddress = m_address.ToString();
--+                    pinfo[0].dwFields |= (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS;
--+                }
--+
--+                // Fields not supported by the sample
--+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSOFFSET) != 0){}
--+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE) != 0){}
--+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_MODULEURL) != 0){}
--+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTION) != 0) {}
--+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTIONOFFSET) != 0) {}
--+
--+                return COM.S_OK;
--+            }
--+            catch (Exception e)
--+            {
--+                return Utils.UnexpectedException(e);
--+            }
--+        }
--+
--+        // Gets the user-displayable name for this context
--+        // This is not supported by the sample engine.
--+        public int GetName(out string pbstrName)
--+        {
--+            throw new Exception("The method or operation is not implemented.");
--+        }
--+
--+        // Subtracts a specified value from the current context's address to create a new context.
--+        public int Subtract(ulong dwCount, out IDebugMemoryContext2 ppMemCxt)
--+        {
--+            ppMemCxt = new AD7MemoryAddress(m_engine, (uint)dwCount - m_address);
--+            return COM.S_OK;
--+        }
--+
--+        #endregion
--+
--+        #region IDebugCodeContext2 Members
--+
--+        // Gets the document context for this code-context
--+        public int GetDocumentContext(out IDebugDocumentContext2 ppSrcCxt)
--+        {
--+            ppSrcCxt = m_documentContext;
--+            return COM.S_OK;
--+        }
--+
--+        // Gets the language information for this code context.
--+        public int GetLanguageInfo(ref string pbstrLanguage, ref Guid pguidLanguage)
--+        {
--+            if (m_documentContext != null)
--+            {
--+                m_documentContext.GetLanguageInfo(ref pbstrLanguage, ref pguidLanguage);
--+                return COM.S_OK;
--+            }
--+            else
--+            {
--+                return COM.S_FALSE;
--+            }
--+        }
--+
--+        #endregion
--+    }
--+}
--Index: Mono.VisualStudio.Debugger/DebuggerController.cs
--===================================================================
----- Mono.VisualStudio.Debugger/DebuggerController.cs	(revision 110947)
--+++ Mono.VisualStudio.Debugger/DebuggerController.cs	(working copy)
--@@ -75,7 +75,7 @@
-- 
-- 		public void Shutdown ()
-- 		{
---			UriBuilder target = new UriBuilder (BaseURL + "/shutdown");
--+			UriBuilder target = new UriBuilder (BaseURL + "/shwwutdown");
-- 			target.Query = "foo=bar";
-- 			Post (target.ToString ());
-- 		}
--Index: Mono.VisualStudio.Debugger/Thread.cs
--===================================================================
----- Mono.VisualStudio.Debugger/Thread.cs	(revision 111699)
--+++ Mono.VisualStudio.Debugger/Thread.cs	(working copy)
--@@ -60,6 +60,7 @@
--             {
--                 StackFrame frame = new StackFrame (Process.Engine, server_frames[i]);
--                 frame.SetFrameInfo (dwFieldSpec, out array[i]);
--+                Utils.Message ("ENUM FRAME INFO: {0} {1:x}", i, frame.Frame.Address);
--             }
-- 
--             ppEnum = new AD7FrameInfoEnum (array);
--Index: Mono.VisualStudio.Debugger/Process.cs
--===================================================================
----- Mono.VisualStudio.Debugger/Process.cs	(revision 111699)
--+++ Mono.VisualStudio.Debugger/Process.cs	(working copy)
--@@ -252,6 +252,180 @@
-- 			return COM.S_OK;
-- 		}
-- 
--+        public int GetDisassemblyStream (uint scope, IDebugCodeContext2 context, out IDebugDisassemblyStream2 stream)
--+        {
--+            TargetAddress address = new TargetAddress (((AD7MemoryAddress) context).Address);
--+            Utils.Message ("GET DISASSEMBLY STREAM: {0:x} {1:x}", scope, address);
--+            IAssemblerMethod method = ServerProcess.DisassembleMethod (address);
--+            stream = new DisassemblyStream (this, address, method);
--+            return COM.S_OK;
--+        }
--+
--+        protected class DisassemblyStream : IDebugDisassemblyStream2
--+        {
--+            public Process Process
--+            {
--+                get;
--+                private set;
--+            }
--+
--+            public TargetAddress StartAddress
--+            {
--+                get; private set;
--+            }
--+
--+            public IAssemblerMethod AssemblerMethod
--+            {
--+                get;
--+                private set;
--+            }
--+
--+            public DisassemblyStream (Process process, TargetAddress address, IAssemblerMethod method)
--+            {
--+                this.StartAddress = address;
--+                this.Process = process;
--+                this.AssemblerMethod = method;
--+            }
--+
--+            #region IDebugDisassemblyStream2 Members
--+
--+            int IDebugDisassemblyStream2.GetCodeContext (ulong uCodeLocationId, out IDebugCodeContext2 ppCodeContext)
--+            {
--+                Utils.Message ("GET CODE CONTEXT: {0:x}", uCodeLocationId);
--+                ppCodeContext = new AD7MemoryAddress (Process.Engine, StartAddress.Address);
--+                return COM.S_OK;
--+            }
--+
--+            int IDebugDisassemblyStream2.GetCodeLocationId (IDebugCodeContext2 pCodeContext, out ulong puCodeLocationId)
--+            {
--+                puCodeLocationId = ((AD7MemoryAddress) pCodeContext).Address;
--+                return COM.S_OK;
--+            }
--+
--+            int IDebugDisassemblyStream2.GetCurrentLocation (out ulong puCodeLocationId)
--+            {
--+                throw new NotImplementedException ();
--+            }
--+
--+            int IDebugDisassemblyStream2.GetDocument (string bstrDocumentUrl, out IDebugDocument2 ppDocument)
--+            {
--+                ppDocument = new DebugDocument ();
--+                return COM.S_OK;
--+            }
--+
--+            int IDebugDisassemblyStream2.GetScope (out uint pdwScope)
--+            {
--+                throw new NotImplementedException ();
--+            }
--+
--+            int IDebugDisassemblyStream2.GetSize (out ulong pnSize)
--+            {
--+                pnSize = 1;
--+                return COM.S_OK;
--+            }
--+
--+            int last_line = 0;
--+
--+            int IDebugDisassemblyStream2.Read (uint dwInstructions, uint dwFields, out uint pdwInstructionsRead, DisassemblyData[] prgDisassembly)
--+            {
--+                pdwInstructionsRead = 0;
--+
--+                if (last_line == 0)
--+                {
--+                    IAssemblerLine line = AssemblerMethod.Lines [0];
--+                    prgDisassembly[0].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
--+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
--+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL |
--+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
--+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODEBYTES);
--+                    prgDisassembly[0].bstrAddress = line.Address.ToString ();
--+                    prgDisassembly[0].bstrCodeBytes = "0x90";
--+                    prgDisassembly[0].bstrOpcode = line.Text;
--+                    prgDisassembly[1].dwByteOffset = 0;
--+                    prgDisassembly[0].uCodeLocationId = line.Address.Address;
--+                    // prgDisassembly[0].bstrDocumentUrl = "monkey";
--+                    prgDisassembly[0].bstrDocumentUrl = "file://C:\\Work\\ConsoleApplication2\\ConsoleApplication2\\Program.cs";
--+                    prgDisassembly[0].posBeg.dwLine = 0;
--+                    prgDisassembly[0].posBeg.dwColumn = 0;
--+                    prgDisassembly[0].posEnd.dwLine = 11;
--+                    prgDisassembly[0].posEnd.dwColumn = uint.MaxValue;
--+                    prgDisassembly[0].dwFlags = (uint) (enum_DISASSEMBLY_FLAGS.DF_DOCUMENTCHANGE | enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
--+
--+                    pdwInstructionsRead++;
--+                    last_line++;
--+                }
--+                else
--+                {
--+                    return COM.S_FALSE;
--+                }
--+
--+                prgDisassembly[1].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODEBYTES | enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPERANDS | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_SYMBOL |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
--+                prgDisassembly[1].bstrAddress = "second-line";
--+                prgDisassembly[1].bstrCodeBytes = "0xcc";
--+                prgDisassembly[1].bstrOpcode = "monkey";
--+                prgDisassembly[1].bstrOperands = "boston";
--+                prgDisassembly[1].dwByteOffset = 0;
--+                prgDisassembly[1].bstrSymbol = "Test";
--+                prgDisassembly[1].uCodeLocationId = StartAddress.Address + 2;
--+                prgDisassembly[1].bstrDocumentUrl = null;
--+                prgDisassembly[1].posBeg.dwLine = 12;
--+                prgDisassembly[1].posBeg.dwColumn = 0;
--+                prgDisassembly[1].posEnd.dwLine = 12;
--+                prgDisassembly[1].posEnd.dwColumn = uint.MaxValue;
--+                prgDisassembly[1].dwFlags = (uint) enum_DISASSEMBLY_FLAGS.DF_HASSOURCE;
--+
--+                prgDisassembly[2].dwFields = (uint) (
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
--+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
--+                
--+                prgDisassembly[2].dwByteOffset = 0;
--+                prgDisassembly[2].uCodeLocationId = StartAddress.Address + 3;
--+                prgDisassembly[2].bstrDocumentUrl = null;
--+                prgDisassembly[2].posBeg.dwLine = 13;
--+                prgDisassembly[2].posBeg.dwColumn = 0;
--+                prgDisassembly[2].posEnd.dwLine = 21;
--+                prgDisassembly[2].posEnd.dwColumn = uint.MaxValue;
--+                prgDisassembly[2].dwFlags = (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE | enum_DISASSEMBLY_FLAGS.DF_DISABLED);
--+
--+                pdwInstructionsRead = 3;
--+                return COM.S_OK;
--+            }
--+
--+            int IDebugDisassemblyStream2.Seek (uint dwSeekStart, IDebugCodeContext2 pCodeContext, ulong uCodeLocationId, long iInstructions)
--+            {
--+                string addr = pCodeContext != null ? String.Format ("{0:x}", ((AD7MemoryAddress) pCodeContext).Address) : "null";
--+                Utils.Message ("SEEK: {0:x} {1:x} {2:x} {3:x}", dwSeekStart, addr, uCodeLocationId, iInstructions);
--+                return COM.S_OK;
--+            }
--+
--+            #endregion
--+        }
--+
--+        protected class DebugDocument : IDebugDocument2
--+        {
--+            #region IDebugDocument2 Members
--+
--+            int IDebugDocument2.GetDocumentClassId (out Guid pclsid)
--+            {
--+                throw new NotImplementedException ();
--+            }
--+
--+            int IDebugDocument2.GetName (uint gnType, out string pbstrFileName)
--+            {
--+                pbstrFileName = "monkey";
--+                return COM.S_OK;
--+            }
--+
--+            #endregion
--+        }
--+
-- 		#endregion
-- 
-- 		#region IDebugProcess2 Members
--@@ -383,11 +557,6 @@
-- 			throw new NotImplementedException ();
-- 		}
-- 
---		int IDebugProgram2.GetDisassemblyStream (uint dwScope, IDebugCodeContext2 pCodeContext, out IDebugDisassemblyStream2 ppDisassemblyStream)
---		{
---			throw new NotImplementedException ();
---		}
---
-- 		int IDebugProgram2.GetENCUpdate (out object ppUpdate)
-- 		{
-- 			throw new NotImplementedException ();
--Index: Server/ServerThread.cs
--===================================================================
----- Server/ServerThread.cs	(revision 111634)
--+++ Server/ServerThread.cs	(working copy)
--@@ -66,6 +66,7 @@
-- 
-- 	public ServerStackFrame GetFrame ()
-- 	{
--+		Thread.CurrentFrame.Method.LineNumberTable.DumpLineNumbers ();
-- 		return new ServerStackFrame (this, Thread.CurrentFrame);
-- 	}
-- 
--Index: Server/ServerProcess.cs
--===================================================================
----- Server/ServerProcess.cs	(revision 111699)
--+++ Server/ServerProcess.cs	(working copy)
--@@ -109,5 +109,73 @@
-- 			break;
-- 		}
-- 	}
--+
--+	public IAssemblerMethod DisassembleMethod (TargetAddress arg)
--+	{
--+		MDB.TargetAddress address = new MDB.TargetAddress (
--+			MDB.AddressDomain.Global, (long) arg.Address);
--+		Console.WriteLine ("DISASSEMBLE METHOD: {0:x} {1}", address, MainThread.Thread);
--+
--+		MDB.Method method = Process.Lookup (address);
--+		Console.WriteLine ("DISASSEMBLE METHOD #1: {0}", method);
--+		if (method == null)
--+			return null;
--+
--+		MDB.AssemblerMethod asm = MainThread.Thread.DisassembleMethod (method);
--+		Console.WriteLine ("DISASSEMBLE METHOD #2: {0}", asm);
--+		if (asm == null)
--+			return null;
--+
--+		return new AssemblerMethod (asm);
--+	}
--+
--+	protected class AssemblerMethod : MarshalByRefObject, IAssemblerMethod
--+	{
--+		public MDB.AssemblerMethod Assembler {
--+			get; private set;
--+		}
--+
--+		public AssemblerMethod (MDB.AssemblerMethod asm)
--+		{
--+			this.Assembler = asm;
--+		}
--+
--+		public IAssemblerLine[] Lines {
--+			get {
--+				IAssemblerLine[] lines = new IAssemblerLine [Assembler.Lines.Length];
--+				for (int i = 0; i < lines.Length; i++)
--+					lines [i] = new AssemblerLine (Assembler.Lines [i]);
--+				return lines;
--+			}
--+		}
--+	}
--+
--+	protected class AssemblerLine : MarshalByRefObject, IAssemblerLine
--+	{
--+		public MDB.AssemblerLine Line {
--+			get; private set;
--+		}
--+
--+		public AssemblerLine (MDB.AssemblerLine line)
--+		{
--+			this.Line = line;
--+		}
--+
--+		string IAssemblerLine.Label {
--+			get { return Line.Label; }
--+		}
--+
--+		TargetAddress IAssemblerLine.Address {
--+			get { return new TargetAddress (Line.Address.Address); }
--+		}
--+
--+		int IAssemblerLine.InstructionSize {
--+			get { return Line.InstructionSize; }
--+		}
--+
--+		string IAssemblerLine.Text {
--+			get { return Line.Text; }
--+		}
--+	}
-- }
-- }
--Index: RegisterDebugger/RegisterDebugger.cs
--===================================================================
----- RegisterDebugger/RegisterDebugger.cs	(revision 111331)
--+++ RegisterDebugger/RegisterDebugger.cs	(working copy)
--@@ -85,6 +85,7 @@
--             mono_engine.SetValue ("AutoselectPriority", 4);
--             mono_engine.SetValue ("Attach", 1);     // Supports attaching
--             mono_engine.SetValue ("AddressBP", 1);  // Supports address-based breakpoints
--+            mono_engine.SetValue ("Disassembly", 1);
-- 			mono_engine.SetValue ("RemotingDebugging", 1);
-- 
-- 			//
-Index: RemotingContract/Contract.cs
-===================================================================
---- RemotingContract/Contract.cs	(revision 111699)
-+++ RemotingContract/Contract.cs	(working copy)
-@@ -84,8 +84,59 @@
-          * Stop all threads in the target.
-          */
-         void Stop ();
-+
-+        IAssemblerMethod DisassembleMethod (TargetAddress address);
- 	}
- 
-+    public interface IAssemblerMethod
-+    {
-+        string SourceFileName
-+        {
-+            get;
-+        }
-+
-+        IAssemblerLine[] Lines
-+        {
-+            get;
-+        }
-+    }
-+
-+    public interface IAssemblerLine
-+    {
-+        string Label
-+        {
-+            get;
-+        }
-+
-+        TargetAddress Address
-+        {
-+            get;
-+        }
-+
-+        int InstructionSize
-+        {
-+            get;
-+        }
-+
-+        string Text
-+        {
-+            get;
-+        }
-+
-+        bool HasSource
-+        {
-+            get;
-+        }
-+
-+        uint SourceRow {
-+            get;
-+        }
-+
-+        uint SourceOffset {
-+            get;
-+        }
-+    }
-+
- 	public interface IServerThread
- 	{
- 		int ID
-@@ -146,4 +197,70 @@
- 			get;
- 		}
- 	}
-+
-+    [Serializable]
-+    public struct TargetAddress
-+    {
-+        public readonly ulong Address;
-+
-+        public TargetAddress (ulong address)
-+        {
-+            this.Address = address;
-+        }
-+
-+        public TargetAddress (long address)
-+        {
-+            unchecked
-+            {
-+                this.Address =  (ulong) address;
-+            }
-+        }
-+
-+		public override string ToString ()
-+		{
-+            unchecked
-+            {
-+                long address = (long) Address;
-+                return String.Format ("0x{0}", FormatAddress (address));
-+            }
-+		}
-+
-+		public static string FormatAddress (long address)
-+		{
-+			int bits = 8;
-+			string saddr = address.ToString ("x");
-+			for (int i = saddr.Length; i < bits; i++)
-+				saddr = "0" + saddr;
-+			return saddr;
-+		}
-+
-+		public int CompareTo (object obj)
-+		{
-+			TargetAddress addr = (TargetAddress) obj;
-+
-+			if (Address < addr.Address)
-+				return -1;
-+			else if (Address > addr.Address)
-+				return 1;
-+			else
-+				return 0;
-+		}
-+
-+		public override bool Equals (object o)
-+		{
-+			if (o == null || !(o is TargetAddress))
-+				return false;
-+
-+			TargetAddress b = (TargetAddress)o;
-+			return Address == b.Address;
-+		}
-+
-+		public override int GetHashCode ()
-+		{
-+            unchecked
-+            {
-+                return (int) Address;
-+            }
-+		}
-+    }
- }
-Index: Mono.VisualStudio.Debugger/MemoryAddress.cs
-===================================================================
---- Mono.VisualStudio.Debugger/MemoryAddress.cs	(revision 110947)
-+++ Mono.VisualStudio.Debugger/MemoryAddress.cs	(working copy)
-@@ -1,184 +1,189 @@
--using System;
--using System.Collections.Generic;
--using System.Text;
--using Microsoft.VisualStudio.Debugger.Interop;
--
--namespace Mono.VisualStudio.Debugger
--{
--    // And implementation of IDebugCodeContext2 and IDebugMemoryContext2. 
--    // IDebugMemoryContext2 represents a position in the address space of the machine running the program being debugged.
--    // IDebugCodeContext2 represents the starting position of a code instruction. 
--    // For most run-time architectures today, a code context can be thought of as an address in a program's execution stream.
--    class AD7MemoryAddress : IDebugCodeContext2
--    {
--        readonly Engine m_engine;
--        readonly ulong m_address;
--        IDebugDocumentContext2 m_documentContext;
--        
--        public AD7MemoryAddress(Engine engine, ulong address)
--        {
--            m_engine = engine;
--            m_address = address;
--        }
--
--        public void SetDocumentContext(IDebugDocumentContext2 docContext)
--        {
--            m_documentContext = docContext;
--        }
--
--        #region IDebugMemoryContext2 Members
--
--        // Adds a specified value to the current context's address to create a new context.
--        public int Add(ulong dwCount, out IDebugMemoryContext2 newAddress)
--        {
--            newAddress = new AD7MemoryAddress(m_engine, (uint)dwCount + m_address);
--            return COM.S_OK;
--        }
--
--        // Compares the memory context to each context in the given array in the manner indicated by compare flags, 
--        // returning an index of the first context that matches.
--        public int Compare(uint uContextCompare, IDebugMemoryContext2[] compareToItems, uint compareToLength, out uint foundIndex)
--        {
--            foundIndex = uint.MaxValue;
--
--            try
--            {
--                enum_CONTEXT_COMPARE contextCompare = (enum_CONTEXT_COMPARE)uContextCompare;
--
--                for (uint c = 0; c < compareToLength; c++)
--                {
--                    AD7MemoryAddress compareTo = compareToItems[c] as AD7MemoryAddress;
--                    if (compareTo == null)
--                    {
--                        continue;
--                    }
--
--                    if (!Engine.ReferenceEquals(this.m_engine, compareTo.m_engine))
--                    {
--                        continue;
--                    }
--
--                    bool result;
--
--                    switch (contextCompare)
--                    {
--                        case enum_CONTEXT_COMPARE.CONTEXT_EQUAL:
--                            result = (this.m_address == compareTo.m_address);
--                            break;
--
--                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN:
--                            result = (this.m_address < compareTo.m_address);
--                            break;
--
--                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN:
--                            result = (this.m_address > compareTo.m_address);
--                            break;
--
--                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN_OR_EQUAL:
--                            result = (this.m_address <= compareTo.m_address);
--                            break;
--
--                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN_OR_EQUAL:
--                            result = (this.m_address >= compareTo.m_address);
--                            break;
--
--                        // The sample debug engine doesn't understand scopes or functions
--                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_SCOPE:
--                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_FUNCTION:
--                            result = (this.m_address == compareTo.m_address);
--                            break;
--
--                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_PROCESS:
--                            result = true;
--                            break;
--
--                        default:
--                            // A new comparison was invented that we don't support
--                            return COM.E_NOTIMPL;
--                    }
--
--                    if (result)
--                    {
--                        foundIndex = c;
--                        return COM.S_OK;
--                    }
--                }
--
--                return COM.S_FALSE;
--            }
--                      catch (Exception e)
--            {
--                return Utils.UnexpectedException(e);
--            }
--        }
--
--        // Gets information that describes this context.
--        public int GetInfo(uint dwFields, CONTEXT_INFO[] pinfo)
--        {           
--            try
--            {
--                pinfo[0].dwFields = 0;
--
--                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS) != 0)
--                {
--                    pinfo[0].bstrAddress = m_address.ToString();
--                    pinfo[0].dwFields |= (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS;
--                }
--
--                // Fields not supported by the sample
--                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSOFFSET) != 0){}
--                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE) != 0){}
--                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_MODULEURL) != 0){}
--                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTION) != 0) {}
--                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTIONOFFSET) != 0) {}
--
--                return COM.S_OK;
--            }
--            catch (Exception e)
--            {
--                return Utils.UnexpectedException(e);
--            }
--        }
--
--        // Gets the user-displayable name for this context
--        // This is not supported by the sample engine.
--        public int GetName(out string pbstrName)
--        {
--            throw new Exception("The method or operation is not implemented.");
--        }
--
--        // Subtracts a specified value from the current context's address to create a new context.
--        public int Subtract(ulong dwCount, out IDebugMemoryContext2 ppMemCxt)
--        {
--            ppMemCxt = new AD7MemoryAddress(m_engine, (uint)dwCount - m_address);
--            return COM.S_OK;
--        }
--
--        #endregion
--
--        #region IDebugCodeContext2 Members
--
--        // Gets the document context for this code-context
--        public int GetDocumentContext(out IDebugDocumentContext2 ppSrcCxt)
--        {
--            ppSrcCxt = m_documentContext;
--            return COM.S_OK;
--        }
--
--        // Gets the language information for this code context.
--        public int GetLanguageInfo(ref string pbstrLanguage, ref Guid pguidLanguage)
--        {
--            if (m_documentContext != null)
--            {
--                m_documentContext.GetLanguageInfo(ref pbstrLanguage, ref pguidLanguage);
--                return COM.S_OK;
--            }
--            else
--            {
--                return COM.S_FALSE;
--            }
--        }
--
--        #endregion
--    }
--}
-+using System;
-+using System.Collections.Generic;
-+using System.Text;
-+using Microsoft.VisualStudio.Debugger.Interop;
-+
-+namespace Mono.VisualStudio.Debugger
-+{
-+    // And implementation of IDebugCodeContext2 and IDebugMemoryContext2. 
-+    // IDebugMemoryContext2 represents a position in the address space of the machine running the program being debugged.
-+    // IDebugCodeContext2 represents the starting position of a code instruction. 
-+    // For most run-time architectures today, a code context can be thought of as an address in a program's execution stream.
-+    class AD7MemoryAddress : IDebugCodeContext2
-+    {
-+        readonly Engine m_engine;
-+        readonly ulong m_address;
-+        IDebugDocumentContext2 m_documentContext;
-+        
-+        public AD7MemoryAddress(Engine engine, ulong address)
-+        {
-+            m_engine = engine;
-+            m_address = address;
-+        }
-+
-+        public ulong Address
-+        {
-+            get { return m_address; }
-+        }
-+
-+        public void SetDocumentContext(IDebugDocumentContext2 docContext)
-+        {
-+            m_documentContext = docContext;
-+        }
-+
-+        #region IDebugMemoryContext2 Members
-+
-+        // Adds a specified value to the current context's address to create a new context.
-+        public int Add(ulong dwCount, out IDebugMemoryContext2 newAddress)
-+        {
-+            newAddress = new AD7MemoryAddress(m_engine, (uint)dwCount + m_address);
-+            return COM.S_OK;
-+        }
-+
-+        // Compares the memory context to each context in the given array in the manner indicated by compare flags, 
-+        // returning an index of the first context that matches.
-+        public int Compare(uint uContextCompare, IDebugMemoryContext2[] compareToItems, uint compareToLength, out uint foundIndex)
-+        {
-+            foundIndex = uint.MaxValue;
-+
-+            try
-+            {
-+                enum_CONTEXT_COMPARE contextCompare = (enum_CONTEXT_COMPARE)uContextCompare;
-+
-+                for (uint c = 0; c < compareToLength; c++)
-+                {
-+                    AD7MemoryAddress compareTo = compareToItems[c] as AD7MemoryAddress;
-+                    if (compareTo == null)
-+                    {
-+                        continue;
-+                    }
-+
-+                    if (!Engine.ReferenceEquals(this.m_engine, compareTo.m_engine))
-+                    {
-+                        continue;
-+                    }
-+
-+                    bool result;
-+
-+                    switch (contextCompare)
-+                    {
-+                        case enum_CONTEXT_COMPARE.CONTEXT_EQUAL:
-+                            result = (this.m_address == compareTo.m_address);
-+                            break;
-+
-+                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN:
-+                            result = (this.m_address < compareTo.m_address);
-+                            break;
-+
-+                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN:
-+                            result = (this.m_address > compareTo.m_address);
-+                            break;
-+
-+                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN_OR_EQUAL:
-+                            result = (this.m_address <= compareTo.m_address);
-+                            break;
-+
-+                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN_OR_EQUAL:
-+                            result = (this.m_address >= compareTo.m_address);
-+                            break;
-+
-+                        // The sample debug engine doesn't understand scopes or functions
-+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_SCOPE:
-+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_FUNCTION:
-+                            result = (this.m_address == compareTo.m_address);
-+                            break;
-+
-+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_PROCESS:
-+                            result = true;
-+                            break;
-+
-+                        default:
-+                            // A new comparison was invented that we don't support
-+                            return COM.E_NOTIMPL;
-+                    }
-+
-+                    if (result)
-+                    {
-+                        foundIndex = c;
-+                        return COM.S_OK;
-+                    }
-+                }
-+
-+                return COM.S_FALSE;
-+            }
-+                      catch (Exception e)
-+            {
-+                return Utils.UnexpectedException(e);
-+            }
-+        }
-+
-+        // Gets information that describes this context.
-+        public int GetInfo(uint dwFields, CONTEXT_INFO[] pinfo)
-+        {           
-+            try
-+            {
-+                pinfo[0].dwFields = 0;
-+
-+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS) != 0)
-+                {
-+                    pinfo[0].bstrAddress = m_address.ToString();
-+                    pinfo[0].dwFields |= (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS;
-+                }
-+
-+                // Fields not supported by the sample
-+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSOFFSET) != 0){}
-+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE) != 0){}
-+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_MODULEURL) != 0){}
-+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTION) != 0) {}
-+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTIONOFFSET) != 0) {}
-+
-+                return COM.S_OK;
-+            }
-+            catch (Exception e)
-+            {
-+                return Utils.UnexpectedException(e);
-+            }
-+        }
-+
-+        // Gets the user-displayable name for this context
-+        // This is not supported by the sample engine.
-+        public int GetName(out string pbstrName)
-+        {
-+            throw new Exception("The method or operation is not implemented.");
-+        }
-+
-+        // Subtracts a specified value from the current context's address to create a new context.
-+        public int Subtract(ulong dwCount, out IDebugMemoryContext2 ppMemCxt)
-+        {
-+            ppMemCxt = new AD7MemoryAddress(m_engine, (uint)dwCount - m_address);
-+            return COM.S_OK;
-+        }
-+
-+        #endregion
-+
-+        #region IDebugCodeContext2 Members
-+
-+        // Gets the document context for this code-context
-+        public int GetDocumentContext(out IDebugDocumentContext2 ppSrcCxt)
-+        {
-+            ppSrcCxt = m_documentContext;
-+            return COM.S_OK;
-+        }
-+
-+        // Gets the language information for this code context.
-+        public int GetLanguageInfo(ref string pbstrLanguage, ref Guid pguidLanguage)
-+        {
-+            if (m_documentContext != null)
-+            {
-+                m_documentContext.GetLanguageInfo(ref pbstrLanguage, ref pguidLanguage);
-+                return COM.S_OK;
-+            }
-+            else
-+            {
-+                return COM.S_FALSE;
-+            }
-+        }
-+
-+        #endregion
-+    }
-+}
-Index: Mono.VisualStudio.Debugger/DebuggerController.cs
-===================================================================
---- Mono.VisualStudio.Debugger/DebuggerController.cs	(revision 110947)
-+++ Mono.VisualStudio.Debugger/DebuggerController.cs	(working copy)
-@@ -75,7 +75,7 @@
- 
- 		public void Shutdown ()
- 		{
--			UriBuilder target = new UriBuilder (BaseURL + "/shutdown");
-+			UriBuilder target = new UriBuilder (BaseURL + "/shwwutdown");
- 			target.Query = "foo=bar";
- 			Post (target.ToString ());
- 		}
-Index: Mono.VisualStudio.Debugger/Thread.cs
-===================================================================
---- Mono.VisualStudio.Debugger/Thread.cs	(revision 111699)
-+++ Mono.VisualStudio.Debugger/Thread.cs	(working copy)
-@@ -60,6 +60,7 @@
-             {
-                 StackFrame frame = new StackFrame (Process.Engine, server_frames[i]);
-                 frame.SetFrameInfo (dwFieldSpec, out array[i]);
-+                Utils.Message ("ENUM FRAME INFO: {0} {1:x}", i, frame.Frame.Address);
-             }
- 
-             ppEnum = new AD7FrameInfoEnum (array);
-Index: Mono.VisualStudio.Debugger/Process.cs
-===================================================================
---- Mono.VisualStudio.Debugger/Process.cs	(revision 111699)
-+++ Mono.VisualStudio.Debugger/Process.cs	(working copy)
-@@ -252,6 +252,284 @@
- 			return COM.S_OK;
- 		}
- 
-+        public int GetDisassemblyStream (uint scope, IDebugCodeContext2 context, out IDebugDisassemblyStream2 stream)
-+        {
-+            TargetAddress address = new TargetAddress (((AD7MemoryAddress) context).Address);
-+            Utils.Message ("GET DISASSEMBLY STREAM: {0:x} {1:x}", scope, address);
-+            IAssemblerMethod method = ServerProcess.DisassembleMethod (address);
-+            stream = new DisassemblyStream (this, address, method);
-+            return COM.S_OK;
-+        }
-+
-+        protected class DisassemblyStream : IDebugDisassemblyStream2
-+        {
-+            public Process Process
-+            {
-+                get;
-+                private set;
-+            }
-+
-+            public TargetAddress StartAddress
-+            {
-+                get; private set;
-+            }
-+
-+            public IAssemblerMethod AssemblerMethod
-+            {
-+                get;
-+                private set;
-+            }
-+
-+            public bool HasSource
-+            {
-+                get { return AssemblerMethod.SourceFileName != null; }
-+            }
-+
-+            public DisassemblyStream (Process process, TargetAddress address, IAssemblerMethod method)
-+            {
-+                this.StartAddress = address;
-+                this.Process = process;
-+                this.AssemblerMethod = method;
-+            }
-+
-+            #region IDebugDisassemblyStream2 Members
-+
-+            int IDebugDisassemblyStream2.GetCodeContext (ulong uCodeLocationId, out IDebugCodeContext2 ppCodeContext)
-+            {
-+                Utils.Message ("GET CODE CONTEXT: {0:x}", uCodeLocationId);
-+                // ppCodeContext = new AD7MemoryAddress (Process.Engine, StartAddress.Address);
-+                ppCodeContext = new AD7MemoryAddress (Process.Engine, uCodeLocationId);
-+                return COM.S_OK;
-+            }
-+
-+            int IDebugDisassemblyStream2.GetCodeLocationId (IDebugCodeContext2 pCodeContext, out ulong puCodeLocationId)
-+            {
-+                puCodeLocationId = ((AD7MemoryAddress) pCodeContext).Address;
-+                return COM.S_OK;
-+            }
-+
-+            int IDebugDisassemblyStream2.GetCurrentLocation (out ulong puCodeLocationId)
-+            {
-+                throw new NotImplementedException ();
-+            }
-+
-+            int IDebugDisassemblyStream2.GetDocument (string bstrDocumentUrl, out IDebugDocument2 ppDocument)
-+            {
-+                ppDocument = new DebugDocument ();
-+                return COM.S_OK;
-+            }
-+
-+            int IDebugDisassemblyStream2.GetScope (out uint pdwScope)
-+            {
-+                throw new NotImplementedException ();
-+            }
-+
-+            int IDebugDisassemblyStream2.GetSize (out ulong pnSize)
-+            {
-+                pnSize = 1;
-+                return COM.S_OK;
-+            }
-+
-+            int pos = 0;
-+            uint last_line = 0;
-+            TargetAddress last_address;
-+            bool done = false;
-+
-+            int IDebugDisassemblyStream2.Read (uint max_instructions, uint field, out uint num_read, DisassemblyData[] data)
-+            {
-+                num_read = 0;
-+
-+                Utils.Message ("READ: {0} {1} {2} {3}", max_instructions, pos, AssemblerMethod.Lines.Length, last_line);
-+
-+#if FIXME
-+                if (false && (pos == 0))
-+                {
-+                    IAssemblerLine line = AssemblerMethod.Lines [0];
-+                    data[0].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
-+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
-+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL |
-+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
-+                    data[0].bstrAddress = line.Address.ToString ();
-+                    data[0].bstrOpcode = line.Text;
-+                    data[0].dwByteOffset = 0;
-+                    data[0].uCodeLocationId = line.Address.Address;
-+                    data[0].bstrDocumentUrl = null;
-+                    data[0].dwFlags = 0;
-+
-+                    if (HasSource)
-+                    {
-+                        data[0].bstrDocumentUrl = AssemblerMethod.SourceFileName;
-+                        data[0].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL);
-+                        data[0].dwFlags |= (uint) (enum_DISASSEMBLY_FLAGS.DF_DOCUMENTCHANGE | enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
-+
-+                        if (line.HasSource && (line.SourceOffset == 0))
-+                        {
-+                            data[0].posBeg.dwLine = 0;
-+                            data[0].posBeg.dwColumn = 0;
-+                            data[0].posEnd.dwLine = line.SourceRow;
-+                            data[0].posEnd.dwColumn = uint.MaxValue;
-+                            data[0].dwByteOffset = line.SourceOffset;
-+                            data[0].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION);
-+                            data[0].dwFlags |= (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
-+                            last_line = line.SourceRow;
-+                        }
-+                    }
-+
-+                    last_address = line.Address;
-+
-+                    num_read++;
-+                    pos++;
-+                }
-+#endif
-+
-+                if (pos >= AssemblerMethod.Lines.Length)
-+                {
-+                    if (HasSource && !done)
-+                    {
-+                        data[0].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET |
-+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
-+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL |
-+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
-+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
-+
-+                        data[0].dwByteOffset = 0;
-+                        data[0].bstrDocumentUrl = AssemblerMethod.SourceFileName; 
-+                        data[0].uCodeLocationId = last_address.Address + 1;
-+                        data[0].posBeg.dwLine = last_line;
-+                        data[0].posBeg.dwColumn = 0;
-+                        data[0].posEnd.dwLine = uint.MaxValue;
-+                        data[0].posEnd.dwColumn = uint.MaxValue;
-+                        data[0].dwFlags = (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
-+                        num_read++;
-+                        done = true;
-+                        return COM.S_OK;
-+                    }
-+
-+                    return COM.S_FALSE;
-+                }
-+
-+                data[num_read].bstrSymbol = "RESTART!";
-+                data[num_read].dwFields |= (uint) enum_DISASSEMBLY_STREAM_FIELDS.DSF_SYMBOL;
-+
-+                while ((pos < AssemblerMethod.Lines.Length) && (num_read < max_instructions))
-+                {
-+                    IAssemblerLine line = AssemblerMethod.Lines[pos];
-+
-+                    data[num_read].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
-+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
-+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
-+                    data[num_read].bstrAddress = line.Address.ToString ();
-+                    data[num_read].bstrOpcode = line.Text;
-+                    data[num_read].dwByteOffset = 0;
-+                    data[num_read].uCodeLocationId = line.Address.Address;
-+                    data[num_read].bstrDocumentUrl = null;
-+                    data[num_read].dwFlags = 0;
-+
-+                    if (!HasSource) {
-+                        pos++;
-+                        num_read++;
-+                        continue;
-+                    }
-+
-+                    if (num_read == 0)
-+                    {
-+                        data[0].bstrDocumentUrl = AssemblerMethod.SourceFileName;
-+                        data[0].dwFields |= (uint) enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL;
-+                        if (pos == 0)
-+                            data[0].dwFlags |= (uint) enum_DISASSEMBLY_FLAGS.DF_DOCUMENTCHANGE;
-+                    }
-+
-+                    if (line.HasSource)
-+                    {
-+                        Utils.Message ("ASM: {0} {1} {2}", line.Address, last_line, line.SourceRow);
-+                        data[num_read].posBeg.dwLine = last_line;
-+                        data[num_read].posBeg.dwColumn = 0;
-+                        data[num_read].posEnd.dwLine = line.SourceRow - 1;
-+                        data[num_read].posEnd.dwColumn = uint.MaxValue;
-+                        data[num_read].dwByteOffset = line.SourceOffset;
-+                        if (true || (line.SourceOffset == 0))
-+                        {
-+                            data[num_read].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION);
-+                            data[num_read].dwFlags |= (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
-+                            last_line = line.SourceRow;
-+                        }
-+                    }
-+
-+                    pos++;
-+                    num_read++;
-+                }
-+
-+                return COM.S_OK;
-+
-+#if FIXME    
-+                data[1].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODEBYTES | enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPERANDS | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_SYMBOL |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
-+                data[1].bstrAddress = "second-line";
-+                data[1].bstrCodeBytes = "0xcc";
-+                data[1].bstrOpcode = "monkey";
-+                data[1].bstrOperands = "boston";
-+                data[1].dwByteOffset = 0;
-+                data[1].bstrSymbol = "Test";
-+                data[1].uCodeLocationId = StartAddress.Address + 2;
-+                data[1].bstrDocumentUrl = null;
-+                data[1].posBeg.dwLine = 12;
-+                data[1].posBeg.dwColumn = 0;
-+                data[1].posEnd.dwLine = 12;
-+                data[1].posEnd.dwColumn = uint.MaxValue;
-+                data[1].dwFlags = (uint) enum_DISASSEMBLY_FLAGS.DF_HASSOURCE;
-+
-+                data[2].dwFields = (uint) (
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
-+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
-+                
-+                data[2].dwByteOffset = 0;
-+                data[2].uCodeLocationId = StartAddress.Address + 3;
-+                data[2].bstrDocumentUrl = null;
-+                data[2].posBeg.dwLine = 13;
-+                data[2].posBeg.dwColumn = 0;
-+                data[2].posEnd.dwLine = 21;
-+                data[2].posEnd.dwColumn = uint.MaxValue;
-+                data[2].dwFlags = (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE | enum_DISASSEMBLY_FLAGS.DF_DISABLED);
-+
-+                num_read = 3;
-+                return COM.S_OK;
-+#endif
-+            }
-+
-+            int IDebugDisassemblyStream2.Seek (uint dwSeekStart, IDebugCodeContext2 pCodeContext, ulong uCodeLocationId, long iInstructions)
-+            {
-+                string addr = pCodeContext != null ? String.Format ("{0:x}", ((AD7MemoryAddress) pCodeContext).Address) : "null";
-+                Utils.Message ("SEEK: {0:x} {1:x} {2:x} {3:x}", dwSeekStart, addr, uCodeLocationId, iInstructions);
-+                return COM.S_OK;
-+            }
-+
-+            #endregion
-+        }
-+
-+        protected class DebugDocument : IDebugDocument2
-+        {
-+            #region IDebugDocument2 Members
-+
-+            int IDebugDocument2.GetDocumentClassId (out Guid pclsid)
-+            {
-+                throw new NotImplementedException ();
-+            }
-+
-+            int IDebugDocument2.GetName (uint gnType, out string pbstrFileName)
-+            {
-+                pbstrFileName = "monkey";
-+                return COM.S_OK;
-+            }
-+
-+            #endregion
-+        }
-+
- 		#endregion
- 
- 		#region IDebugProcess2 Members
-@@ -383,11 +661,6 @@
- 			throw new NotImplementedException ();
- 		}
- 
--		int IDebugProgram2.GetDisassemblyStream (uint dwScope, IDebugCodeContext2 pCodeContext, out IDebugDisassemblyStream2 ppDisassemblyStream)
--		{
--			throw new NotImplementedException ();
--		}
--
- 		int IDebugProgram2.GetENCUpdate (out object ppUpdate)
- 		{
- 			throw new NotImplementedException ();
-Index: Server/ServerThread.cs
-===================================================================
---- Server/ServerThread.cs	(revision 111634)
-+++ Server/ServerThread.cs	(working copy)
-@@ -66,6 +66,7 @@
- 
- 	public ServerStackFrame GetFrame ()
- 	{
-+		Thread.CurrentFrame.Method.LineNumberTable.DumpLineNumbers ();
- 		return new ServerStackFrame (this, Thread.CurrentFrame);
- 	}
- 
-Index: Server/ServerProcess.cs
-===================================================================
---- Server/ServerProcess.cs	(revision 111699)
-+++ Server/ServerProcess.cs	(working copy)
-@@ -109,5 +109,134 @@
- 			break;
- 		}
- 	}
-+
-+	public IAssemblerMethod DisassembleMethod (TargetAddress arg)
-+	{
-+		MDB.TargetAddress address = new MDB.TargetAddress (
-+			MDB.AddressDomain.Global, (long) arg.Address);
-+		Console.WriteLine ("DISASSEMBLE METHOD: {0:x} {1}", address, MainThread.Thread);
-+
-+		MDB.Method method = Process.Lookup (address);
-+		Console.WriteLine ("DISASSEMBLE METHOD #1: {0}", method);
-+		if (method == null)
-+			return null;
-+
-+		MDB.AssemblerMethod asm = MainThread.Thread.DisassembleMethod (method);
-+		Console.WriteLine ("DISASSEMBLE METHOD #2: {0}", asm);
-+		if (asm == null)
-+			return null;
-+
-+		string file = null;
-+		MDB.LineNumberTable lnt = null;
-+		if (method.HasSource && method.MethodSource.HasSourceFile && method.HasLineNumbers) {
-+			lnt = method.LineNumberTable;
-+			file = method.MethodSource.SourceFile.FileName;
-+		}
-+
-+		IAssemblerLine[] lines = new IAssemblerLine [asm.Lines.Length];
-+		for (int i = 0; i < lines.Length; i++) {
-+			MDB.SourceAddress source = null;
-+			if (lnt != null) {
-+				source = lnt.Lookup (asm.Lines [i].Address);
-+				Console.WriteLine ("  DISASSEMBLE METHOD #4: {0} {1} {2}", i,
-+						   asm.Lines [i].Address, source);
-+			}
-+
-+			if (source != null)
-+				lines [i] = new AssemblerLine (
-+					asm.Lines [i], source.Row, source.SourceOffset);
-+			else
-+				lines [i] = new AssemblerLine (asm.Lines [i]);
-+		}
-+
-+		return new AssemblerMethod (asm, lines, file);
-+	}
-+
-+	protected class AssemblerMethod : MarshalByRefObject, IAssemblerMethod
-+	{
-+		public MDB.AssemblerMethod Assembler {
-+			get; private set;
-+		}
-+
-+		public IAssemblerLine[] Lines {
-+			get; private set;
-+		}
-+
-+		public string FileName {
-+			get; private set;
-+		}
-+
-+		public AssemblerMethod (MDB.AssemblerMethod asm, IAssemblerLine[] lines,
-+					string filename)
-+		{
-+			this.Assembler = asm;
-+			this.Lines = lines;
-+			this.FileName = filename;
-+		}
-+
-+		IAssemblerLine[] IAssemblerMethod.Lines {
-+			get { return Lines; }
-+		}
-+
-+		string IAssemblerMethod.SourceFileName {
-+			get { return FileName; }
-+		}
-+	}
-+
-+	protected class AssemblerLine : MarshalByRefObject, IAssemblerLine
-+	{
-+		public MDB.AssemblerLine Line {
-+			get; private set;
-+		}
-+
-+		public bool HasSource {
-+			get; private set;
-+		}
-+
-+		public int SourceRow {
-+			get; private set;
-+		}
-+
-+		public int SourceOffset {
-+			get; private set;
-+		}
-+
-+		public AssemblerLine (MDB.AssemblerLine line)
-+		{
-+			this.Line = line;
-+		}
-+
-+		public AssemblerLine (MDB.AssemblerLine line, int row, int offset)
-+			: this (line)
-+		{
-+			this.SourceRow = row;
-+			this.SourceOffset = offset;
-+			this.HasSource = true;
-+		}
-+
-+		string IAssemblerLine.Label {
-+			get { return Line.Label; }
-+		}
-+
-+		TargetAddress IAssemblerLine.Address {
-+			get { return new TargetAddress (Line.Address.Address); }
-+		}
-+
-+		int IAssemblerLine.InstructionSize {
-+			get { return Line.InstructionSize; }
-+		}
-+
-+		string IAssemblerLine.Text {
-+			get { return Line.Text; }
-+		}
-+
-+		uint IAssemblerLine.SourceRow {
-+			get { return (uint) SourceRow; }
-+		}
-+
-+		uint IAssemblerLine.SourceOffset {
-+			get { return (uint) SourceOffset; }
-+		}
-+	}
- }
- }
-Index: RegisterDebugger/RegisterDebugger.cs
-===================================================================
---- RegisterDebugger/RegisterDebugger.cs	(revision 111331)
-+++ RegisterDebugger/RegisterDebugger.cs	(working copy)
-@@ -85,6 +85,7 @@
-             mono_engine.SetValue ("AutoselectPriority", 4);
-             mono_engine.SetValue ("Attach", 1);     // Supports attaching
-             mono_engine.SetValue ("AddressBP", 1);  // Supports address-based breakpoints
-+            mono_engine.SetValue ("Disassembly", 1);
- 			mono_engine.SetValue ("RemotingDebugging", 1);
- 
- 			//
Index: RemotingContract/Contract.cs
===================================================================
--- RemotingContract/Contract.cs	(revision 111699)
+++ RemotingContract/Contract.cs	(working copy)
@@ -84,8 +84,59 @@
          * Stop all threads in the target.
          */
         void Stop ();
+
+        IAssemblerMethod DisassembleMethod (TargetAddress address);
 	}
 
+    public interface IAssemblerMethod
+    {
+        string SourceFileName
+        {
+            get;
+        }
+
+        IAssemblerLine[] Lines
+        {
+            get;
+        }
+    }
+
+    public interface IAssemblerLine
+    {
+        string Label
+        {
+            get;
+        }
+
+        TargetAddress Address
+        {
+            get;
+        }
+
+        int InstructionSize
+        {
+            get;
+        }
+
+        string Text
+        {
+            get;
+        }
+
+        bool HasSource
+        {
+            get;
+        }
+
+        uint SourceRow {
+            get;
+        }
+
+        uint SourceOffset {
+            get;
+        }
+    }
+
 	public interface IServerThread
 	{
 		int ID
@@ -146,4 +197,70 @@
 			get;
 		}
 	}
+
+    [Serializable]
+    public struct TargetAddress
+    {
+        public readonly ulong Address;
+
+        public TargetAddress (ulong address)
+        {
+            this.Address = address;
+        }
+
+        public TargetAddress (long address)
+        {
+            unchecked
+            {
+                this.Address =  (ulong) address;
+            }
+        }
+
+		public override string ToString ()
+		{
+            unchecked
+            {
+                long address = (long) Address;
+                return String.Format ("0x{0}", FormatAddress (address));
+            }
+		}
+
+		public static string FormatAddress (long address)
+		{
+			int bits = 8;
+			string saddr = address.ToString ("x");
+			for (int i = saddr.Length; i < bits; i++)
+				saddr = "0" + saddr;
+			return saddr;
+		}
+
+		public int CompareTo (object obj)
+		{
+			TargetAddress addr = (TargetAddress) obj;
+
+			if (Address < addr.Address)
+				return -1;
+			else if (Address > addr.Address)
+				return 1;
+			else
+				return 0;
+		}
+
+		public override bool Equals (object o)
+		{
+			if (o == null || !(o is TargetAddress))
+				return false;
+
+			TargetAddress b = (TargetAddress)o;
+			return Address == b.Address;
+		}
+
+		public override int GetHashCode ()
+		{
+            unchecked
+            {
+                return (int) Address;
+            }
+		}
+    }
 }
Index: Mono.VisualStudio.Debugger/MemoryAddress.cs
===================================================================
--- Mono.VisualStudio.Debugger/MemoryAddress.cs	(revision 110947)
+++ Mono.VisualStudio.Debugger/MemoryAddress.cs	(working copy)
@@ -1,184 +1,189 @@
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.VisualStudio.Debugger.Interop;
-
-namespace Mono.VisualStudio.Debugger
-{
-    // And implementation of IDebugCodeContext2 and IDebugMemoryContext2. 
-    // IDebugMemoryContext2 represents a position in the address space of the machine running the program being debugged.
-    // IDebugCodeContext2 represents the starting position of a code instruction. 
-    // For most run-time architectures today, a code context can be thought of as an address in a program's execution stream.
-    class AD7MemoryAddress : IDebugCodeContext2
-    {
-        readonly Engine m_engine;
-        readonly ulong m_address;
-        IDebugDocumentContext2 m_documentContext;
-        
-        public AD7MemoryAddress(Engine engine, ulong address)
-        {
-            m_engine = engine;
-            m_address = address;
-        }
-
-        public void SetDocumentContext(IDebugDocumentContext2 docContext)
-        {
-            m_documentContext = docContext;
-        }
-
-        #region IDebugMemoryContext2 Members
-
-        // Adds a specified value to the current context's address to create a new context.
-        public int Add(ulong dwCount, out IDebugMemoryContext2 newAddress)
-        {
-            newAddress = new AD7MemoryAddress(m_engine, (uint)dwCount + m_address);
-            return COM.S_OK;
-        }
-
-        // Compares the memory context to each context in the given array in the manner indicated by compare flags, 
-        // returning an index of the first context that matches.
-        public int Compare(uint uContextCompare, IDebugMemoryContext2[] compareToItems, uint compareToLength, out uint foundIndex)
-        {
-            foundIndex = uint.MaxValue;
-
-            try
-            {
-                enum_CONTEXT_COMPARE contextCompare = (enum_CONTEXT_COMPARE)uContextCompare;
-
-                for (uint c = 0; c < compareToLength; c++)
-                {
-                    AD7MemoryAddress compareTo = compareToItems[c] as AD7MemoryAddress;
-                    if (compareTo == null)
-                    {
-                        continue;
-                    }
-
-                    if (!Engine.ReferenceEquals(this.m_engine, compareTo.m_engine))
-                    {
-                        continue;
-                    }
-
-                    bool result;
-
-                    switch (contextCompare)
-                    {
-                        case enum_CONTEXT_COMPARE.CONTEXT_EQUAL:
-                            result = (this.m_address == compareTo.m_address);
-                            break;
-
-                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN:
-                            result = (this.m_address < compareTo.m_address);
-                            break;
-
-                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN:
-                            result = (this.m_address > compareTo.m_address);
-                            break;
-
-                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN_OR_EQUAL:
-                            result = (this.m_address <= compareTo.m_address);
-                            break;
-
-                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN_OR_EQUAL:
-                            result = (this.m_address >= compareTo.m_address);
-                            break;
-
-                        // The sample debug engine doesn't understand scopes or functions
-                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_SCOPE:
-                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_FUNCTION:
-                            result = (this.m_address == compareTo.m_address);
-                            break;
-
-                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_PROCESS:
-                            result = true;
-                            break;
-
-                        default:
-                            // A new comparison was invented that we don't support
-                            return COM.E_NOTIMPL;
-                    }
-
-                    if (result)
-                    {
-                        foundIndex = c;
-                        return COM.S_OK;
-                    }
-                }
-
-                return COM.S_FALSE;
-            }
-                      catch (Exception e)
-            {
-                return Utils.UnexpectedException(e);
-            }
-        }
-
-        // Gets information that describes this context.
-        public int GetInfo(uint dwFields, CONTEXT_INFO[] pinfo)
-        {           
-            try
-            {
-                pinfo[0].dwFields = 0;
-
-                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS) != 0)
-                {
-                    pinfo[0].bstrAddress = m_address.ToString();
-                    pinfo[0].dwFields |= (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS;
-                }
-
-                // Fields not supported by the sample
-                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSOFFSET) != 0){}
-                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE) != 0){}
-                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_MODULEURL) != 0){}
-                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTION) != 0) {}
-                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTIONOFFSET) != 0) {}
-
-                return COM.S_OK;
-            }
-            catch (Exception e)
-            {
-                return Utils.UnexpectedException(e);
-            }
-        }
-
-        // Gets the user-displayable name for this context
-        // This is not supported by the sample engine.
-        public int GetName(out string pbstrName)
-        {
-            throw new Exception("The method or operation is not implemented.");
-        }
-
-        // Subtracts a specified value from the current context's address to create a new context.
-        public int Subtract(ulong dwCount, out IDebugMemoryContext2 ppMemCxt)
-        {
-            ppMemCxt = new AD7MemoryAddress(m_engine, (uint)dwCount - m_address);
-            return COM.S_OK;
-        }
-
-        #endregion
-
-        #region IDebugCodeContext2 Members
-
-        // Gets the document context for this code-context
-        public int GetDocumentContext(out IDebugDocumentContext2 ppSrcCxt)
-        {
-            ppSrcCxt = m_documentContext;
-            return COM.S_OK;
-        }
-
-        // Gets the language information for this code context.
-        public int GetLanguageInfo(ref string pbstrLanguage, ref Guid pguidLanguage)
-        {
-            if (m_documentContext != null)
-            {
-                m_documentContext.GetLanguageInfo(ref pbstrLanguage, ref pguidLanguage);
-                return COM.S_OK;
-            }
-            else
-            {
-                return COM.S_FALSE;
-            }
-        }
-
-        #endregion
-    }
-}
+using System;
+using System.Collections.Generic;
+using System.Text;
+using Microsoft.VisualStudio.Debugger.Interop;
+
+namespace Mono.VisualStudio.Debugger
+{
+    // And implementation of IDebugCodeContext2 and IDebugMemoryContext2. 
+    // IDebugMemoryContext2 represents a position in the address space of the machine running the program being debugged.
+    // IDebugCodeContext2 represents the starting position of a code instruction. 
+    // For most run-time architectures today, a code context can be thought of as an address in a program's execution stream.
+    class AD7MemoryAddress : IDebugCodeContext2
+    {
+        readonly Engine m_engine;
+        readonly ulong m_address;
+        IDebugDocumentContext2 m_documentContext;
+        
+        public AD7MemoryAddress(Engine engine, ulong address)
+        {
+            m_engine = engine;
+            m_address = address;
+        }
+
+        public ulong Address
+        {
+            get { return m_address; }
+        }
+
+        public void SetDocumentContext(IDebugDocumentContext2 docContext)
+        {
+            m_documentContext = docContext;
+        }
+
+        #region IDebugMemoryContext2 Members
+
+        // Adds a specified value to the current context's address to create a new context.
+        public int Add(ulong dwCount, out IDebugMemoryContext2 newAddress)
+        {
+            newAddress = new AD7MemoryAddress(m_engine, (uint)dwCount + m_address);
+            return COM.S_OK;
+        }
+
+        // Compares the memory context to each context in the given array in the manner indicated by compare flags, 
+        // returning an index of the first context that matches.
+        public int Compare(uint uContextCompare, IDebugMemoryContext2[] compareToItems, uint compareToLength, out uint foundIndex)
+        {
+            foundIndex = uint.MaxValue;
+
+            try
+            {
+                enum_CONTEXT_COMPARE contextCompare = (enum_CONTEXT_COMPARE)uContextCompare;
+
+                for (uint c = 0; c < compareToLength; c++)
+                {
+                    AD7MemoryAddress compareTo = compareToItems[c] as AD7MemoryAddress;
+                    if (compareTo == null)
+                    {
+                        continue;
+                    }
+
+                    if (!Engine.ReferenceEquals(this.m_engine, compareTo.m_engine))
+                    {
+                        continue;
+                    }
+
+                    bool result;
+
+                    switch (contextCompare)
+                    {
+                        case enum_CONTEXT_COMPARE.CONTEXT_EQUAL:
+                            result = (this.m_address == compareTo.m_address);
+                            break;
+
+                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN:
+                            result = (this.m_address < compareTo.m_address);
+                            break;
+
+                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN:
+                            result = (this.m_address > compareTo.m_address);
+                            break;
+
+                        case enum_CONTEXT_COMPARE.CONTEXT_LESS_THAN_OR_EQUAL:
+                            result = (this.m_address <= compareTo.m_address);
+                            break;
+
+                        case enum_CONTEXT_COMPARE.CONTEXT_GREATER_THAN_OR_EQUAL:
+                            result = (this.m_address >= compareTo.m_address);
+                            break;
+
+                        // The sample debug engine doesn't understand scopes or functions
+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_SCOPE:
+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_FUNCTION:
+                            result = (this.m_address == compareTo.m_address);
+                            break;
+
+                        case enum_CONTEXT_COMPARE.CONTEXT_SAME_PROCESS:
+                            result = true;
+                            break;
+
+                        default:
+                            // A new comparison was invented that we don't support
+                            return COM.E_NOTIMPL;
+                    }
+
+                    if (result)
+                    {
+                        foundIndex = c;
+                        return COM.S_OK;
+                    }
+                }
+
+                return COM.S_FALSE;
+            }
+                      catch (Exception e)
+            {
+                return Utils.UnexpectedException(e);
+            }
+        }
+
+        // Gets information that describes this context.
+        public int GetInfo(uint dwFields, CONTEXT_INFO[] pinfo)
+        {           
+            try
+            {
+                pinfo[0].dwFields = 0;
+
+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS) != 0)
+                {
+                    pinfo[0].bstrAddress = m_address.ToString();
+                    pinfo[0].dwFields |= (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESS;
+                }
+
+                // Fields not supported by the sample
+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSOFFSET) != 0){}
+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE) != 0){}
+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_MODULEURL) != 0){}
+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTION) != 0) {}
+                if ((dwFields & (uint)enum_CONTEXT_INFO_FIELDS.CIF_FUNCTIONOFFSET) != 0) {}
+
+                return COM.S_OK;
+            }
+            catch (Exception e)
+            {
+                return Utils.UnexpectedException(e);
+            }
+        }
+
+        // Gets the user-displayable name for this context
+        // This is not supported by the sample engine.
+        public int GetName(out string pbstrName)
+        {
+            throw new Exception("The method or operation is not implemented.");
+        }
+
+        // Subtracts a specified value from the current context's address to create a new context.
+        public int Subtract(ulong dwCount, out IDebugMemoryContext2 ppMemCxt)
+        {
+            ppMemCxt = new AD7MemoryAddress(m_engine, (uint)dwCount - m_address);
+            return COM.S_OK;
+        }
+
+        #endregion
+
+        #region IDebugCodeContext2 Members
+
+        // Gets the document context for this code-context
+        public int GetDocumentContext(out IDebugDocumentContext2 ppSrcCxt)
+        {
+            ppSrcCxt = m_documentContext;
+            return COM.S_OK;
+        }
+
+        // Gets the language information for this code context.
+        public int GetLanguageInfo(ref string pbstrLanguage, ref Guid pguidLanguage)
+        {
+            if (m_documentContext != null)
+            {
+                m_documentContext.GetLanguageInfo(ref pbstrLanguage, ref pguidLanguage);
+                return COM.S_OK;
+            }
+            else
+            {
+                return COM.S_FALSE;
+            }
+        }
+
+        #endregion
+    }
+}
Index: Mono.VisualStudio.Debugger/DebuggerController.cs
===================================================================
--- Mono.VisualStudio.Debugger/DebuggerController.cs	(revision 110947)
+++ Mono.VisualStudio.Debugger/DebuggerController.cs	(working copy)
@@ -75,7 +75,7 @@
 
 		public void Shutdown ()
 		{
-			UriBuilder target = new UriBuilder (BaseURL + "/shutdown");
+			UriBuilder target = new UriBuilder (BaseURL + "/shwwutdown");
 			target.Query = "foo=bar";
 			Post (target.ToString ());
 		}
Index: Mono.VisualStudio.Debugger/Thread.cs
===================================================================
--- Mono.VisualStudio.Debugger/Thread.cs	(revision 111699)
+++ Mono.VisualStudio.Debugger/Thread.cs	(working copy)
@@ -60,6 +60,7 @@
             {
                 StackFrame frame = new StackFrame (Process.Engine, server_frames[i]);
                 frame.SetFrameInfo (dwFieldSpec, out array[i]);
+                Utils.Message ("ENUM FRAME INFO: {0} {1:x}", i, frame.Frame.Address);
             }
 
             ppEnum = new AD7FrameInfoEnum (array);
Index: Mono.VisualStudio.Debugger/Process.cs
===================================================================
--- Mono.VisualStudio.Debugger/Process.cs	(revision 111699)
+++ Mono.VisualStudio.Debugger/Process.cs	(working copy)
@@ -252,6 +252,284 @@
 			return COM.S_OK;
 		}
 
+        public int GetDisassemblyStream (uint scope, IDebugCodeContext2 context, out IDebugDisassemblyStream2 stream)
+        {
+            TargetAddress address = new TargetAddress (((AD7MemoryAddress) context).Address);
+            Utils.Message ("GET DISASSEMBLY STREAM: {0:x} {1:x}", scope, address);
+            IAssemblerMethod method = ServerProcess.DisassembleMethod (address);
+            stream = new DisassemblyStream (this, address, method);
+            return COM.S_OK;
+        }
+
+        protected class DisassemblyStream : IDebugDisassemblyStream2
+        {
+            public Process Process
+            {
+                get;
+                private set;
+            }
+
+            public TargetAddress StartAddress
+            {
+                get; private set;
+            }
+
+            public IAssemblerMethod AssemblerMethod
+            {
+                get;
+                private set;
+            }
+
+            public bool HasSource
+            {
+                get { return AssemblerMethod.SourceFileName != null; }
+            }
+
+            public DisassemblyStream (Process process, TargetAddress address, IAssemblerMethod method)
+            {
+                this.StartAddress = address;
+                this.Process = process;
+                this.AssemblerMethod = method;
+            }
+
+            #region IDebugDisassemblyStream2 Members
+
+            int IDebugDisassemblyStream2.GetCodeContext (ulong uCodeLocationId, out IDebugCodeContext2 ppCodeContext)
+            {
+                Utils.Message ("GET CODE CONTEXT: {0:x}", uCodeLocationId);
+                // ppCodeContext = new AD7MemoryAddress (Process.Engine, StartAddress.Address);
+                ppCodeContext = new AD7MemoryAddress (Process.Engine, uCodeLocationId);
+                return COM.S_OK;
+            }
+
+            int IDebugDisassemblyStream2.GetCodeLocationId (IDebugCodeContext2 pCodeContext, out ulong puCodeLocationId)
+            {
+                puCodeLocationId = ((AD7MemoryAddress) pCodeContext).Address;
+                return COM.S_OK;
+            }
+
+            int IDebugDisassemblyStream2.GetCurrentLocation (out ulong puCodeLocationId)
+            {
+                throw new NotImplementedException ();
+            }
+
+            int IDebugDisassemblyStream2.GetDocument (string bstrDocumentUrl, out IDebugDocument2 ppDocument)
+            {
+                ppDocument = new DebugDocument ();
+                return COM.S_OK;
+            }
+
+            int IDebugDisassemblyStream2.GetScope (out uint pdwScope)
+            {
+                throw new NotImplementedException ();
+            }
+
+            int IDebugDisassemblyStream2.GetSize (out ulong pnSize)
+            {
+                pnSize = 1;
+                return COM.S_OK;
+            }
+
+            int pos = 0;
+            uint last_line = 0;
+            TargetAddress last_address;
+            bool done = false;
+
+            int IDebugDisassemblyStream2.Read (uint max_instructions, uint field, out uint num_read, DisassemblyData[] data)
+            {
+                num_read = 0;
+
+                Utils.Message ("READ: {0} {1} {2} {3}", max_instructions, pos, AssemblerMethod.Lines.Length, last_line);
+
+#if FIXME
+                if (false && (pos == 0))
+                {
+                    IAssemblerLine line = AssemblerMethod.Lines [0];
+                    data[0].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL |
+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
+                    data[0].bstrAddress = line.Address.ToString ();
+                    data[0].bstrOpcode = line.Text;
+                    data[0].dwByteOffset = 0;
+                    data[0].uCodeLocationId = line.Address.Address;
+                    data[0].bstrDocumentUrl = null;
+                    data[0].dwFlags = 0;
+
+                    if (HasSource)
+                    {
+                        data[0].bstrDocumentUrl = AssemblerMethod.SourceFileName;
+                        data[0].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL);
+                        data[0].dwFlags |= (uint) (enum_DISASSEMBLY_FLAGS.DF_DOCUMENTCHANGE | enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
+
+                        if (line.HasSource && (line.SourceOffset == 0))
+                        {
+                            data[0].posBeg.dwLine = 0;
+                            data[0].posBeg.dwColumn = 0;
+                            data[0].posEnd.dwLine = line.SourceRow;
+                            data[0].posEnd.dwColumn = uint.MaxValue;
+                            data[0].dwByteOffset = line.SourceOffset;
+                            data[0].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION);
+                            data[0].dwFlags |= (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
+                            last_line = line.SourceRow;
+                        }
+                    }
+
+                    last_address = line.Address;
+
+                    num_read++;
+                    pos++;
+                }
+#endif
+
+                if (pos >= AssemblerMethod.Lines.Length)
+                {
+                    if (HasSource && !done)
+                    {
+                        data[0].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET |
+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL |
+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
+                            enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
+
+                        data[0].dwByteOffset = 0;
+                        data[0].bstrDocumentUrl = AssemblerMethod.SourceFileName; 
+                        data[0].uCodeLocationId = last_address.Address + 1;
+                        data[0].posBeg.dwLine = last_line;
+                        data[0].posBeg.dwColumn = 0;
+                        data[0].posEnd.dwLine = uint.MaxValue;
+                        data[0].posEnd.dwColumn = uint.MaxValue;
+                        data[0].dwFlags = (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
+                        num_read++;
+                        done = true;
+                        return COM.S_OK;
+                    }
+
+                    return COM.S_FALSE;
+                }
+
+                data[num_read].bstrSymbol = "RESTART!";
+                data[num_read].dwFields |= (uint) enum_DISASSEMBLY_STREAM_FIELDS.DSF_SYMBOL;
+
+                while ((pos < AssemblerMethod.Lines.Length) && (num_read < max_instructions))
+                {
+                    IAssemblerLine line = AssemblerMethod.Lines[pos];
+
+                    data[num_read].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
+                        enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
+                    data[num_read].bstrAddress = line.Address.ToString ();
+                    data[num_read].bstrOpcode = line.Text;
+                    data[num_read].dwByteOffset = 0;
+                    data[num_read].uCodeLocationId = line.Address.Address;
+                    data[num_read].bstrDocumentUrl = null;
+                    data[num_read].dwFlags = 0;
+
+                    if (!HasSource) {
+                        pos++;
+                        num_read++;
+                        continue;
+                    }
+
+                    if (num_read == 0)
+                    {
+                        data[0].bstrDocumentUrl = AssemblerMethod.SourceFileName;
+                        data[0].dwFields |= (uint) enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL;
+                        if (pos == 0)
+                            data[0].dwFlags |= (uint) enum_DISASSEMBLY_FLAGS.DF_DOCUMENTCHANGE;
+                    }
+
+                    if (line.HasSource)
+                    {
+                        Utils.Message ("ASM: {0} {1} {2}", line.Address, last_line, line.SourceRow);
+                        data[num_read].posBeg.dwLine = last_line;
+                        data[num_read].posBeg.dwColumn = 0;
+                        data[num_read].posEnd.dwLine = line.SourceRow - 1;
+                        data[num_read].posEnd.dwColumn = uint.MaxValue;
+                        data[num_read].dwByteOffset = line.SourceOffset;
+                        if (true || (line.SourceOffset == 0))
+                        {
+                            data[num_read].dwFields |= (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION);
+                            data[num_read].dwFlags |= (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE);
+                            last_line = line.SourceRow;
+                        }
+                    }
+
+                    pos++;
+                    num_read++;
+                }
+
+                return COM.S_OK;
+
+#if FIXME    
+                data[1].dwFields = (uint) (enum_DISASSEMBLY_STREAM_FIELDS.DSF_ADDRESS |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODEBYTES | enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPCODE |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_OPERANDS | enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET | enum_DISASSEMBLY_STREAM_FIELDS.DSF_SYMBOL |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
+                data[1].bstrAddress = "second-line";
+                data[1].bstrCodeBytes = "0xcc";
+                data[1].bstrOpcode = "monkey";
+                data[1].bstrOperands = "boston";
+                data[1].dwByteOffset = 0;
+                data[1].bstrSymbol = "Test";
+                data[1].uCodeLocationId = StartAddress.Address + 2;
+                data[1].bstrDocumentUrl = null;
+                data[1].posBeg.dwLine = 12;
+                data[1].posBeg.dwColumn = 0;
+                data[1].posEnd.dwLine = 12;
+                data[1].posEnd.dwColumn = uint.MaxValue;
+                data[1].dwFlags = (uint) enum_DISASSEMBLY_FLAGS.DF_HASSOURCE;
+
+                data[2].dwFields = (uint) (
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_CODELOCATIONID |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_BYTEOFFSET |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_DOCUMENTURL | enum_DISASSEMBLY_STREAM_FIELDS.DSF_POSITION |
+                    enum_DISASSEMBLY_STREAM_FIELDS.DSF_FLAGS);
+                
+                data[2].dwByteOffset = 0;
+                data[2].uCodeLocationId = StartAddress.Address + 3;
+                data[2].bstrDocumentUrl = null;
+                data[2].posBeg.dwLine = 13;
+                data[2].posBeg.dwColumn = 0;
+                data[2].posEnd.dwLine = 21;
+                data[2].posEnd.dwColumn = uint.MaxValue;
+                data[2].dwFlags = (uint) (enum_DISASSEMBLY_FLAGS.DF_HASSOURCE | enum_DISASSEMBLY_FLAGS.DF_DISABLED);
+
+                num_read = 3;
+                return COM.S_OK;
+#endif
+            }
+
+            int IDebugDisassemblyStream2.Seek (uint dwSeekStart, IDebugCodeContext2 pCodeContext, ulong uCodeLocationId, long iInstructions)
+            {
+                string addr = pCodeContext != null ? String.Format ("{0:x}", ((AD7MemoryAddress) pCodeContext).Address) : "null";
+                Utils.Message ("SEEK: {0:x} {1:x} {2:x} {3:x}", dwSeekStart, addr, uCodeLocationId, iInstructions);
+                return COM.S_OK;
+            }
+
+            #endregion
+        }
+
+        protected class DebugDocument : IDebugDocument2
+        {
+            #region IDebugDocument2 Members
+
+            int IDebugDocument2.GetDocumentClassId (out Guid pclsid)
+            {
+                throw new NotImplementedException ();
+            }
+
+            int IDebugDocument2.GetName (uint gnType, out string pbstrFileName)
+            {
+                pbstrFileName = "monkey";
+                return COM.S_OK;
+            }
+
+            #endregion
+        }
+
 		#endregion
 
 		#region IDebugProcess2 Members
@@ -383,11 +661,6 @@
 			throw new NotImplementedException ();
 		}
 
-		int IDebugProgram2.GetDisassemblyStream (uint dwScope, IDebugCodeContext2 pCodeContext, out IDebugDisassemblyStream2 ppDisassemblyStream)
-		{
-			throw new NotImplementedException ();
-		}
-
 		int IDebugProgram2.GetENCUpdate (out object ppUpdate)
 		{
 			throw new NotImplementedException ();
Index: Server/DebuggerServer.cs
===================================================================
--- Server/DebuggerServer.cs	(revision 110947)
+++ Server/DebuggerServer.cs	(working copy)
@@ -4,7 +4,7 @@
 
 namespace Mono.VisualStudio.Mdb
 {
-public class DebuggerServer : MarshalByRefObject, IDebuggerServer
+public class DebuggerServer : DebuggerMarshalByRefObject, IDebuggerServer
 {
 	public DebuggerManager DebuggerManager {
 		get; private set;
Index: Server/ServerThread.cs
===================================================================
--- Server/ServerThread.cs	(revision 111634)
+++ Server/ServerThread.cs	(working copy)
@@ -4,7 +4,7 @@
 
 namespace Mono.VisualStudio.Mdb
 {
-public class ServerThread : MarshalByRefObject, IServerThread
+public class ServerThread : DebuggerMarshalByRefObject, IServerThread
 {
 	public ServerProcess Process {
 		get; private set;
@@ -66,6 +66,7 @@
 
 	public ServerStackFrame GetFrame ()
 	{
+		Thread.CurrentFrame.Method.LineNumberTable.DumpLineNumbers ();
 		return new ServerStackFrame (this, Thread.CurrentFrame);
 	}
 
Index: Server/DebuggerManager.cs
===================================================================
--- Server/DebuggerManager.cs	(revision 110947)
+++ Server/DebuggerManager.cs	(working copy)
@@ -16,6 +16,14 @@
 
 namespace Mono.VisualStudio.Mdb {
 
+public class DebuggerMarshalByRefObject : MarshalByRefObject
+{
+	public override object InitializeLifetimeService()
+	{
+		return null;
+	}
+}
+
 public static class Manager {
 	static ManualResetEvent exit_event = new ManualResetEvent (false);
 
@@ -87,7 +95,7 @@
 	}
 }
 
-public class DebuggerManager : MarshalByRefObject, IMdbManager, ISponsor {
+public class DebuggerManager : DebuggerMarshalByRefObject, IMdbManager, ISponsor {
 	
 	IMdbController controller;
 	
Index: Server/ServerBreakpoint.cs
===================================================================
--- Server/ServerBreakpoint.cs	(revision 110947)
+++ Server/ServerBreakpoint.cs	(working copy)
@@ -4,7 +4,7 @@
 
 namespace Mono.VisualStudio.Mdb {
 
-public class ServerBreakpoint : MarshalByRefObject, IServerBreakpoint
+public class ServerBreakpoint : DebuggerMarshalByRefObject, IServerBreakpoint
 {
 	public MDB.Event Event;
 
Index: Server/ServerProcess.cs
===================================================================
--- Server/ServerProcess.cs	(revision 111699)
+++ Server/ServerProcess.cs	(working copy)
@@ -5,7 +5,7 @@
 
 namespace Mono.VisualStudio.Mdb {
 
-public class ServerProcess : MarshalByRefObject, IServerProcess
+public class ServerProcess : DebuggerMarshalByRefObject, IServerProcess
 {
 	Dictionary<MDB.Thread,ServerThread> threads = new Dictionary<MDB.Thread,ServerThread> ();
 	ManualResetEvent start_event = new ManualResetEvent (false);
@@ -109,5 +109,134 @@
 			break;
 		}
 	}
+
+	public IAssemblerMethod DisassembleMethod (TargetAddress arg)
+	{
+		MDB.TargetAddress address = new MDB.TargetAddress (
+			MDB.AddressDomain.Global, (long) arg.Address);
+		Console.WriteLine ("DISASSEMBLE METHOD: {0:x} {1}", address, MainThread.Thread);
+
+		MDB.Method method = Process.Lookup (address);
+		Console.WriteLine ("DISASSEMBLE METHOD #1: {0}", method);
+		if (method == null)
+			return null;
+
+		MDB.AssemblerMethod asm = MainThread.Thread.DisassembleMethod (method);
+		Console.WriteLine ("DISASSEMBLE METHOD #2: {0}", asm);
+		if (asm == null)
+			return null;
+
+		string file = null;
+		MDB.LineNumberTable lnt = null;
+		if (method.HasSource && method.MethodSource.HasSourceFile && method.HasLineNumbers) {
+			lnt = method.LineNumberTable;
+			file = method.MethodSource.SourceFile.FileName;
+		}
+
+		IAssemblerLine[] lines = new IAssemblerLine [asm.Lines.Length];
+		for (int i = 0; i < lines.Length; i++) {
+			MDB.SourceAddress source = null;
+			if (lnt != null) {
+				source = lnt.Lookup (asm.Lines [i].Address);
+				Console.WriteLine ("  DISASSEMBLE METHOD #4: {0} {1} {2}", i,
+						   asm.Lines [i].Address, source);
+			}
+
+			if (source != null)
+				lines [i] = new AssemblerLine (
+					asm.Lines [i], source.Row, source.SourceOffset);
+			else
+				lines [i] = new AssemblerLine (asm.Lines [i]);
+		}
+
+		return new AssemblerMethod (asm, lines, file);
+	}
+
+	protected class AssemblerMethod : DebuggerMarshalByRefObject, IAssemblerMethod
+	{
+		public MDB.AssemblerMethod Assembler {
+			get; private set;
+		}
+
+		public IAssemblerLine[] Lines {
+			get; private set;
+		}
+
+		public string FileName {
+			get; private set;
+		}
+
+		public AssemblerMethod (MDB.AssemblerMethod asm, IAssemblerLine[] lines,
+					string filename)
+		{
+			this.Assembler = asm;
+			this.Lines = lines;
+			this.FileName = filename;
+		}
+
+		IAssemblerLine[] IAssemblerMethod.Lines {
+			get { return Lines; }
+		}
+
+		string IAssemblerMethod.SourceFileName {
+			get { return FileName; }
+		}
+	}
+
+	protected class AssemblerLine : DebuggerMarshalByRefObject, IAssemblerLine
+	{
+		public MDB.AssemblerLine Line {
+			get; private set;
+		}
+
+		public bool HasSource {
+			get; private set;
+		}
+
+		public int SourceRow {
+			get; private set;
+		}
+
+		public int SourceOffset {
+			get; private set;
+		}
+
+		public AssemblerLine (MDB.AssemblerLine line)
+		{
+			this.Line = line;
+		}
+
+		public AssemblerLine (MDB.AssemblerLine line, int row, int offset)
+			: this (line)
+		{
+			this.SourceRow = row;
+			this.SourceOffset = offset;
+			this.HasSource = true;
+		}
+
+		string IAssemblerLine.Label {
+			get { return Line.Label; }
+		}
+
+		TargetAddress IAssemblerLine.Address {
+			get { return new TargetAddress (Line.Address.Address); }
+		}
+
+		int IAssemblerLine.InstructionSize {
+			get { return Line.InstructionSize; }
+		}
+
+		string IAssemblerLine.Text {
+			get { return Line.Text; }
+		}
+
+		uint IAssemblerLine.SourceRow {
+			get { return (uint) SourceRow; }
+		}
+
+		uint IAssemblerLine.SourceOffset {
+			get { return (uint) SourceOffset; }
+		}
+	}
 }
 }
Index: Server/ServerStackFrame.cs
===================================================================
--- Server/ServerStackFrame.cs	(revision 111634)
+++ Server/ServerStackFrame.cs	(working copy)
@@ -5,7 +5,7 @@
 
 namespace Mono.VisualStudio.Mdb
 {
-public class ServerStackFrame : MarshalByRefObject, IServerStackFrame
+public class ServerStackFrame : DebuggerMarshalByRefObject, IServerStackFrame
 {
 	public ServerThread Thread {
 		get; private set;
@@ -62,7 +62,7 @@
 		return new SourceLocation (Frame.SourceAddress);
 	}
 
-	protected class SourceLocation : MarshalByRefObject, ISourceLocation
+	protected class SourceLocation : DebuggerMarshalByRefObject, ISourceLocation
 	{
 		string filename;
 		int line;
@@ -83,7 +83,7 @@
 	}
 }
 
-public class ServerBacktrace : MarshalByRefObject, IServerBacktrace
+public class ServerBacktrace : DebuggerMarshalByRefObject, IServerBacktrace
 {
 	public ServerThread Thread {
 		get; private set;
Index: Server/BreakpointManager.cs
===================================================================
--- Server/BreakpointManager.cs	(revision 110947)
+++ Server/BreakpointManager.cs	(working copy)
@@ -4,7 +4,7 @@
 
 namespace Mono.VisualStudio.Mdb
 {
-public class BreakpointManager : MarshalByRefObject, IBreakpointManager
+public class BreakpointManager : DebuggerMarshalByRefObject, IBreakpointManager
 {
 	public DebuggerServer DebuggerServer {
 		get; private set;
Index: RegisterDebugger/RegisterDebugger.cs
===================================================================
--- RegisterDebugger/RegisterDebugger.cs	(revision 111331)
+++ RegisterDebugger/RegisterDebugger.cs	(working copy)
@@ -85,6 +85,7 @@
             mono_engine.SetValue ("AutoselectPriority", 4);
             mono_engine.SetValue ("Attach", 1);     // Supports attaching
             mono_engine.SetValue ("AddressBP", 1);  // Supports address-based breakpoints
+            mono_engine.SetValue ("Disassembly", 1);
 			mono_engine.SetValue ("RemotingDebugging", 1);
 
 			//
