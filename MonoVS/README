A few notes on working on this codebase:

* Status:
	
	Communication between Linux and Windows is currently possible
	using the contract specified in RemotingContract.dll, this
	interface will grow as more features are neded.

	On Windows, run the solution, this will startup a new instance
	of VisualStudio.  In there create (or load) a simple managed
	C# program, compile and run it at least once.

	You also need to copy the file HomeDir/*.AddIn into
	your c:\users\Name\Documents\Visual Studio 2008\Addins.

	On Linux in the MonoVS/Server directory run "make run".

	Then on VS select "Tools/MonoAddin", that will start the
	debugger.  It will respect breakpoints that you might have
	set, and single stepping and continue should be working, as
	well as stack traces. 

	Thanks a *million* to Jonathan Chambers that figured out
	why the debugger/port supplier was not working, and got
	things moving in the right path!

	See "Directions" for more details.

* Requirements

	You will need Visual Studio 2008 Standard Edition.  

	A useful addition might be the Visual Studio 2008 SDK,
	but so far it is not necessary to have it installed.

* Building and running

	You must start Visual Studio as administrator, on Vista
	this is done by right clicking on the Visual Studio 2008
	icon and selecting "Run as Administrator".

	This is necessary to allow the Addin to be registered
	with COM (necessary to start the debugger in the first
	place).

	You *must* edit the MonoAddin/MonoAddin.Addin file and update
	the <Assembly> section to include the full path, at this point
	you could launch the new Visual Studio.

	On the Linux side: Make sure that you turn off your firewall
	as well, the server listens on port 7777 and that you go into
	the Server directory, and type make, followed by "make run".

	A common problem that you will encouter when running
	multiple versions of Visual Studio is that you will end
	up loading the Addin repeatedly, and that will prevent
	the build from happening (VS will complain about not
	being able to overwrite a file because it is in use).

	To solve this problem, make sure that you start Visual
	with no working DLL files in your build directories
	(bin/) or you will not be able to build.


* The Current Setup

	I started with an Addin (MonoAddin) and the hand-crafted 
	Mono.VisualStudio.Debugger because I was following the model
	explained in DebugEngineSample, but it is possible that all
	the code could live in a single DLL instead of two. We need to
	figure out if we want to merge the assemblies, or have a shared 
	assembly that both references for things like Settings. Right 
	now the file is shared between the projects, but that is a hack.

	The Addin is supposed to (pieces with (+) are done):

	* (+) Provide MDB debugger files from the PDB ones.
	*     Transfer the files to Linux (.exe, dll, .mdb, data files).
	* (+) Launch the DebugEngine (Mono.VisualStudio.Debugger).
	*     Provide configuration of the plugin. (Started)
	*     Provide discovery of Linux/Mono installations hosts.

	The Debug Engine needs to:
	* (+) Get Loaded
	* 	Connect to the remote Linux system
	* 	Expose its interface to the remote system.
	*  	Send commands from VS to the remote debugger.
	* ...

* The Debug Engine

	The PortSupplier allows us to connect to multiple different
	machines, currently we provide for connecting to a single host.
	This is configurable in the Settings dialog. The data is persisted
	to the users local Application Data folder (%APPDATA%) under a
	MonoAddin subdirectory.

* Style - Remoting

	When using Remoting, one of the problems is that all entry
	points could throw an exception, and if they do, they will
	propagate errors from the client side to the server, including
	the assembly that caused it (from the exception) like
	Mono.Debugger.

	We should switch to an explicit error checking system, and use
	try/catch on all remoting entry points (Contract.cs) and
	return stringified errors, like:

		string DoSomething (...)
		{
			try {
			    ...

			    // empty string is success
			    return null;
			} catch (Exception e){
			    return e.ToString ();
			}
		}

* Common Problems

	If code fails to communicate when you have been adding classes
	or methods to the RemotingContract, make sure that all of your
	classes derive from MarshalByRefObject.

* Style - naming

	I am not quite happy with the style conventions used by our
	interfaces.   

	To ameliorate some of the problems, in Server/* I have been using:

	   using MDB=Mono.Debugger

	And prefixing all of the Mono.Debugger types with that, to deambiguate.   


* Directions

	Few things to implement, feel free to add to the list:

		* Fill out the various events in Server* that
	  	  are currently calling "Abort", the next one on
		  the list is OnThreadCreated

		* Debugger configuration (to configure the target
	  	  server).

		* Copying of the obj/Debug/file.exe.mdb to 
				 bin/Debug/file.exe.mdb

	   	  Have not figured that one out yet.

		* In addition to the current setup (shared directories)
		  it would be useful to have a "Deploy to Server" configuration
		  for the cases where sharing is not possible or desired.

		  We should look into implementing something like zsync
		  (http-based rsync).

	Low priority:

		* Debug/Attach does not seem to work, the
		  Port supplier returns the enumerator, but
		  crashes.


* Creating a VSPackage


 	It seems that the debugger should be a VSPackage (and perhaps
	the Mono.Addin should be turned into a package as well, and
	maybe even merged).

	Currently we do not do this, and just have an AddIn and a 
	standalone library.   To activate the standalone library,
	we are using a sample program "RegisterDebugger" that 
	populates the registry with the keys necessary to get 
	the Debug Engine registered.

	To turn at least the Mono.VisualStudio.Debugger into a VSPackage
	considering that *currently* it exposes COM (in Properties for the
	project, "Register for COM interop") it is necessary to
	install this hotfix:

		https://connect.microsoft.com/VisualStudio/Downloads/DownloadDetails.aspx?DownloadID=10671

	It is possible that creating a standard VSPackage might solve
	this (this is coded by hand, not from a template).

* Debugging Visual Studio and COM

	I suggest that you use Process Monitor from sysinternals.com
	as this tool will point out errors for example when VS
	fails to activate your components (failed lookups on registry
	keys).

